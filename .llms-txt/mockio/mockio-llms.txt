├── .github
    ├── FUNDING.yml
    └── workflows
    │   ├── build.yml
    │   └── docs.yml
├── .gitignore
├── .golangci.yml
├── LICENSE
├── Makefile
├── README.md
├── config
    └── config.go
├── docs
    ├── features
    │   ├── captors.md
    │   ├── configuration.md
    │   ├── error-reporting.md
    │   ├── matchers.md
    │   ├── method-stubbing.md
    │   ├── parallel-execution.md
    │   └── verification.md
    ├── index.md
    ├── limitations.md
    ├── requirements.txt
    └── sponsors.md
├── go.mod
├── go.sum
├── matchers
    ├── capture.go
    ├── matchers.go
    ├── reporter.go
    ├── returners.go
    └── verification.go
├── mkdocs.yml
├── mock
    └── api.go
├── mockopts
    └── options.go
├── registry
    ├── captor.go
    ├── handler.go
    ├── matchers.go
    ├── registry.go
    ├── reporter.go
    ├── returners.go
    ├── state.go
    └── util.go
├── tests
    ├── captor
    │   └── captor_test.go
    ├── check
    │   └── check_test.go
    ├── common
    │   └── common.go
    ├── concurrent
    │   └── concurrent_test.go
    ├── match
    │   └── match_test.go
    ├── mocking
    │   └── mock_test.go
    ├── reporting
    │   └── error_reporting_test.go
    ├── returners
    │   └── returners_test.go
    ├── simple
    │   └── simple_test.go
    ├── variadic
    │   └── variadic_test.go
    ├── verify
    │   └── verify_test.go
    └── when
    │   ├── when_double_test.go
    │   ├── when_single_test.go
    │   └── when_test.go
└── threadlocal
    └── threadlocal.go


/.github/FUNDING.yml:
--------------------------------------------------------------------------------
1 | github: [ovechkin-dm]
2 | 
3 | 


--------------------------------------------------------------------------------
/.github/workflows/build.yml:
--------------------------------------------------------------------------------
 1 | # Workflow file of GitHub Actions
 2 | 
 3 | name: build
 4 | 
 5 | on:
 6 |   push:
 7 |     branches:
 8 |       - main
 9 |       - feature/**
10 |   pull_request:
11 |     branches:
12 |       - main
13 | 
14 | jobs:
15 |   Lint:
16 |     runs-on: ubuntu-latest
17 |     steps:
18 |       - name: Checkout scm
19 |         uses: actions/checkout@v3
20 | 
21 |       - name: Set up Go
22 |         uses: actions/setup-go@v4
23 |         with:
24 |           go-version-file: go.mod
25 | 
26 |       - name: Lint
27 |         uses: golangci/golangci-lint-action@v7
28 |         with:
29 |           version: v2.0.2
30 | 
31 |   CodeQL:
32 |     needs: Lint
33 |     runs-on: ubuntu-latest
34 |     steps:
35 |       - name: Checkout scm
36 |         uses: actions/checkout@v3
37 | 
38 |       - name: Set up Go
39 |         uses: actions/setup-go@v4
40 |         with:
41 |           go-version-file: go.mod
42 | 
43 |       - name: Initialize CodeQL
44 |         uses: github/codeql-action/init@v2
45 |         with:
46 |           languages: go
47 | 
48 |       - name: Perform CodeQL Analysis
49 |         uses: github/codeql-action/analyze@v2
50 | 
51 |   Test:
52 |     needs: Lint
53 |     runs-on: ${{ matrix.runs-on }}
54 |     strategy:
55 |       fail-fast: false
56 |       matrix:
57 |         os: [linux]
58 |         arch: [ amd64, arm64 ]
59 |         go: [ '1.20', '1.22', '1.23' ]
60 |         include:
61 |           - os: linux
62 |             runs-on: ubuntu-22.04
63 |     steps:
64 |       - name: Checkout scm
65 |         uses: actions/checkout@v3
66 | 
67 |       - name: Set up Go
68 |         uses: actions/setup-go@v4
69 |         with:
70 |           go-version: ${{ matrix.go }}
71 | 
72 |       - name: 'Test on linux [amd64]'
73 |         if: ${{ matrix.os == 'linux' && contains(fromJson('["amd64"]'), matrix.arch) }}
74 |         env:
75 |           GOOS: ${{ matrix.os }}
76 |           GOARCH: ${{ matrix.arch }}
77 |         run: go test -race -v -coverprofile="coverage.txt" -coverpkg=./... ./...
78 | 
79 |       - name: 'Setup qemu-user-static on [linux] arch [arm64]'
80 |         if: ${{ matrix.os == 'linux' && contains(fromJson('["arm64"]'), matrix.arch) }}
81 |         run: |
82 |           sudo apt-get update
83 |           sudo apt-get -y install qemu-user-static
84 | 
85 |       - name: 'Test on [linux] arch [arm64]'
86 |         if: ${{ matrix.os == 'linux' && contains(fromJson('["arm64"]'), matrix.arch) }}
87 |         env:
88 |           GOOS: ${{ matrix.os }}
89 |           GOARCH: ${{ matrix.arch }}
90 |         run: go test -coverpkg=./... ./...
91 | 
92 |       - name: Codecov
93 |         uses: codecov/codecov-action@v3
94 |         with:
95 |           token: ${{ secrets.CODECOV_TOKEN }}
96 |           name: Codecov on ${{ matrix.os }}/${{ matrix.arch }} go${{ matrix.go }}
97 |           fail_ci_if_error: false
98 | 


--------------------------------------------------------------------------------
/.github/workflows/docs.yml:
--------------------------------------------------------------------------------
 1 | name: docs
 2 | on:
 3 |   push:
 4 |     tags:
 5 |       - 'v*.*.*'
 6 | permissions:
 7 |   contents: write
 8 | jobs:
 9 |   deploy:
10 |     runs-on: ubuntu-latest
11 |     steps:
12 |       - uses: actions/checkout@v3
13 |       - uses: actions/setup-python@v4
14 |         with:
15 |           python-version: 3.x
16 |       - uses: actions/cache@v2
17 |         with:
18 |           key: ${{ github.ref }}
19 |           path: .cache
20 |       - run: sudo apt-get install -y libcairo2-dev libfreetype6-dev libffi-dev libjpeg-dev libpng-dev libz-dev
21 |       - run: pip install -r docs/requirements.txt
22 |         env:
23 |           GH_TOKEN: ${{ secrets.GH_TOKEN }}
24 |       - name: Setup git
25 |         run: |
26 |           git config --global user.name mockio-actions
27 |           git config --global user.email mockio-actions@ovechkin-dm.github.io
28 |           git fetch origin gh-pages --depth=1
29 |       - name: Deploy docs
30 |         run: "mike deploy --push --update-aliases $(echo ${{ github.ref_name }} | cut -d'.' -f1-2 | xargs printf '%s.0' ) latest"


--------------------------------------------------------------------------------
/.gitignore:
--------------------------------------------------------------------------------
1 | coverage.txt
2 | .cache
3 | .idea
4 | *.dylib


--------------------------------------------------------------------------------
/.golangci.yml:
--------------------------------------------------------------------------------
 1 | version: "2"
 2 | run:
 3 |   timeout: 10m
 4 | linters:
 5 |   default: none
 6 |   enable:
 7 |     - asciicheck
 8 |     - bidichk
 9 |     - errcheck
10 |     - govet
11 |     - ineffassign
12 |     - staticcheck
13 |     - unused
14 | formatters:
15 |   enable:
16 |     - gci
17 |     - gofumpt
18 |   settings:
19 |     gci:
20 |       sections:
21 |         - standard
22 |         - default
23 |         - prefix(github.com/ovechkin-dm/mockio)
24 |         - blank
25 |         - dot
26 |         - alias
27 | 


--------------------------------------------------------------------------------
/LICENSE:
--------------------------------------------------------------------------------
 1 | MIT License
 2 | 
 3 | Copyright (c) 2019 jet-black
 4 | 
 5 | Permission is hereby granted, free of charge, to any person obtaining a copy
 6 | of this software and associated documentation files (the "Software"), to deal
 7 | in the Software without restriction, including without limitation the rights
 8 | to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 9 | copies of the Software, and to permit persons to whom the Software is
10 | furnished to do so, subject to the following conditions:
11 | 
12 | The above copyright notice and this permission notice shall be included in all
13 | copies or substantial portions of the Software.
14 | 
15 | THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16 | IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
17 | FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
18 | AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
19 | LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
20 | OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
21 | SOFTWARE.


--------------------------------------------------------------------------------
/Makefile:
--------------------------------------------------------------------------------
 1 | all: gofumpt import lint
 2 | 
 3 | init:
 4 | 	go install mvdan.cc/gofumpt@v0.6.0
 5 | 	go install github.com/golangci/golangci-lint/v2/cmd/golangci-lint@v2.0.2
 6 | 	go install github.com/daixiang0/gci@v0.12.3
 7 | 
 8 | lint:
 9 | 	golangci-lint run ./...
10 | 
11 | gofumpt:
12 | 	gofumpt -l -w .
13 | 
14 | import:
15 | 	gci write --skip-generated -s standard -s default -s "prefix(github.com/ovechkin-dm/mockio)" -s blank -s dot -s alias .
16 | 


--------------------------------------------------------------------------------
/README.md:
--------------------------------------------------------------------------------
 1 | # Mockio 
 2 | 
 3 | [![Build Status](https://github.com/ovechkin-dm/mockio/actions/workflows/build.yml/badge.svg)](https://github.com/ovechkin-dm/mockio/actions)
 4 | [![Codecov](https://codecov.io/gh/ovechkin-dm/mockio/branch/main/graph/badge.svg)](https://app.codecov.io/gh/ovechkin-dm/mockio)
 5 | [![Go Report Card](https://goreportcard.com/badge/github.com/ovechkin-dm/mockio)](https://goreportcard.com/report/github.com/ovechkin-dm/mockio)
 6 | [![Documentation](https://pkg.go.dev/badge/github.com/ovechkin-dm/mockio.svg)](https://pkg.go.dev/github.com/ovechkin-dm/mockio)
 7 | [![Release](https://img.shields.io/github/release/ovechkin-dm/mockio.svg)](https://github.com/ovechkin-dm/mockio/releases)
 8 | [![License](https://img.shields.io/github/license/ovechkin-dm/mockio.svg)](https://github.com/ovechkin-dm/mockio/blob/main/LICENSE)
 9 | 
10 | # Mock library for golang without code generation
11 | Mockio is a Golang library that provides functionality for mocking and stubbing functions and methods in tests inspired by mockito. The library is designed to simplify the testing process by allowing developers to easily create test doubles for their code, which can then be used to simulate different scenarios.
12 | 
13 | # Documentation
14 | 
15 | Latest documentation is available [here](https://ovechkin-dm.github.io/mockio/latest/)
16 | 
17 | # Quick start
18 | 
19 | Install latest version of the library using go get command:
20 | 
21 | ```bash
22 | go get -u github.com/ovechkin-dm/mockio
23 | ```
24 | 
25 | Create a simple mock and test:
26 | ```go
27 | package main
28 | 
29 | import (
30 |     . "github.com/ovechkin-dm/mockio/mock"
31 |     "testing"
32 | )
33 | 
34 | type Greeter interface {
35 |     Greet(name string) string
36 | }
37 | 
38 | func TestGreet(t *testing.T) {
39 |     SetUp(t)
40 |     m := Mock[Greeter]()
41 |     WhenSingle(m.Greet("John")).ThenReturn("Hello, John!")
42 |     if m.Greet("John") != "Hello, John!" {
43 |         t.Fail()
44 |     }
45 | }
46 | ```


--------------------------------------------------------------------------------
/config/config.go:
--------------------------------------------------------------------------------
 1 | package config
 2 | 
 3 | type Option func(*MockConfig)
 4 | 
 5 | type MockConfig struct {
 6 | 	PrintStackTrace bool
 7 | 	StrictVerify    bool
 8 | }
 9 | 
10 | func NewConfig() *MockConfig {
11 | 	return &MockConfig{
12 | 		PrintStackTrace: true,
13 | 		StrictVerify:    false,
14 | 	}
15 | }
16 | 


--------------------------------------------------------------------------------
/docs/features/captors.md:
--------------------------------------------------------------------------------
 1 | # Argument Captors
 2 | 
 3 | Argument captors are a powerful feature that allow you to capture the arguments passed to a method when it is
 4 | called. This is useful when you want to verify that a method was called with specific arguments, but you don't know what
 5 | those arguments will be ahead of time.
 6 | 
 7 | ## Creating a Captor
 8 | 
 9 | To create a captor, you simply call the `Captor` function with the type of the argument you want to capture:
10 | 
11 | ```go
12 | c := Captor[string]()
13 | ```
14 | 
15 | ## Using a Captor
16 | 
17 | To use a captor, you pass it as an argument to the `When` function. When the method is called, the captor will capture the
18 | argument and store it in the captor's value:
19 | 
20 | ```go
21 | When(greeter.Greet(c.Capture())).ThenReturn("Hello, world!")
22 | ```
23 | 
24 | ## Retrieving the Captured Values
25 | 
26 | Argument captor records an argument on each stub call. You can retrieve the captured values by calling the `Values` method
27 | 
28 | ```go
29 | capturedValues := c.Values()
30 | ```
31 | 
32 | If you want to retrieve just the last captured value, you can call the `Last` method
33 | 
34 | ```go
35 | capturedValue := c.Last()
36 | ```
37 | 
38 | ## Example usage
39 | 
40 | In this example we will create a mock, and use an argument captor to capture the arguments passed to the `Greet` method:
41 | 
42 | ```go
43 | package main
44 | 
45 | import (
46 | 	. "github.com/ovechkin-dm/mockio/mock"
47 | 	"testing"
48 | )
49 | 
50 | type Greeter interface {
51 | 	Greet(name any) string
52 | }
53 | 
54 | func TestSimple(t *testing.T) {
55 | 	SetUp(t)
56 | 	greeter := Mock[Greeter]()
57 | 	c := Captor[string]()
58 | 	When(greeter.Greet(c.Capture())).ThenReturn("Hello, world!")
59 | 	_ = greeter.Greet("John")
60 | 	_ = greeter.Greet("Jane")
61 | 	if c.Values()[0] != "John" {
62 | 		t.Error("Expected John, got", c.Values()[0])
63 | 	}
64 | 	if c.Values()[1] != "Jane" {
65 | 		t.Error("Expected Jane, got", c.Values()[1])
66 | 	}
67 | }
68 | ```


--------------------------------------------------------------------------------
/docs/features/configuration.md:
--------------------------------------------------------------------------------
  1 | # Configuration
  2 | 
  3 | ## Using options
  4 | 
  5 | MockIO library can be configured by providing options from `mockopts` package inside `SetUp` function like this:
  6 | ```go
  7 | package main
  8 | 
  9 | import (
 10 | 	. "github.com/ovechkin-dm/mockio/mock"
 11 | 	"github.com/ovechkin-dm/mockio/mockopts"
 12 | 	"testing"
 13 | )
 14 | 
 15 | func TestSimple(t *testing.T) {
 16 | 	SetUp(t, mockopts.WithoutStackTrace())
 17 | }
 18 | 
 19 | ```
 20 | 
 21 | ## StrictVerify
 22 | **StrictVerify** adds extra checks on each test teardown. 
 23 | It will fail the test if there are any unverified calls.
 24 | It will also fail the test if there are any calls that were not expected.
 25 | 
 26 | ### Unverified calls check
 27 | 
 28 | Consider the following example:
 29 | ```go
 30 | package main
 31 | 
 32 | import (
 33 | 	. "github.com/ovechkin-dm/mockio/mock"
 34 | 	"github.com/ovechkin-dm/mockio/mockopts"
 35 | 	"testing"
 36 | )
 37 | 
 38 | type Greeter interface {
 39 | 	Greet(name string) string
 40 | }
 41 | 
 42 | func TestSimple(t *testing.T) {
 43 | 	SetUp(t, mockopts.StrictVerify())
 44 | 	greeter := Mock[Greeter]()
 45 | 	When(greeter.Greet("John")).ThenReturn("Hello, John!")
 46 | }
 47 | 
 48 | ```
 49 | In this case, the test will fail because the `Greet` method was not called with the expected argument.
 50 | If we want this test to pass, we need to call greeter with the expected argument:
 51 | ```go
 52 | func TestSimple(t *testing.T) {
 53 | 	SetUp(t, mockopts.StrictVerify())
 54 | 	greeter := Mock[Greeter]()
 55 | 	When(greeter.Greet("John")).ThenReturn("Hello, John!")
 56 | 	greeter.Greet("John")
 57 | }
 58 | ```
 59 | 
 60 | ### Unexpected calls check
 61 | 
 62 | Consider the following example:
 63 | 
 64 | ```go
 65 | func TestSimple(t *testing.T) {
 66 |     SetUp(t, mockopts.StrictVerify())
 67 |     greeter := Mock[Greeter]()
 68 |     When(greeter.Greet("John")).ThenReturn("Hello, John!")
 69 |     greeter.Greet("John")
 70 |     greeter.Greet("Jane")
 71 | }
 72 | ```
 73 | 
 74 | In this case, the test will fail because the `Greet` method was called with an unexpected argument.
 75 | If we want this test to pass, we need to remove the unexpected call, or add an expectation for it:
 76 | ```go
 77 | func TestSimple(t *testing.T) {
 78 |     SetUp(t, mockopts.StrictVerify())
 79 |     greeter := Mock[Greeter]()
 80 |     When(greeter.Greet("John")).ThenReturn("Hello, John!")
 81 |     When(greeter.Greet("Jane")).ThenReturn("Hello, Jane!")
 82 |     greeter.Greet("John")
 83 |     greeter.Greet("Jane")
 84 | }
 85 | ```
 86 | 
 87 | ## WithoutStackTrace
 88 | **WithoutStackTrace** option disables stack trace printing in case of test failure.
 89 | 
 90 | Consider the following example:
 91 | ```go
 92 | package main
 93 | 
 94 | import (
 95 | 	. "github.com/ovechkin-dm/mockio/mock"
 96 | 	"testing"
 97 | )
 98 | 
 99 | type Greeter interface {
100 | 	Greet(name string) string
101 | }
102 | 
103 | func TestSimple(t *testing.T) {
104 | 	SetUp(t)
105 | 	greeter := Mock[Greeter]()
106 | 	When(greeter.Greet("Jane")).ThenReturn("hello world")
107 | 	greeter.Greet("John")
108 | 	VerifyNoMoreInteractions(greeter)
109 | }
110 | 
111 | ```
112 | 
113 | If we run this test, we will see the following error:
114 | ```
115 | === RUN   TestSimple
116 |     reporter.go:75: At:
117 |         	go/pkg/mod/github.com/ovechkin-dm/mockio@v0.7.2/registry/registry.go:130 +0x45
118 |         Cause:
119 |         	No more interactions expected, but unverified interactions found:
120 |         		Greeter.Greet(John) at demo/hello_test.go:16 +0xf2
121 |         Trace:
122 |         demo.TestSimple.VerifyNoMoreInteractions.VerifyNoMoreInteractions.func1()
123 |         	go/pkg/mod/github.com/ovechkin-dm/mockio@v0.7.2/registry/registry.go:130 +0x45
124 |         demo.TestSimple(0xc00018c4e0?)
125 |         	demo/hello_test.go:17 +0x15a
126 |         testing.tRunner(0xc00018c4e0, 0x647ca0)
127 |         	/usr/local/go/src/testing/testing.go:1689 +0xfb
128 |         created by testing.(*T).Run in goroutine 1
129 |         	/usr/local/go/src/testing/testing.go:1742 +0x390
130 |         
131 | --- FAIL: TestSimple (0.00s)
132 | 
133 | FAIL
134 | ```
135 | 
136 | By adding `mockopts.WithoutStackTrace()` to the `SetUp` function, we can disable stack trace printing:
137 | ```go
138 | func TestSimple(t *testing.T) {
139 | 	SetUp(t, mockopts.WithoutStackTrace())
140 | 	greeter := Mock[Greeter]()
141 | 	When(greeter.Greet("Jane")).ThenReturn("hello world")
142 | 	greeter.Greet("John")
143 | 	VerifyNoMoreInteractions(greeter)
144 | }
145 | ```
146 | 
147 | Now the error will look like this:
148 | ```
149 | === RUN   TestSimple
150 |     reporter.go:75: At:
151 |         	go/pkg/mod/github.com/ovechkin-dm/mockio@v0.7.2/registry/registry.go:130 +0x45
152 |         Cause:
153 |         	No more interactions expected, but unverified interactions found:
154 |         		Greeter.Greet(John) at demo/hello_test.go:17 +0x10b
155 | --- FAIL: TestSimple (0.00s)
156 | 
157 | FAIL
158 | ```


--------------------------------------------------------------------------------
/docs/features/error-reporting.md:
--------------------------------------------------------------------------------
  1 | # Error reporting
  2 | 
  3 | `Mockio` library supports providing custom error reporting in `SetUp()` function.
  4 | This can be helpful if you want to introduce custom error reporting or logging.
  5 | Reporter should implement `ErrorReporter` interface.
  6 | ```go
  7 | type ErrorReporter interface {
  8 | 	Fatalf(format string, args ...any)
  9 | 	Errorf(format string, args ...any)
 10 | 	Cleanup(func())
 11 | }
 12 | 
 13 | ```
 14 | 
 15 | * `Fatalf` - should be used to report fatal errors. It should stop the test execution.
 16 | * `Errorf` - should be used to report non-fatal errors. It should continue the test execution.  
 17 | * `Cleanup` - should be used to register a cleanup function. It should be called after the test execution.
 18 | 
 19 | ## Error output
 20 | 
 21 | ### Incorrect `When` usage
 22 | 
 23 | Example:
 24 | 
 25 | ```go
 26 | When(1)
 27 | ```
 28 | 
 29 | Output:
 30 | ```
 31 | At:
 32 | 	/demo/error_reporting_test.go:22 +0xad
 33 | Cause:
 34 | 	When() requires an argument which has to be 'a method call on a mock'.
 35 | 	For example: When(mock.GetArticles()).ThenReturn(articles)
 36 | ```
 37 | 
 38 | ### Verify from different goroutine
 39 | 
 40 | Example:
 41 | 
 42 | ```go
 43 | SetUp(r)
 44 | mock := Mock[Foo]()
 45 | wg := sync.WaitGroup{}
 46 | wg.Add(1)
 47 | go func() {
 48 |     SetUp(r)
 49 |     Verify(mock, Once())
 50 |     wg.Done()
 51 | }()
 52 | wg.Wait()
 53 | ```
 54 | 
 55 | Output:
 56 | ```
 57 | At:
 58 | 	/demo/error_reporting_test.go:35 +0xc5
 59 | Cause:
 60 | 	Argument passed to Verify() is {<nil> DynamicProxy[reporting.Foo] <nil>} and is not a mock, or a mock created in a different goroutine.
 61 | 	Make sure you place the parenthesis correctly.
 62 | 	Example of correct verification:
 63 | 		Verify(mock, Times(10)).SomeMethod()
 64 | ```
 65 | 
 66 | ### Non-mock verification
 67 | 
 68 | Example:
 69 | 
 70 | ```go
 71 | Verify(100, Once())
 72 | ```
 73 | 
 74 | Output:
 75 | ```
 76 | At:
 77 | 	/demo/error_reporting_test.go:46 +0x105
 78 | Cause:
 79 | 	Argument passed to Verify() is 100 and is not a mock, or a mock created in a different goroutine.
 80 | 	Make sure you place the parenthesis correctly.
 81 | 	Example of correct verification:
 82 | 		Verify(mock, Times(10)).SomeMethod()
 83 | ```
 84 | 
 85 | ### Invalid use of matchers
 86 | 
 87 | Example:
 88 | 
 89 | ```go
 90 | When(mock.Baz(AnyInt(), AnyInt(), 10)).ThenReturn(10)
 91 | ```
 92 | 
 93 | Output:
 94 | ```
 95 | At:
 96 | 	/demo/error_reporting_test.go:55 +0x110
 97 | Cause:
 98 | 	Invalid use of matchers
 99 | 	3 expected, 2 recorded:
100 | 		/demo/error_reporting_test.go:55 +0xab
101 | 		/demo/error_reporting_test.go:55 +0xbc
102 | 	method:
103 | 		Foo.Baz(int, int, int) int
104 | 	expected:
105 | 		(int,int,int)
106 | 	got:
107 | 		(Any[int],Any[int])
108 | 	This can happen for 2 reasons:
109 | 		1. Declaration of matcher outside When() call
110 | 		2. Mixing matchers and exact values in When() call. Is this case, consider using "Exact" matcher.
111 | ```
112 | 
113 | ### Expected method call
114 | 
115 | Example:
116 | 
117 | ```go
118 | When(mock.Baz(AnyInt(), AnyInt(), AnyInt())).ThenReturn(10)
119 | _ = mock.Baz(10, 10, 11)
120 | Verify(mock, Once()).Baz(AnyInt(), AnyInt(), Exact(10))
121 | ```
122 | 
123 | Output:
124 | ```
125 | At:
126 | 	/demo/error_reporting_test.go:88 +0x262
127 | Cause:
128 | 	expected num method calls: 1, got : 0
129 | 		Foo.Baz(Any[int], Any[int], Exact(10))
130 | 	However, there were other interactions with this method:
131 | 		Foo.Baz(10, 10, 11) at /demo/error_reporting_test.go:87 +0x193
132 | ```
133 | 
134 | ### Number of method calls
135 | 
136 | Example:
137 | 
138 | ```go
139 | When(mock.Baz(AnyInt(), AnyInt(), AnyInt())).ThenReturn(10)
140 | _ = mock.Baz(10, 10, 10)
141 | Verify(mock, Times(20)).Baz(AnyInt(), AnyInt(), AnyInt())
142 | ```
143 | 
144 | Output:
145 | ```
146 | At:
147 | 	/demo/error_reporting_test.go:121 +0x25a
148 | Cause:
149 | 	expected num method calls: 20, got : 1
150 | 		Foo.Baz(Any[int], Any[int], Any[int])
151 | 	Invocations:
152 | 		/demo/error_reporting_test.go:120 +0x191
153 | ```
154 | 
155 | ### Empty captor
156 | 
157 | Example:
158 | 
159 | ```go
160 | c := Captor[int]()
161 | _ = c.Last()
162 | ```
163 | 
164 | Output:
165 | ```
166 | At:
167 | 	/demo/error_reporting_test.go:130 +0x92
168 | Cause:
169 | 	no values were captured for captor
170 | ```
171 | 
172 | ### Invalid return values
173 | 
174 | Example:
175 | 
176 | ```go
177 | When(mock.Baz(AnyInt(), AnyInt(), AnyInt())).ThenReturn(10, 20)
178 | ```
179 | 
180 | Output:
181 | ```
182 | At:
183 | 	/demo/error_reporting_test.go:140 +0x1a7
184 | Cause:
185 | 	invalid return values
186 | expected:
187 | 	Foo.Baz(int, int, int) int
188 | got:
189 | 	Foo.Baz(int, int, int) (string, int)
190 | ```
191 | 
192 | ### No more interactions
193 | 
194 | Example:
195 | 
196 | ```go
197 | When(mock.Baz(AnyInt(), AnyInt(), AnyInt())).ThenReturn("test", 10)
198 | _ = mock.Baz(10, 10, 10)
199 | _ = mock.Baz(10, 20, 10)
200 | VerifyNoMoreInteractions(mock)
201 | ```
202 | 
203 | Output:
204 | ```
205 | At:
206 | 	/demo/mockio/registry/registry.go:130 +0x45
207 | Cause:
208 | 	No more interactions expected, but unverified interactions found:
209 | 		Foo.Baz(10, 10, 10) at /demo/error_reporting_test.go:150 +0x1a8
210 | 		Foo.Baz(10, 20, 10) at /demo/error_reporting_test.go:151 +0x1c6
211 | ```
212 | 
213 | ### Unexpected matcher declaration
214 | 
215 | Example:
216 | 
217 | ```go
218 | When(mock.Baz(AnyInt(), AnyInt(), AnyInt())).ThenReturn(10)
219 | mock.Baz(AnyInt(), AnyInt(), AnyInt())
220 | Verify(mock, Once()).Baz(10, 10, 10)
221 | ```
222 | 
223 | ```go
224 | At:
225 | 	/demo/error_reporting_test.go:175 +0x23f
226 | Cause:
227 | 	Unexpected matchers declaration.
228 | 		at /demo/error_reporting_test.go:174 +0x185
229 | 		at /demo/error_reporting_test.go:174 +0x196
230 | 		at /demo/error_reporting_test.go:174 +0x1a7
231 | 	Matchers can only be used inside When() method call.
232 | ```


--------------------------------------------------------------------------------
/docs/features/matchers.md:
--------------------------------------------------------------------------------
  1 | # Matchers
  2 | MockIO library provides a lot of ways to match arguments of the method calls.
  3 | Matchers are used to define the expected arguments of the method calls.
  4 | 
  5 | We will use the following interface for the examples:
  6 | ```go
  7 | package main
  8 | 
  9 | import (
 10 | 	. "github.com/ovechkin-dm/mockio/mock"
 11 | 	"testing"
 12 | )
 13 | 
 14 | type Greeter interface {
 15 | 	Greet(name any) string
 16 | }
 17 | 
 18 | func TestSimple(t *testing.T) {
 19 | 	SetUp(t)
 20 | 	greeter := Mock[Greeter]()
 21 | 	When(greeter.Greet("Jane")).ThenReturn("hello world")
 22 | 	greeter.Greet("John")
 23 | }
 24 | ```
 25 | 
 26 | ## Any
 27 | The `Any[T]()` matcher matches any value of the type `T`.
 28 | 
 29 | This test will succeed:
 30 | ```go
 31 | func TestSimple(t *testing.T) {
 32 |     SetUp(t)
 33 |     greeter := Mock[Greeter]()
 34 |     When(greeter.Greet(Any[string]())).ThenReturn("hello world")
 35 |     if greeter.Greet("John") != "hello world" {
 36 |         t.Error("Expected 'hello world'")
 37 |     }
 38 | }
 39 | ```
 40 | 
 41 | ## AnyInt
 42 | The `AnyInt()` matcher matches any integer value. 
 43 | 
 44 | This test will succeed:
 45 | ```go
 46 | func TestSimple(t *testing.T) {
 47 | 	SetUp(t)
 48 | 	greeter := Mock[Greeter]()
 49 | 	When(greeter.Greet(Any[int]())).ThenReturn("hello world")
 50 | 	if greeter.Greet(10) != "hello world" {
 51 | 		t.Error("Expected 'hello world'")
 52 | 	}
 53 | }
 54 | ```
 55 | This test will fail, because the argument is not an integer:
 56 | ```go
 57 | func TestSimple(t *testing.T) {
 58 | 	SetUp(t)
 59 | 	greeter := Mock[Greeter]()
 60 | 	When(greeter.Greet(Any[int]())).ThenReturn("hello world")
 61 | 	if greeter.Greet("John") != "hello world" {
 62 | 		t.Error("Expected 'hello world'")
 63 | 	}
 64 | }
 65 | ```
 66 | 
 67 | ## AnyString
 68 | The `AnyString()` matcher matches any string value.
 69 | 
 70 | This test will succeed:
 71 | ```go
 72 | func TestSimple(t *testing.T) {
 73 | 	SetUp(t)
 74 | 	greeter := Mock[Greeter]()
 75 | 	When(greeter.Greet(Any[string]())).ThenReturn("hello world")
 76 | 	if greeter.Greet("John") != "hello world" {
 77 | 		t.Error("Expected 'hello world'")
 78 | 	}
 79 | }
 80 | ```
 81 | This test will fail, because the argument is not a string:
 82 | ```go
 83 | func TestSimple(t *testing.T) {
 84 | 	SetUp(t)
 85 | 	greeter := Mock[Greeter]()
 86 | 	When(greeter.Greet(Any[int]())).ThenReturn("hello world")
 87 | 	if greeter.Greet(10) != "hello world" {
 88 | 		t.Error("Expected 'hello world'")
 89 | 	}
 90 | }
 91 | ```
 92 | 
 93 | ## AnyInterface
 94 | The `AnyInterface()` matcher matches any value of any type.
 95 | 
 96 | This test will succeed:
 97 | ```go
 98 | func TestSimple(t *testing.T) {
 99 |     SetUp(t)
100 |     greeter := Mock[Greeter]()
101 |     When(greeter.Greet(AnyInterface())).ThenReturn("hello world")
102 |     if greeter.Greet("John") != "hello world" {
103 |         t.Error("Expected 'hello world'")
104 |     }
105 | }
106 | ```
107 | 
108 | This test will also succeed:
109 | ```go
110 | func TestSimple(t *testing.T) {
111 |     SetUp(t)
112 |     greeter := Mock[Greeter]()
113 |     When(greeter.Greet(AnyInterface())).ThenReturn("hello world")
114 |     if greeter.Greet(10) != "hello world" {
115 |         t.Error("Expected 'hello world'")
116 |     }
117 | }
118 | ```
119 | 
120 | ## AnyContext
121 | The `AnyContext()` matcher matches any context.Context value.
122 | 
123 | This test will succeed:
124 | ```go
125 | func TestSimple(t *testing.T) {
126 |     SetUp(t)
127 |     greeter := Mock[Greeter]()
128 |     When(greeter.Greet(AnyContext())).ThenReturn("hello world")
129 |     if greeter.Greet(context.Background()) != "hello world" {
130 |         t.Error("Expected 'hello world'")
131 |     }
132 | }
133 | ```
134 | 
135 | ## AnyOfType
136 | The `AnyOfType[T](t T)` matcher matches any value of the type `T` or its subtype. It is useful for type inference.
137 | 
138 | This test will succeed:
139 | ```go
140 | func TestSimple(t *testing.T) {
141 | 	SetUp(t)
142 | 	greeter := Mock[Greeter]()
143 | 	When(greeter.Greet(AnyOfType(10))).ThenReturn("hello world")
144 | 	if greeter.Greet(10) != "hello world" {
145 | 		t.Error("Expected 'hello world'")
146 | 	}
147 | }
148 | ```
149 | Note that when we are using AnyOfType, we don't need to specify the type explicitly.
150 | 
151 | ##  Nil
152 | The `Nil[T]()` matcher matches any nil value of the type `T`.
153 | 
154 | This test will succeed:
155 | ```go
156 | func TestSimple(t *testing.T) {
157 |     SetUp(t)
158 |     greeter := Mock[Greeter]()
159 |     When(greeter.Greet(Nil[any]())).ThenReturn("hello world")
160 |     if greeter.Greet(nil) != "hello world" {
161 |         t.Error("Expected 'hello world'")
162 |     }
163 | }
164 | ```
165 | 
166 | ## NotNil
167 | The `NotNil[T]()` matcher matches any non-nil value of the type `T`.
168 | 
169 | This test will succeed:
170 | ```go
171 | func TestSimple(t *testing.T) {
172 |     SetUp(t)
173 |     greeter := Mock[Greeter]()
174 |     When(greeter.Greet(NotNil[any]())).ThenReturn("hello world")
175 |     if greeter.Greet("John") != "hello world" {
176 |         t.Error("Expected 'hello world'")
177 |     }
178 | }
179 | ```
180 | 
181 | This test will fail:
182 | ```go
183 | func TestSimple(t *testing.T) {
184 |     SetUp(t)
185 |     greeter := Mock[Greeter]()
186 |     When(greeter.Greet(NotNil[any]())).ThenReturn("hello world")
187 |     if greeter.Greet(nil) != "hello world" {
188 |         t.Error("Expected 'hello world'")
189 |     }
190 | }
191 | ```
192 | 
193 | ## Regex
194 | The `Regex(pattern string)` matcher matches any string that matches the regular expression `pattern`.
195 | 
196 | This test will succeed:
197 | ```go
198 | func TestSimple(t *testing.T) {
199 |     SetUp(t)
200 |     greeter := Mock[Greeter]()
201 |     When(greeter.Greet(Regex("J.*"))).ThenReturn("hello world")
202 |     if greeter.Greet("John") != "hello world" {
203 |         t.Error("Expected 'hello world'")
204 |     }
205 | }
206 | ```
207 | 
208 | ## Substring
209 | The `Substring(sub string)` matcher matches any string that contains the substring `sub`.
210 | 
211 | This test will succeed:
212 | ```go
213 | func TestSimple(t *testing.T) {
214 |     SetUp(t)
215 |     greeter := Mock[Greeter]()
216 |     When(greeter.Greet(Substring("oh"))).ThenReturn("hello world")
217 |     if greeter.Greet("John") != "hello world" {
218 |         t.Error("Expected 'hello world'")
219 |     }
220 | }
221 | ```
222 | 
223 | ## SliceLen
224 | The `SliceLen(length int)` matcher matches any slice with the length `length`.
225 | 
226 | This test will succeed:
227 | ```go
228 | func TestSimple(t *testing.T) {
229 |     SetUp(t)
230 |     greeter := Mock[Greeter]()
231 |     When(greeter.Greet(SliceLen[int](2))).ThenReturn("hello world")
232 |     if greeter.Greet([]int{1, 2}) != "hello world" {
233 |         t.Error("Expected 'hello world'")
234 |     }
235 | }
236 | ```
237 | 
238 | This test will fail:
239 | ```go
240 | func TestSimple(t *testing.T) {
241 |     SetUp(t)
242 |     greeter := Mock[Greeter]()
243 |     When(greeter.Greet(SliceLen[int](2))).ThenReturn("hello world")
244 |     if greeter.Greet([]int{1, 2, 3}) != "hello world" {
245 |         t.Error("Expected 'hello world'")
246 |     }
247 | }
248 | ```
249 | 
250 | ## MapLen
251 | The `MapLen(length int)` matcher matches any map with the length `length`.
252 | 
253 | This test will succeed:
254 | ```go
255 | func TestSimple(t *testing.T) {
256 |     SetUp(t)
257 |     greeter := Mock[Greeter]()
258 |     When(greeter.Greet(MapLen[int, string](2))).ThenReturn("hello world")
259 |     if greeter.Greet(map[int]string{1: "one", 2: "two"}) != "hello world" {
260 |         t.Error("Expected 'hello world'")
261 |     }
262 | }
263 | ```
264 | 
265 | This test will fail:
266 | ```go
267 | func TestSimple(t *testing.T) {
268 |     SetUp(t)
269 |     greeter := Mock[Greeter]()
270 |     When(greeter.Greet(MapLen[int, string](2))).ThenReturn("hello world")
271 |     if greeter.Greet(map[int]string{1: "one", 2: "two", 3: "three"}) != "hello world" {
272 |         t.Error("Expected 'hello world'")
273 |     }
274 | }
275 | ```
276 | 
277 | ## SliceContains
278 | The `SliceContains[T any](values ...T)` matcher matches any slice that contains all the values `values`.
279 | 
280 | This test will succeed:
281 | ```go
282 | func TestSimple(t *testing.T) {
283 |     SetUp(t)
284 |     greeter := Mock[Greeter]()
285 |     When(greeter.Greet(SliceContains[int](1, 2))).ThenReturn("hello world")
286 |     if greeter.Greet([]int{1, 2, 3}) != "hello world" {
287 |         t.Error("Expected 'hello world'")
288 |     }
289 | }
290 | ```
291 | 
292 | This test will fail:
293 | ```go
294 | func TestSimple(t *testing.T) {
295 |     SetUp(t)
296 |     greeter := Mock[Greeter]()
297 |     When(greeter.Greet(SliceContains[int](1, 2))).ThenReturn("hello world")
298 |     if greeter.Greet([]int{1, 3}) != "hello world" {
299 |         t.Error("Expected 'hello world'")
300 |     }
301 | }
302 | ```
303 | 
304 | ## MapContains
305 | The `MapContains[K any, V any](keys ...K)` matcher matches any map that contains all the keys `keys`.
306 |  
307 | This test will succeed:
308 | ```go
309 | func TestSimple(t *testing.T) {
310 |     SetUp(t)
311 |     greeter := Mock[Greeter]()
312 |     When(greeter.Greet(MapContains[int, string](1, 2))).ThenReturn("hello world")
313 |     if greeter.Greet(map[int]string{1: "one", 2: "two", 3: "three"}) != "hello world" {
314 |         t.Error("Expected 'hello world'")
315 |     }
316 | }
317 | ```
318 | 
319 | This test will fail:
320 | ```go
321 | func TestSimple(t *testing.T) {
322 |     SetUp(t)
323 |     greeter := Mock[Greeter]()
324 |     When(greeter.Greet(MapContains[int, string](1, 2))).ThenReturn("hello world")
325 |     if greeter.Greet(map[int]string{1: "one", 3: "three"}) != "hello world" {
326 |         t.Error("Expected 'hello world'")
327 |     }
328 | }
329 | ```
330 | 
331 | ## SliceEqualUnordered
332 | 
333 | The `SliceEqualUnordered[T any](values []T)` matcher matches any slice that contains the same elements as `values`, but in any order.
334 | 
335 | This test will succeed:
336 | ```go
337 | func TestSimple(t *testing.T) {
338 |     SetUp(t)
339 |     greeter := Mock[Greeter]()
340 |     When(greeter.Greet(SliceEqualUnordered[int](1, 2))).ThenReturn("hello world")
341 |     if greeter.Greet([]int{2, 1}) != "hello world" {
342 |         t.Error("Expected 'hello world'")
343 |     }
344 | }
345 | ```
346 | 
347 | This test will fail:
348 | ```go
349 | func TestSimple(t *testing.T) {
350 |     SetUp(t)
351 |     greeter := Mock[Greeter]()
352 |     When(greeter.Greet(SliceEqualUnordered[int](1, 2))).ThenReturn("hello world")
353 |     if greeter.Greet([]int{1, 3}) != "hello world" {
354 |         t.Error("Expected 'hello world'")
355 |     }
356 | }
357 | ```
358 | 
359 | ## Exact
360 | 
361 | The `Exact` matcher matches any value that is equal to the expected value.
362 | `Exact` uses `==` operator to compare values.
363 | 
364 | This test will succeed:
365 | ```go
366 | func TestSimple(t *testing.T) {
367 | 	SetUp(t)
368 | 	greeter := Mock[Greeter]()
369 | 	world1 := "world"
370 | 	When(greeter.Greet(Exact(&world1))).ThenReturn("hello world")
371 | 	if greeter.Greet(&world1) != "hello world" {
372 | 		t.Error("Expected 'hello world'")
373 | 	}
374 | }
375 | ```
376 | 
377 | However, this test will fail, because although the values are equal, they are different pointers:
378 | ```go
379 | func TestSimple(t *testing.T) {
380 | 	SetUp(t)
381 | 	greeter := Mock[Greeter]()
382 | 	world1 := "world"
383 | 	world2 := "world"
384 | 	When(greeter.Greet(Exact(&world1))).ThenReturn("hello world")
385 | 	if greeter.Greet(&world2) != "hello world" {
386 | 		t.Error("Expected 'hello world'")
387 | 	}
388 | }
389 | ```
390 | 
391 | ## Equal
392 | 
393 | The `Equal` matcher matches any value that is equal to the expected value. `Equal` uses `reflect.DeepEqual` to compare values.
394 | 
395 | This test will succeed, because `reflect.DeepEqual` compares values by their content:
396 | ```go
397 | func TestSimple(t *testing.T) {
398 | 	SetUp(t)
399 | 	greeter := Mock[Greeter]()
400 | 	world1 := "world"
401 | 	world2 := "world"
402 | 	When(greeter.Greet(Equal(&world1))).ThenReturn("hello world")
403 | 	if greeter.Greet(&world2) != "hello world" {
404 | 		t.Error("Expected 'hello world'")
405 | 	}
406 | }
407 | ```
408 | 
409 | ## NotEqual
410 | 
411 | The `NotEqual` matcher matches any value that is not equal to the expected value. `NotEqual` uses `reflect.DeepEqual` to compare values.
412 | 
413 | This test will succeed:
414 | ```go
415 | func TestSimple(t *testing.T) {
416 |     SetUp(t)
417 |     greeter := Mock[Greeter]()
418 |     When(greeter.Greet(NotEqual("John"))).ThenReturn("hello world")
419 |     if greeter.Greet("world") != "hello world" {
420 |         t.Error("Expected 'hello John'")
421 |     }
422 | }
423 | 
424 | ```
425 | 
426 | ## OneOf 
427 | 
428 | The `OneOf` matcher matches any value that is equal to one of the expected values. `OneOf` uses `reflect.DeepEqual` to compare values.
429 | 
430 | This test will succeed:
431 | ```go
432 | func TestSimple(t *testing.T) {
433 | 	SetUp(t)
434 | 	greeter := Mock[Greeter]()
435 | 	When(greeter.Greet(OneOf("John", "Jane"))).ThenReturn("hello John or Jane")
436 | 	if greeter.Greet("Jane") != "hello John or Jane" {
437 | 		t.Error("expected 'hello John or Jane'")
438 | 	}
439 | }
440 | ```
441 | ## Custom matcher
442 | 
443 | Here is an example of a custom matcher that matches odd numbers only:
444 | 
445 | ```go
446 | func TestSimple(t *testing.T) {
447 | 	SetUp(t)
448 | 	greeter := Mock[Greeter]()
449 | 	odd := CreateMatcher[int]("odd", func(args []any, v int) bool {
450 | 		return v%2 == 1
451 | 	})
452 | 	When(greeter.Greet(odd())).ThenReturn("hello odd number")
453 | 	if greeter.Greet(1) != "hello odd number" {
454 | 		t.Error("expected ''hello odd number''")
455 | 	}
456 | }
457 | ```
458 | 
459 | For more examples on custom matchers see `Examples` section.
460 | 
461 | 


--------------------------------------------------------------------------------
/docs/features/method-stubbing.md:
--------------------------------------------------------------------------------
  1 | # Method stubbing
  2 | 
  3 | Method stubbing is a technique used in unit testing to replace a method with a stub. A stub is a small piece of code
  4 | that simulates the behavior of the method it replaces. This allows you to test the behavior of the code that calls the
  5 | method without actually executing the method itself.
  6 | 
  7 | Basic usage of method stubbing in Mockio looks like this:
  8 | 
  9 | ```go
 10 | When(mock.SomeMethod(AnyInt())).ThenReturn("some value")
 11 | ```
 12 | 
 13 | * `When` is a function that takes a method call as an argument and returns a `Returner` object.
 14 | * Inside the method call argument you can use any matcher from the library's API. In this example we used `AnyInt()` matcher.
 15 | * `ThenReturn` is a method of the `Returner`
 16 | 
 17 | This is basic usage of method stubbing. But there are also some useful extensions to this API.
 18 | 
 19 | ## When
 20 | 
 21 | `When` is a function that allows you to stub a method.
 22 | Keep in mind, that `When` is a generic function, so it does not provide any type check on return value.
 23 | 
 24 | 
 25 | ## WhenSingle 
 26 | 
 27 | `WhenSingle` is a function that allows you to stub a method to return a single value. 
 28 | It is almost the same as `When`, but it provides additional type check on return value.
 29 | 
 30 | Consider Following interface:
 31 | ```go
 32 | type Foo interface {
 33 |     Bar(int) string
 34 | }
 35 | ```
 36 | 
 37 | You can stub `Bar` method like this:
 38 | ```go
 39 | WhenSingle(mock.Bar(AnyInt())).ThenReturn("some value")
 40 | ```
 41 | 
 42 | However, this will not compile:
 43 | ```go
 44 | WhenSingle(mock.Bar(AnyInt())).ThenReturn(42)
 45 | ```
 46 | 
 47 | But this will:
 48 | ```go
 49 | When(mock.Bar(AnyInt())).ThenReturn(42)
 50 | ```
 51 | 
 52 | ## WhenDouble
 53 | 
 54 | `WhenDouble` is a function that allows you to stub a method to return two values.
 55 | It is almost the same as `When`, but it provides additional type check on return values.
 56 | 
 57 | Consider Following interface:
 58 | ```go
 59 | type Foo interface {
 60 |     Bar(int) (string, error)
 61 | }
 62 | ```
 63 | 
 64 | You can stub `Bar` method like this:
 65 | ```go
 66 | WhenDouble(mock.Bar(AnyInt())).ThenReturn("some value", nil)
 67 | ```
 68 | 
 69 | However, this will not compile:
 70 | ```go
 71 | WhenDouble(mock.Bar(AnyInt())).ThenReturn("some value", 42)
 72 | ```
 73 |  
 74 | But this will:
 75 | ```go
 76 | When(mock.Bar(AnyInt())).ThenReturn("some value", 42)
 77 | ```
 78 | 
 79 | ## ThenAnswer
 80 | 
 81 | `Answer` is a function that allows you to stub a method to return a value based on the arguments passed to the method.
 82 | 
 83 | Consider following interface:
 84 | ```go
 85 | type Foo interface {
 86 |     Bar(int) string
 87 | }
 88 | ```
 89 | 
 90 | You can stub `Bar` method like this:
 91 | ```go
 92 | mock := Mock[Foo]()
 93 | WhenSingle(mock.Bar(AnyInt())).ThenAnswer(func(args []any) string {
 94 |     return fmt.Sprintf("Hello, %d", args[0].(int))
 95 | })
 96 | ```
 97 | 
 98 | When `Bar` method is called with argument `42`, it will return `"Hello, 42"`.
 99 | 
100 | ## ThenReturn
101 | 
102 | You can chain multiple `ThenReturn` calls to return different values on subsequent calls:
103 | 
104 | ```go
105 | When(mock.SomeMethod(AnyInt())).
106 |     ThenReturn("first value").
107 |     ThenReturn("second value")
108 | ```
109 | 
110 | Calling `SomeMethod` first time will return `"first value"`, second time `"second value"`, and so on.
111 | 
112 | ## Implicit `Exact` matchers
113 | 
114 | Consider following interface:
115 | 
116 | ```go
117 | type Foo interface {
118 |     Bar(int, int) string
119 | }
120 | 
121 | ```
122 | 
123 | To stub `Bar` method, we can use something like this:
124 | ```go
125 | When(mock.Bar(Exact(1), Exact(2))).ThenReturn("some value")
126 | ```
127 | 
128 | However, this can be simplified to:
129 | ```go
130 | When(mock.Bar(1, 2)).ThenReturn("some value")
131 | ```
132 | 
133 | In short, you can omit using matchers when you want to match exact values, but they all should be exact.
134 | For example, this will not work:
135 | ```go
136 | When(mock.Bar(1, Exact(2))).ThenReturn("some value")
137 | ```
138 | 


--------------------------------------------------------------------------------
/docs/features/parallel-execution.md:
--------------------------------------------------------------------------------
 1 | # Parallel execution
 2 | 
 3 | ## Parallelism
 4 | 
 5 | It is possible to run multiple tests with mockio in parallel using the `--parallel` option. This option is available in the `test` and `run` commands.
 6 | 
 7 | ## Concurrency
 8 | 
 9 | Library supports invoking stubbed methods from different goroutine.
10 | 
11 | ```go
12 | func TestParallelSuccess(t *testing.T) {
13 | 	SetUp(t)
14 | 	greeter := Mock[Greeter]()
15 | 	wg := sync.WaitGroup{}
16 | 	wg.Add(2)
17 | 	When(greeter.Greet("John")).ThenReturn("hello world")
18 | 	go func() {
19 | 		greeter.Greet("John")
20 | 		wg.Done()
21 | 	}()
22 | 	go func() {
23 | 		greeter.Greet("John")
24 | 		wg.Done()
25 | 	}()
26 | 	wg.Wait()
27 | 	Verify(greeter, Times(2)).Greet("John")
28 | }
29 | ```
30 | 
31 | However, library does not support stubbing methods from different goroutine. 
32 | This test will result in error:
33 | 
34 | ```go
35 | func TestParallelFail(t *testing.T) {
36 | 	SetUp(t)
37 | 	greeter := Mock[Greeter]()
38 | 	wg := sync.WaitGroup{}
39 | 	wg.Add(2)
40 | 	go func() {
41 | 		When(greeter.Greet("John")).ThenReturn("hello world")
42 | 		wg.Done()
43 | 	}()
44 | 	go func() {
45 | 		When(greeter.Greet("John")).ThenReturn("hello world")
46 | 		wg.Done()
47 | 	}()
48 | 	wg.Wait()
49 | 	if greeter.Greet("John") != "hello world" {
50 | 		t.Error("Expected 'hello world'")
51 | 	}
52 | }
53 | ```
54 | 
55 | The main rule is that call to `When` should be in the same goroutine in which the mock is created.
56 | 
57 | Also, each time you create a mock in a newly created goroutine, you need to call `SetUp(t)` again to initialize the mockio library in that goroutine.
58 | 
59 | ```go
60 | func TestParallelSuccess(t *testing.T) {
61 | 	SetUp(t)
62 | 	wg := sync.WaitGroup{}
63 | 	wg.Add(1)
64 | 	go func() {
65 | 		SetUp(t)
66 | 		greeter := Mock[Greeter]()
67 | 		When(greeter.Greet("John")).ThenReturn("hello world")
68 | 		wg.Done()
69 | 	}()
70 | 	wg.Wait()
71 | }
72 | ```


--------------------------------------------------------------------------------
/docs/features/verification.md:
--------------------------------------------------------------------------------
  1 | # Verification
  2 | 
  3 | We will use the following interface for the examples:
  4 | ```go
  5 | package main
  6 | 
  7 | import (
  8 | 	. "github.com/ovechkin-dm/mockio/mock"
  9 | 	"testing"
 10 | )
 11 | 
 12 | type Greeter interface {
 13 | 	Greet(name any) string
 14 | }
 15 | 
 16 | func TestSimple(t *testing.T) {
 17 | 	SetUp(t)
 18 | 	greeter := Mock[Greeter]()
 19 | 	When(greeter.Greet("Jane")).ThenReturn("hello world")
 20 | 	greeter.Greet("John")
 21 | 
 22 | }
 23 | ```
 24 | 
 25 | ## Verify
 26 | 
 27 | To verify that a method was called, use the `Verify` function. 
 28 | If the method was called, the test will pass. If the method was not called, the test will fail.
 29 | 
 30 | This test will succeed:
 31 | ```go
 32 | func TestSimple(t *testing.T) {
 33 | 	SetUp(t)
 34 | 	greeter := Mock[Greeter]()
 35 | 	When(greeter.Greet("Jane")).ThenReturn("hello world")
 36 | 	greeter.Greet("John")
 37 | 	Verify(greeter, Once()).Greet("John")
 38 | }
 39 | ```
 40 | 
 41 | This test will fail:
 42 | ```go
 43 | func TestSimple(t *testing.T) {
 44 | 	SetUp(t)
 45 | 	greeter := Mock[Greeter]()
 46 | 	When(greeter.Greet("Jane")).ThenReturn("hello world")
 47 | 	greeter.Greet("John")
 48 | 	Verify(greeter, Once()).Greet("Jane")
 49 | }
 50 | ```
 51 | 
 52 | ### AtLeastOnce
 53 | 
 54 | Verify that a method was called at least once:
 55 | ```go
 56 | func TestSimple(t *testing.T) {
 57 |     SetUp(t)
 58 |     greeter := Mock[Greeter]()
 59 |     When(greeter.Greet("Jane")).ThenReturn("hello world")
 60 |     greeter.Greet("John")
 61 |     Verify(greeter, AtLeastOnce()).Greet("John")
 62 | }
 63 | ```
 64 | 
 65 | ### Once
 66 | 
 67 | Verify that a method was called exactly once:
 68 | ```go
 69 | func TestSimple(t *testing.T) {
 70 |     SetUp(t)
 71 |     greeter := Mock[Greeter]()
 72 |     When(greeter.Greet("Jane")).ThenReturn("hello world")
 73 |     greeter.Greet("John")
 74 |     Verify(greeter, Once()).Greet("John")
 75 | }
 76 | ```
 77 | 
 78 | ### Times
 79 | 
 80 | Verify that a method was called a specific number of times:
 81 | ```go
 82 | func TestSimple(t *testing.T) {
 83 |     SetUp(t)
 84 |     greeter := Mock[Greeter]()
 85 |     When(greeter.Greet("Jane")).ThenReturn("hello world")
 86 |     greeter.Greet("John")
 87 |     greeter.Greet("John")
 88 |     Verify(greeter, Times(2)).Greet("John")
 89 | }
 90 | ```
 91 | 
 92 | 
 93 | ## VerifyNoMoreInteractions
 94 | 
 95 | To verify that no other methods were called on the mock object, use the `VerifyNoMoreInteractions` function.
 96 | It will fail the test if there are any unverified calls.
 97 | 
 98 | This test will succeed:
 99 | ```go
100 | func TestSimple(t *testing.T) {
101 |     SetUp(t)
102 |     greeter := Mock[Greeter]()
103 |     When(greeter.Greet("Jane")).ThenReturn("hello world")
104 |     greeter.Greet("John")
105 |     Verify(greeter, Once()).Greet("John")
106 |     VerifyNoMoreInteractions(greeter)
107 | }
108 | ```
109 | 
110 | This test will fail:
111 | ```go
112 | func TestSimple(t *testing.T) {
113 |     SetUp(t)
114 |     greeter := Mock[Greeter]()
115 |     When(greeter.Greet("John")).ThenReturn("hello world")
116 |     greeter.Greet("John")
117 |     VerifyNoMoreInteractions(greeter)
118 | }
119 | ```
120 | 
121 | ## Verify after `ThenReturn`
122 | 
123 | Since it is common to actually verify that a stub was used correctly, you can use the `Verify` function after the `ThenReturn` function:
124 | ```go
125 | func TestSimple(t *testing.T) {
126 | 	SetUp(t)
127 | 	greeter := Mock[Greeter]()
128 | 	When(greeter.Greet("John")).ThenReturn("hello world").Verify(Once())
129 | 	greeter.Greet("John")
130 | 	VerifyNoMoreInteractions(greeter)
131 | }
132 | ```
133 | 


--------------------------------------------------------------------------------
/docs/index.md:
--------------------------------------------------------------------------------
 1 | # Mockio
 2 | 
 3 | Golang library for mocking without code generation, inspired by Mockito.
 4 | 
 5 | ## Installing library
 6 | 
 7 | Install latest version of the library using `go get` command:
 8 | 
 9 | ```bash
10 | go get -u github.com/ovechkin-dm/mockio
11 | ```
12 | 
13 | ## Creating test
14 | 
15 | Let's create an interface that we want to mock:
16 | 
17 | ```go
18 | type Greeter interface {
19 |     Greet(name string) string
20 | }
21 | ```
22 | 
23 | Now we will use `dot import` to simplify the usage of the library:
24 | 
25 | ```go
26 | import (
27 |     ."github.com/ovechkin-dm/mockio/mock"
28 |     "testing"
29 | )
30 | ```
31 | 
32 | Now we can create a mock for the `Greeter` interface, and test it's method `Greet`:
33 | 
34 | ```go
35 | func TestGreet(t *testing.T) {
36 |     SetUp(t)
37 |     m := Mock[Greeter]()
38 |     WhenSingle(m.Greet("John")).ThenReturn("Hello, John!")
39 |     if m.Greet("John") != "Hello, John!" {
40 |         t.Fail()
41 |     }
42 | }
43 | ```
44 | 
45 | ## Full example
46 | Here is the full listing for our simple test:
47 | 
48 | ```go
49 | package main
50 | 
51 | import (
52 | 	. "github.com/ovechkin-dm/mockio/mock"
53 | 	"testing"
54 | )
55 | 
56 | type Greeter interface {
57 | 	Greet(name string) string
58 | }
59 | 
60 | func TestGreet(t *testing.T) {
61 | 	SetUp(t)
62 | 	m := Mock[Greeter]()
63 | 	WhenSingle(m.Greet("John")).ThenReturn("Hello, John!")
64 | 	if m.Greet("John") != "Hello, John!" {
65 | 		t.Fail()
66 | 	}
67 | }
68 | 
69 | ```
70 | 
71 | That's it! You have created a mock for the `Greeter` interface without any code generation.
72 | As you can see, the library is very simple and easy to use.
73 | And no need to generate mocks for your interfaces.
74 | 


--------------------------------------------------------------------------------
/docs/limitations.md:
--------------------------------------------------------------------------------
 1 | # Limitations
 2 | 
 3 | ## Architecture
 4 | 
 5 | Because library uses assembly code to generate mocks, it is not possible to use it in pure Go code. 
 6 | This means that you cannot use it in a project that is intended to be cross-compiled to multiple platforms.
 7 | 
 8 | For now supported platforms are:
 9 | 
10 | - AMD64
11 | - ARM64 (M1-M3 macs are supported)
12 | 
13 | This list may be extended in the future.
14 | 
15 | ## Backwards compatibility and new Go versions
16 | 
17 | This library is tested for GO 1.18 up to 1.23
18 | 
19 | Caution: there is no guarantee that it will work with future versions of Go. 
20 | However there is not much that can break the library, so it should be easy to fix it if it stops working. As of latest mockio version, almost all of dependencies on golang internal runtime features were removed.
21 | 


--------------------------------------------------------------------------------
/docs/requirements.txt:
--------------------------------------------------------------------------------
1 | mike @ git+https://github.com/jimporter/mike.git
2 | mkdocs
3 | mkdocs-glightbox
4 | mkdocs-open-in-new-tab
5 | mkdocs-material
6 | cairosvg
7 | pillow


--------------------------------------------------------------------------------
/docs/sponsors.md:
--------------------------------------------------------------------------------
1 | # Sponsors list
2 | 
3 | Thanks to all the people who supported this project by donating money, 
4 | time or resources:
5 | 
6 | * [Ovechkin Dmitry](https://github.com/ovechkin-dm)
7 | * [Eray Ates](https://github.com/rytsh)
8 | * [Emilien Puget](https://github.com/emilien-puget)


--------------------------------------------------------------------------------
/go.mod:
--------------------------------------------------------------------------------
1 | module github.com/ovechkin-dm/mockio
2 | 
3 | go 1.21
4 | 
5 | require github.com/ovechkin-dm/go-dyno v0.3.2
6 | 
7 | require github.com/petermattis/goid v0.0.0-20240813172612-4fcff4a6cae7
8 | 


--------------------------------------------------------------------------------
/go.sum:
--------------------------------------------------------------------------------
1 | github.com/ovechkin-dm/go-dyno v0.3.0 h1:VLEA81c8/8LLKE4I0D+tl2ESFagORilszzfvLsF+cww=
2 | github.com/ovechkin-dm/go-dyno v0.3.0/go.mod h1:CcJNuo7AbePMoRNpM3i1jC1Rp9kHEMyWozNdWzR+0ys=
3 | github.com/ovechkin-dm/go-dyno v0.3.2 h1:jl0hE+o6M/egVVk1SljGw2GYkIEZFkzFWJ1nbqLyEbw=
4 | github.com/ovechkin-dm/go-dyno v0.3.2/go.mod h1:CcJNuo7AbePMoRNpM3i1jC1Rp9kHEMyWozNdWzR+0ys=
5 | github.com/petermattis/goid v0.0.0-20240813172612-4fcff4a6cae7 h1:Dx7Ovyv/SFnMFw3fD4oEoeorXc6saIiQ23LrGLth0Gw=
6 | github.com/petermattis/goid v0.0.0-20240813172612-4fcff4a6cae7/go.mod h1:pxMtw7cyUw6B2bRH0ZBANSPg+AoSud1I1iyJHI69jH4=
7 | 


--------------------------------------------------------------------------------
/matchers/capture.go:
--------------------------------------------------------------------------------
 1 | package matchers
 2 | 
 3 | // ArgumentCaptor is interface that allows capturing arguments
 4 | // passed to a mock method call.
 5 | //
 6 | // The Capture method is used to capture and store a single argument passed to a method call.
 7 | // The Last method is used to retrieve the last captured argument.
 8 | // The Values method is used to retrieve all captured arguments.
 9 | //
10 | // Example usage:
11 | //
12 | // // Create a mock object
13 | //
14 | //	m := Mock[Iface]()
15 | //
16 | //	// Create captor for int value
17 | //	c := Captor[int]()
18 | //
19 | //	// Use captor.Capture() inside When expression
20 | //	WhenSingle(m.Foo(AnyInt(), c.Capture())).ThenReturn(10)
21 | //
22 | //	m.Foo(10, 20)
23 | //	capturedValue := c.Last()
24 | //
25 | //	fmt.Printf("Captured value: %v\n", capturedValue)
26 | //
27 | // Output:
28 | //
29 | //	Captured value: 20
30 | type ArgumentCaptor[T any] interface {
31 | 	// Capture captures and stores a single argument passed to a method call.
32 | 	Capture() T
33 | 	// Last retrieves the last captured argument.
34 | 	Last() T
35 | 	// Values retrieves all captured arguments.
36 | 	Values() []T
37 | }
38 | 


--------------------------------------------------------------------------------
/matchers/matchers.go:
--------------------------------------------------------------------------------
 1 | package matchers
 2 | 
 3 | // Answer is a type alias for a function that can be used as a return value for mock function calls.
 4 | // This function takes a variable number of interface{} arguments and returns a slice of interface{} values.
 5 | // Each value in the returned slice corresponds to a return value for the mock function call.
 6 | // This type can be used to provide dynamic return values based on the input arguments passed to the mock function call.
 7 | type Answer = func(args []any) []any
 8 | 
 9 | // Matcher interface represents an object capable of matching method calls to specific criteria.
10 | //
11 | // A Matcher should implement the Match method, which takes a MethodCall and an actual parameter, and returns true
12 | // if the parameter satisfies the criteria defined by the Matcher.
13 | //
14 | // A Matcher should also implement the Description method, which returns a string describing the criteria defined by
15 | // the Matcher.
16 | //
17 | // Matchers can be used in conjunction with the Match function to create flexible and powerful method call matching
18 | // capabilities.
19 | type Matcher[T any] interface {
20 | 	// Description returns a string describing the criteria defined by the Matcher.
21 | 	Description() string
22 | 
23 | 	// Match returns true if the given method call satisfies the criteria defined by the Matcher.
24 | 	// The actual parameter represents the actual value passed to method.
25 | 	// The allArgs parameter represents all the arguments that were passed to a method.
26 | 	Match(allArgs []any, actual T) bool
27 | }
28 | 


--------------------------------------------------------------------------------
/matchers/reporter.go:
--------------------------------------------------------------------------------
 1 | package matchers
 2 | 
 3 | // ErrorReporter is an interface for reporting errors during test execution.
 4 | // Implementations of this interface should provide a way to fail the test with a message.
 5 | type ErrorReporter interface {
 6 | 	// Fatalf reports an error and fails the test execution.
 7 | 	// It formats the message according to a format specifier and arguments
 8 | 	// It can be used to report an error and provide additional context about the error.
 9 | 	Fatalf(format string, args ...any)
10 | 	// Errorf reports an error and continues the test execution.
11 | 	// It formats the message according to a format specifier and arguments
12 | 	// It can be used to report an error and provide additional context about the error.
13 | 	Errorf(format string, args ...any)
14 | 	// Cleanup adds hooks that are used to clean up data after test was executed.
15 | 	Cleanup(func())
16 | }
17 | 


--------------------------------------------------------------------------------
/matchers/returners.go:
--------------------------------------------------------------------------------
 1 | package matchers
 2 | 
 3 | type Returner interface {
 4 | 	Verify(verifier MethodVerifier)
 5 | }
 6 | 
 7 | // ReturnerSingle is interface that defines methods for returning a value or an answer
 8 | // for a mock function with one argument.
 9 | type ReturnerSingle[T any] interface {
10 | 	Returner
11 | 	// ThenReturn sets the return value for the mock function with one argument.
12 | 	// The return value must be of type T.
13 | 	ThenReturn(value T) ReturnerSingle[T]
14 | 	// ThenAnswer sets a function that will be called when the mock function is
15 | 	// called with one argument. The function must take a variable number of
16 | 	// arguments of type interface{} and return a value of type T.
17 | 	ThenAnswer(func(args []any) T) ReturnerSingle[T]
18 | }
19 | 
20 | // ReturnerDouble is an interface that provides methods to define the returned value and error of a mock function with a single argument.
21 | // ThenReturn method sets the return value and error of the mocked function to the provided value and error respectively.
22 | // ThenAnswer method sets the return value and error of the mocked function to the value and error returned by the provided function respectively.
23 | type ReturnerDouble[A any, B any] interface {
24 | 	Returner
25 | 	// ThenReturn sets the return value and error of the mocked function to the provided value and error respectively.
26 | 	ThenReturn(a A, b B) ReturnerDouble[A, B]
27 | 	// ThenAnswer sets the return value and error of the mocked function to the value and error returned by the provided function respectively.
28 | 	ThenAnswer(func(args []any) (A, B)) ReturnerDouble[A, B]
29 | }
30 | 
31 | // ReturnerAll is a type that defines the methods for returning and answering values for
32 | // a method call with multiple return values. It is returned by the When method.
33 | type ReturnerAll interface {
34 | 	Returner
35 | 	// ThenReturn sets the return values for the method call.
36 | 	// The number and types of the values should match the signature of the method being mocked.
37 | 	// This method can be called multiple times to set up different return values
38 | 	// for different calls to the same method with the same arguments.
39 | 	ThenReturn(values ...any) ReturnerAll
40 | 
41 | 	// ThenAnswer sets a function that will be called to calculate the return values for the method call.
42 | 	// The function should have the same signature as the method being mocked.
43 | 	// This method can be called multiple times to set up different answer functions
44 | 	// for different calls to the same method with the same arguments.
45 | 	ThenAnswer(answer Answer) ReturnerAll
46 | }
47 | 


--------------------------------------------------------------------------------
/matchers/verification.go:
--------------------------------------------------------------------------------
 1 | package matchers
 2 | 
 3 | import (
 4 | 	"fmt"
 5 | 	"reflect"
 6 | )
 7 | 
 8 | type MethodVerificationData struct {
 9 | 	NumMethodCalls int
10 | }
11 | 
12 | type InvocationData struct {
13 | 	MethodType reflect.Method
14 | 	MethodName string
15 | 	Args       []reflect.Value
16 | }
17 | 
18 | type MethodVerifier interface {
19 | 	Verify(data *MethodVerificationData) error
20 | }
21 | 
22 | func AtLeastOnce() MethodVerifier {
23 | 	return MethodVerifierFromFunc(func(data *MethodVerificationData) error {
24 | 		if data.NumMethodCalls <= 0 {
25 | 			return fmt.Errorf("expected num method calls: atLeastOnce, got: %d", data.NumMethodCalls)
26 | 		}
27 | 		return nil
28 | 	})
29 | }
30 | 
31 | func Times(n int) MethodVerifier {
32 | 	return MethodVerifierFromFunc(func(data *MethodVerificationData) error {
33 | 		if data.NumMethodCalls != n {
34 | 			return fmt.Errorf("expected num method calls: %d, got : %d", n, data.NumMethodCalls)
35 | 		}
36 | 		return nil
37 | 	})
38 | }
39 | 
40 | func MethodVerifierFromFunc(f func(data *MethodVerificationData) error) MethodVerifier {
41 | 	return &methodVerifierImpl{
42 | 		f: f,
43 | 	}
44 | }
45 | 
46 | type methodVerifierImpl struct {
47 | 	f func(data *MethodVerificationData) error
48 | }
49 | 
50 | func (m *methodVerifierImpl) Verify(data *MethodVerificationData) error {
51 | 	return m.f(data)
52 | }
53 | 


--------------------------------------------------------------------------------
/mkdocs.yml:
--------------------------------------------------------------------------------
 1 | site_name: mockio
 2 | site_url: https://ovechkin-dm.github.io/mockio/
 3 | site_description: >-
 4 |   Mock library for Go
 5 | 
 6 | repo_name: ovechkin-dm/mockio
 7 | repo_url: https://github.com/ovechkin-dm/mockio
 8 | 
 9 | theme:
10 |   name: material
11 |   icon:
12 |     logo: fontawesome/brands/golang
13 |   palette:
14 |     - media: "(prefers-color-scheme: dark)"
15 |       scheme: slate
16 |       primary: purple
17 |       toggle:
18 |         icon: material/brightness-4
19 |         name: Switch to light mode
20 |     - media: "(prefers-color-scheme: light)"
21 |       scheme: default
22 |       primary: purple
23 |       toggle:
24 |         icon: material/brightness-7
25 |         name: Switch to dark mode
26 |   features:
27 |     - content.code.annotate
28 |     - content.code.copy
29 |     - navigation.indexes
30 |     - navigation.sections
31 |     - navigation.tracking
32 |     - toc.follow
33 | markdown_extensions:
34 |   - admonition
35 |   - attr_list
36 |   - md_in_html
37 |   - pymdownx.emoji:
38 |       emoji_index: !!python/name:material.extensions.emoji.twemoji
39 |       emoji_generator: !!python/name:material.extensions.emoji.to_svg
40 |   - pymdownx.details
41 |   - pymdownx.highlight:
42 |       anchor_linenums: true
43 |       auto_title: true
44 |   - pymdownx.inlinehilite
45 |   - pymdownx.magiclink
46 |   - pymdownx.superfences
47 |   - pymdownx.tabbed:
48 |       alternate_style: true
49 |   - toc:
50 |       permalink: true
51 | 
52 | 
53 | nav:
54 |   - Home: index.md
55 |   - Features:
56 |       - Method stubbing: features/method-stubbing.md
57 |       - Matchers: features/matchers.md
58 |       - Verification: features/verification.md
59 |       - Configuration: features/configuration.md
60 |       - Argument captors: features/captors.md
61 |       - Parallel execution: features/parallel-execution.md
62 |       - Error reporting: features/error-reporting.md
63 |   - Limitations: limitations.md
64 |   - Sponsors: sponsors.md
65 | 
66 | extra_css:
67 |   - stylesheets/extra.css
68 | 
69 | extra_javascript:
70 |   - https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js
71 |   - javascripts/tablesort.js
72 | 
73 | extra:
74 |   version:
75 |     provider: mike
76 | 
77 | plugins:
78 |   - glightbox
79 |   - mike:
80 |       alias_type: copy
81 |       canonical_version: latest
82 |   - open-in-new-tab
83 |   - search
84 |   - social


--------------------------------------------------------------------------------
/mock/api.go:
--------------------------------------------------------------------------------
  1 | package mock
  2 | 
  3 | import (
  4 | 	"context"
  5 | 	"fmt"
  6 | 	"reflect"
  7 | 	"regexp"
  8 | 	"strings"
  9 | 
 10 | 	"github.com/ovechkin-dm/mockio/config"
 11 | 	"github.com/ovechkin-dm/mockio/matchers"
 12 | 	"github.com/ovechkin-dm/mockio/registry"
 13 | )
 14 | 
 15 | // SetUp initializes the mock library with the reporter.
 16 | // Example usage:
 17 | //
 18 | //	package simple
 19 | //
 20 | //	import (
 21 | //		. "github.com/ovechkin-dm/mockio/mock"
 22 | //		"testing"
 23 | //	)
 24 | //
 25 | //	type myInterface interface {
 26 | //		Foo(a int) int
 27 | //	}
 28 | //
 29 | //	func TestSimple(t *testing.T) {
 30 | //		SetUp(t)
 31 | //		m := Mock[myInterface]()
 32 | //		WhenSingle(m.Foo(Any[int]())).ThenReturn(42)
 33 | //		ret := m.Foo(10)
 34 | //		r.AssertEqual(42, ret)
 35 | //	}
 36 | func SetUp(t matchers.ErrorReporter, opts ...config.Option) {
 37 | 	registry.SetUp(t, opts...)
 38 | }
 39 | 
 40 | // Mock returns a mock object that implements the specified interface or type.
 41 | // The returned object can be used to set up mock behaviors for its methods.
 42 | //
 43 | // Example usage:
 44 | //
 45 | //	type MyInterface interface {
 46 | //	   MyMethod(arg1 string, arg2 int) (string, error)
 47 | //	}
 48 | //
 49 | //	func TestMyFunction(t *testing.T) {
 50 | //	   // Set up the mock library
 51 | //	   SetUp(t)
 52 | //
 53 | //	   // Create a mock object that implements MyInterface
 54 | //	   myMock := Mock[MyInterface]()
 55 | //
 56 | //	   // Set up a mock behavior for the MyMethod method
 57 | //	   WhenSingle(myMock.MyMethod("foo", 42)).ThenReturn("bar")
 58 | //
 59 | //	   // Call the method on the mock object
 60 | //	   result, err := myMock.MyMethod("foo", 42)
 61 | //
 62 | //	   // Verify that the mock was called with the correct arguments
 63 | //	   Verify(myMock, Times(1)).MyMethod(Any[string](), Any[int]())
 64 | //	}
 65 | func Mock[T any]() T {
 66 | 	return registry.Mock[T]()
 67 | }
 68 | 
 69 | // Any returns a mock value of type T that matches any value of type T.
 70 | // This can be useful when setting up mock behaviors for methods that take arguments of type T,
 71 | // but the specific argument value is not important for the test case.
 72 | //
 73 | // Example usage:
 74 | //
 75 | //	// Set up a mock behavior for a method that takes a string argument
 76 | //	WhenSingle(myMock.MyMethod(mock.Any[string]())).ThenReturn("bar")
 77 | //
 78 | //	// Set up a mock behavior for a method that takes an integer argument
 79 | //	WhenSingle(myMock.MyOtherMethod(mock.Any[int]())).ThenReturn("baz")
 80 | func Any[T any]() T {
 81 | 	registry.AddMatcher(registry.AnyMatcher[T]())
 82 | 	var t T
 83 | 	return t
 84 | }
 85 | 
 86 | // AnyInt is an alias for Any[int]
 87 | // See Any for more description
 88 | func AnyInt() int {
 89 | 	return Any[int]()
 90 | }
 91 | 
 92 | // AnyString is an alias for Any[string]
 93 | // See Any for more description
 94 | func AnyString() string {
 95 | 	return Any[string]()
 96 | }
 97 | 
 98 | // AnyInterface is an alias for Any[any]
 99 | // See Any for more description
100 | func AnyInterface() any {
101 | 	return Any[any]()
102 | }
103 | 
104 | // AnyContext is an alias for Any[context.Context]
105 | // See Any for more description
106 | func AnyContext() context.Context {
107 | 	return Any[context.Context]()
108 | }
109 | 
110 | // AnyOfType is an alias for Any[T] for specific type
111 | // Used for automatic type inference
112 | func AnyOfType[T any](t T) T {
113 | 	return Any[T]()
114 | }
115 | 
116 | // Nil returns matcher that matches nil argument.
117 | // Example usage:
118 | //
119 | //	WhenSingle(myMock.MyMethod(Nil[string]())).ThenReturn("bar")
120 | func Nil[T any]() T {
121 | 	m := registry.FunMatcher[T]("Nil", func(m []any, actual T) bool {
122 | 		var d any = actual
123 | 		return d == nil
124 | 	})
125 | 	registry.AddMatcher(m)
126 | 	var t T
127 | 	return t
128 | }
129 | 
130 | // NotNil returns matcher that matches non-nil argument.
131 | // Example usage:
132 | //
133 | //	WhenSingle(myMock.MyMethod(NotNil[string]())).ThenReturn("bar")
134 | func NotNil[T any]() T {
135 | 	m := registry.FunMatcher[T]("NotNil", func(m []any, actual T) bool {
136 | 		var d any = actual
137 | 		return d != nil
138 | 	})
139 | 	registry.AddMatcher(m)
140 | 	var t T
141 | 	return t
142 | }
143 | 
144 | // Regex returns matcher that matches string against provided pattern.
145 | // Example usage:
146 | //
147 | //	WhenSingle(myMock.MyMethod(Regex[string]("foo"))).ThenReturn("bar")
148 | func Regex(pattern string) string {
149 | 	re, err := regexp.Compile(pattern)
150 | 	desc := fmt.Sprintf("Regex(%v)", pattern)
151 | 	if err != nil {
152 | 		desc = fmt.Sprintf("InvalidRegex(%v)", pattern)
153 | 	}
154 | 	m := registry.FunMatcher(desc, func(m []any, actual string) bool {
155 | 		return err == nil && re.MatchString(actual)
156 | 	})
157 | 	registry.AddMatcher(m)
158 | 	return ""
159 | }
160 | 
161 | // Substring returns matcher that matches any string that contains specified substring.
162 | // Example usage:
163 | //
164 | //	WhenSingle(myMock.MyMethod(Substring("foo"))).ThenReturn("bar")
165 | func Substring(value string) string {
166 | 	desc := fmt.Sprintf("Substring(%v)", value)
167 | 	m := registry.FunMatcher(desc, func(m []any, actual string) bool {
168 | 		return strings.Contains(actual, value)
169 | 	})
170 | 	registry.AddMatcher(m)
171 | 	return ""
172 | }
173 | 
174 | // SliceLen returns matcher that matches any slice of length n.
175 | // Example usage:
176 | //
177 | //	WhenSingle(myMock.MyMethod(SliceLen(10))).ThenReturn("bar")
178 | func SliceLen[T any](value int) []T {
179 | 	desc := fmt.Sprintf("SliceLen(%v)", value)
180 | 	m := registry.FunMatcher(desc, func(m []any, actual []T) bool {
181 | 		return len(actual) == value
182 | 	})
183 | 	registry.AddMatcher(m)
184 | 	var t []T
185 | 	return t
186 | }
187 | 
188 | // MapLen returns matcher that matches any map of length n.
189 | // Example usage:
190 | //
191 | //	WhenSingle(myMock.MyMethod(MapLen(10))).ThenReturn("bar")
192 | func MapLen[K comparable, V any](value int) map[K]V {
193 | 	desc := fmt.Sprintf("MapLen(%v)", value)
194 | 	m := registry.FunMatcher(desc, func(m []any, actual map[K]V) bool {
195 | 		return len(actual) == value
196 | 	})
197 | 	registry.AddMatcher(m)
198 | 	var t map[K]V
199 | 	return t
200 | }
201 | 
202 | // SliceContains returns matcher that matches any slice that contains specified values.
203 | // Example usage:
204 | //
205 | //	WhenSingle(myMock.MyMethod(SliceContains("foo", "bar"))).ThenReturn("baz")
206 | func SliceContains[T any](values ...T) []T {
207 | 	desc := fmt.Sprintf("SliceContains(%v)", values)
208 | 	m := registry.FunMatcher(desc, func(m []any, actual []T) bool {
209 | 		amap := make(map[any]struct{})
210 | 		for _, v := range actual {
211 | 			amap[v] = struct{}{}
212 | 		}
213 | 		for _, v := range values {
214 | 			_, ok := amap[v]
215 | 			if !ok {
216 | 				return false
217 | 			}
218 | 		}
219 | 		return true
220 | 	})
221 | 	registry.AddMatcher(m)
222 | 	var t []T
223 | 	return t
224 | }
225 | 
226 | // MapContains returns matcher that matches any map that contains specified keys.
227 | // Example usage:
228 | //
229 | //	WhenSingle(myMock.MyMethod(MapContains("foo", "bar"))).ThenReturn("baz")
230 | func MapContains[K comparable, V any](values ...K) map[K]V {
231 | 	desc := fmt.Sprintf("MapContains(%v)", values)
232 | 	m := registry.FunMatcher(desc, func(m []any, actual map[K]V) bool {
233 | 		for _, v := range values {
234 | 			_, ok := actual[v]
235 | 			if !ok {
236 | 				return false
237 | 			}
238 | 		}
239 | 		return true
240 | 	})
241 | 	registry.AddMatcher(m)
242 | 	var t map[K]V
243 | 	return t
244 | }
245 | 
246 | // SliceEqualUnordered returns matcher that matches slice with same values without taking order of elements into account.
247 | // Example usage:
248 | //
249 | //	WhenSingle(myMock.MyMethod(SliceEqualUnordered([]int{2,1}))).ThenReturn("baz")
250 | func SliceEqualUnordered[T any](values []T) []T {
251 | 	desc := fmt.Sprintf("EqualUnordered(%v)", values)
252 | 	vmap := make(map[any]struct{})
253 | 	for _, v := range values {
254 | 		vmap[v] = struct{}{}
255 | 	}
256 | 	m := registry.FunMatcher(desc, func(m []any, actual []T) bool {
257 | 		if len(vmap) != len(values) {
258 | 			return false
259 | 		}
260 | 		if len(actual) != len(values) {
261 | 			return false
262 | 		}
263 | 		for _, v := range actual {
264 | 			_, ok := vmap[v]
265 | 			if !ok {
266 | 				return false
267 | 			}
268 | 		}
269 | 		return true
270 | 	})
271 | 	registry.AddMatcher(m)
272 | 	var t []T
273 | 	return t
274 | }
275 | 
276 | // Exact returns a matcher that matches values of type T that are equal to the provided value.
277 | // The value passed to Exact must be comparable with values of type T.
278 | //
279 | // Example usage:
280 | //
281 | //	// Set up a mock behavior for a method that takes a string argument equal to "foo"
282 | //	WhenSingle(myMock.MyMethod(Exact("foo"))).ThenReturn("bar")
283 | //
284 | //	// Set up a mock behavior for a method that takes an integer argument equal to 42
285 | //	WhenSingle(myMock.MyOtherMethod(Exact(42))).ThenReturn("baz")
286 | func Exact[T comparable](value T) T {
287 | 	desc := fmt.Sprintf("Exact(%v)", value)
288 | 	m := registry.FunMatcher(desc, func(m []any, actual T) bool {
289 | 		vrv := reflect.ValueOf(value)
290 | 		arv := reflect.ValueOf(actual)
291 | 		if vrv.Kind() == reflect.Struct && arv.Kind() == reflect.Struct {
292 | 			return vrv == arv
293 | 		}
294 | 		if !vrv.Comparable() {
295 | 			return false
296 | 		}
297 | 		if !arv.Comparable() {
298 | 			return false
299 | 		}
300 | 		return value == actual
301 | 	})
302 | 	registry.AddMatcher(m)
303 | 	var t T
304 | 	return t
305 | }
306 | 
307 | // Equal returns a matcher that matches values of type T that are equal via reflect.DeepEqual to the provided value.
308 | // The value passed to Equal must be of the exact same type as values of type T.
309 | //
310 | // Example usage:
311 | //
312 | //	// Set up a mock behavior for a method that takes a string argument exactly equal to "foo"
313 | //	WhenSingle(myMock.MyMethod(Equal("foo"))).ThenReturn("bar")
314 | //
315 | //	// Set up a mock behavior for a method that takes an integer argument exactly equal to 42
316 | //	WhenSingle(myMock.MyOtherMethod(Equal(42))).ThenReturn("baz")
317 | func Equal[T any](value T) T {
318 | 	desc := fmt.Sprintf("Equal(%v)", value)
319 | 	m := registry.FunMatcher[T](desc, func(m []any, actual T) bool {
320 | 		return reflect.DeepEqual(value, actual)
321 | 	})
322 | 	registry.AddMatcher(m)
323 | 	var t T
324 | 	return t
325 | }
326 | 
327 | // NotEqual returns a matcher that matches values of type T that are not equal via reflect.DeepEqual to the provided value.
328 | // The value passed to NotEqual must be of the exact same type as values of type T.
329 | //
330 | // Example usage:
331 | //
332 | //	// Set up a mock behavior for a method that takes a string argument not equal to "foo"
333 | //	WhenSingle(myMock.MyMethod(NotEqual("foo"))).ThenReturn("bar")
334 | //
335 | //	// Set up a mock behavior for a method that takes an integer argument not equal to 42
336 | //	WhenSingle(myMock.MyOtherMethod(NotEqual(42))).ThenReturn("baz")
337 | func NotEqual[T any](value T) T {
338 | 	desc := fmt.Sprintf("NotEqual(%v)", value)
339 | 	m := registry.FunMatcher[T](desc, func(m []any, actual T) bool {
340 | 		return !reflect.DeepEqual(value, actual)
341 | 	})
342 | 	registry.AddMatcher(m)
343 | 	var t T
344 | 	return t
345 | }
346 | 
347 | // OneOf returns a matcher that matches at least one of values of type T that are equal via reflect.DeepEqual to the provided value.
348 | // The value passed to OneOf must be of the exact same type as values of type T.
349 | //
350 | // Example usage:
351 | //
352 | //	// Set up a mock behavior for a method that takes a string argument equal to either "foo" or "bar"
353 | //	WhenSingle(myMock.MyMethod(OneOf("foo", "bar"))).ThenReturn("bar")
354 | //
355 | //	// Set up a mock behavior for a method that takes an integer argument equal to either 41 or 42
356 | //	WhenSingle(myMock.MyOtherMethod(OneOf(41, 42))).ThenReturn("baz")
357 | func OneOf[T any](values ...T) T {
358 | 	vs := make([]string, len(values))
359 | 	for i := range values {
360 | 		vs[i] = fmt.Sprintf("%v", values[i])
361 | 	}
362 | 
363 | 	desc := fmt.Sprintf("OneOf(%s)", strings.Join(vs, ","))
364 | 	m := registry.FunMatcher[T](desc, func(args []any, t T) bool {
365 | 		for i := range values {
366 | 			if reflect.DeepEqual(values[i], t) {
367 | 				return true
368 | 			}
369 | 		}
370 | 		return false
371 | 	})
372 | 	registry.AddMatcher(m)
373 | 	var t T
374 | 	return t
375 | }
376 | 
377 | // CreateMatcher returns a func that creates a custom matcher on invocation.
378 | func CreateMatcher[T any](description string, f func(allArgs []any, actual T) bool) func() T {
379 | 	return func() T {
380 | 		m := registry.FunMatcher[T](description, f)
381 | 		registry.AddMatcher(m)
382 | 		var t T
383 | 		return t
384 | 	}
385 | }
386 | 
387 | // WhenSingle takes an argument of type T and returns a ReturnerSingle interface
388 | // that allows for specifying a return value for a method call that has that argument.
389 | // This function should be used for method that returns exactly one return value
390 | // It acts like When, but also provides additional type check on return value
391 | // For more than on value consider using WhenDouble or When
392 | func WhenSingle[T any](t T) matchers.ReturnerSingle[T] {
393 | 	return registry.ToReturnerSingle[T](registry.When())
394 | }
395 | 
396 | // WhenDouble takes an arguments of type A and B and  returns a ReturnerDouble interface
397 | // that allows for specifying two return values for a method call that has that argument.
398 | // This function should be used for method that returns exactly two return values
399 | // It acts like When, but also provides additional type check on return values
400 | // For more multiple return values consider using When
401 | func WhenDouble[A any, B any](a A, b B) matchers.ReturnerDouble[A, B] {
402 | 	return registry.ToReturnerDouble[A, B](registry.When())
403 | }
404 | 
405 | // When sets up a method call expectation on a mocked object with a specified set of arguments
406 | // and returns a ReturnerAll object that allows specifying the return values or answer function
407 | // for the method call. Arguments can be any values, and the method call expectation is matched
408 | // based on the types and values of the arguments passed. If multiple expectations match the same
409 | // method call, the first matching expectation will be used.
410 | func When(args ...any) matchers.ReturnerAll {
411 | 	return registry.When()
412 | }
413 | 
414 | // Captor returns an ArgumentCaptor, which can be used to capture arguments
415 | // passed to a mocked method. ArgumentCaptor is a generic type, which means
416 | // that the type of the arguments to be captured should be specified when
417 | // calling Captor.
418 | func Captor[T any]() matchers.ArgumentCaptor[T] {
419 | 	return registry.NewArgumentCaptor[T]()
420 | }
421 | 
422 | // Verify checks if the method call on the provided mock object matches the expected verification conditions.
423 | //
424 | // It takes two arguments: the mock object to be verified and a method verifier. The method verifier defines the conditions
425 | // that should be matched during the verification process. If the verification passes, Verify returns the mock object.
426 | // If it fails, it reports an error.
427 | //
428 | // The method verifier can be created using one of the following functions:
429 | //
430 | //   - AtLeastOnce() MethodVerifier: Matches if the method is called at least once.
431 | //
432 | //   - Once() MethodVerifier: Matches if the method is called exactly once.
433 | //
434 | //   - Times(n int) MethodVerifier: Matches if the method is called n times.
435 | //
436 | //   - Never() MethodVerifier: Matches if the method is never called.
437 | //
438 | // The Verify function is typically used to assert that a method is called with the correct arguments and/or that it is
439 | // called the correct number of times during a unit test.
440 | //
441 | //	package simple
442 | //
443 | //	import (
444 | //		. "github.com/ovechkin-dm/mockio/mock"
445 | //		"testing"
446 | //	)
447 | //
448 | //	type myInterface interface {
449 | //		Foo(a int) int
450 | //	}
451 | //
452 | //	func TestSimple(t *testing.T) {
453 | //		r := common.NewMockReporter(t)
454 | //		SetUp(r)
455 | //		m := Mock[myInterface]()
456 | //		WhenSingle(m.Foo(Any[int]())).ThenReturn(42)
457 | //		ret := m.Foo(10)
458 | //		r.AssertEqual(42, ret)
459 | //		Verify(m, AtLeastOnce()).Foo(10)
460 | //	}
461 | func Verify[T any](t T, v matchers.MethodVerifier) T {
462 | 	registry.VerifyMethod(t, v)
463 | 	return t
464 | }
465 | 
466 | // AtLeastOnce returns a MethodVerifier that verifies if the number of method calls
467 | // is greater than zero. It can be used to verify that a method has been called at least once.
468 | //
469 | // Example usage:
470 | //
471 | //	mockObj := Mock[MyInterface]()
472 | //	mockObj.MyMethod("arg1")
473 | //	mockObj.MyMethod("arg2")
474 | //	Verify(mockObj, AtLeastOnce()).MyMethod(Any[string]())
475 | //
476 | // This verifies that the MyMethod function of mockObj was called at least once.
477 | func AtLeastOnce() matchers.MethodVerifier {
478 | 	return matchers.AtLeastOnce()
479 | }
480 | 
481 | // Once returns a MethodVerifier that expects a method to be called exactly once.
482 | // If the method is not called, or called more than once, an error will be returned during verification.
483 | func Once() matchers.MethodVerifier {
484 | 	return matchers.Times(1)
485 | }
486 | 
487 | // Times returns a MethodVerifier that verifies the number of times a method has been called.
488 | // It takes an integer 'n' as an argument, which specifies the expected number of method calls.
489 | //
490 | // Example usage:
491 | //
492 | //	// Create a mock object for testing
493 | //	mockObj := Mock[MyInterface]()
494 | //
495 | //	// Call a method on the mock object
496 | //	mockObj.MyMethod()
497 | //
498 | //	// Verify that MyMethod was called exactly once
499 | //	Verify(mockObj, Times(1)).MyMethod()
500 | //
501 | //	// Call the method again
502 | //	mockObj.MyMethod()
503 | //
504 | //	// Verify that MyMethod was called exactly twice
505 | //	Verify(mockObj, Times(2)).MyMethod()
506 | //
507 | // If the number of method calls does not match the expected number of method calls, an error is returned.
508 | // The error message will indicate the expected and actual number of method calls.
509 | func Times(n int) matchers.MethodVerifier {
510 | 	return matchers.Times(n)
511 | }
512 | 
513 | // Never returns a MethodVerifier that verifies that a method has never been called.
514 | //
515 | // Example usage:
516 | //
517 | //	// Create a mock object for testing
518 | //	mockObj := Mock[MyInterface]()
519 | //
520 | //	// Verify that MyMethod was never called
521 | //	Verify(mockObj, Never()).MyMethod()
522 | //
523 | //	// Call the method
524 | //	mockObj.MyMethod()
525 | //
526 | //	// Verify that MyMethod was called at least once
527 | //	Verify(mockObj, AtLeastOnce()).MyMethod()
528 | func Never() matchers.MethodVerifier {
529 | 	return matchers.Times(0)
530 | }
531 | 
532 | // VerifyNoMoreInteractions verifies that there are no more unverified interactions with the mock object.
533 | // For example if
534 | // Example usage:
535 | //
536 | //	// Create a mock object for testing
537 | //	mockObj := Mock[MyInterface]()
538 | //
539 | //	// Call the method
540 | //	mockObj.MyMethod()
541 | //
542 | //	// Verify that MyMethod was called exactly once
543 | //	Verify(mockObj, Once()).MyMethod()
544 | //
545 | //	// Verify that there are no more unverified interactions
546 | //	VerifyNoMoreInteractions(mockObj)
547 | func VerifyNoMoreInteractions(value any) {
548 | 	registry.VerifyNoMoreInteractions(value)
549 | }
550 | 


--------------------------------------------------------------------------------
/mockopts/options.go:
--------------------------------------------------------------------------------
 1 | package mockopts
 2 | 
 3 | import (
 4 | 	"github.com/ovechkin-dm/mockio/config"
 5 | )
 6 | 
 7 | // WithoutStackTrace enables stack trace printing for mock errors.
 8 | // By default, stack trace is being printed.
 9 | // This option is useful for debugging.
10 | // Example:
11 | //
12 | //	SetUp(t, WithoutStackTrace())
13 | func WithoutStackTrace() config.Option {
14 | 	return func(cfg *config.MockConfig) {
15 | 		cfg.PrintStackTrace = false
16 | 	}
17 | }
18 | 
19 | // StrictVerify enables strict verification of mock calls.
20 | // This means that all mocked methods that are not called will be reported as errors,
21 | // and all not mocked methods that are called will be reported as errors.
22 | // By default, strict verification is disabled.
23 | func StrictVerify() config.Option {
24 | 	return func(cfg *config.MockConfig) {
25 | 		cfg.StrictVerify = true
26 | 	}
27 | }
28 | 


--------------------------------------------------------------------------------
/registry/captor.go:
--------------------------------------------------------------------------------
 1 | package registry
 2 | 
 3 | import (
 4 | 	"reflect"
 5 | 	"sync"
 6 | )
 7 | 
 8 | type recordable interface {
 9 | 	Record(call *MethodCall, value any)
10 | 	RemoveRecord(call *MethodCall)
11 | }
12 | 
13 | type capturedValue[T any] struct {
14 | 	value T
15 | 	call  *MethodCall
16 | }
17 | 
18 | type captorImpl[T any] struct {
19 | 	values []*capturedValue[T]
20 | 	ctx    *mockContext
21 | 	lock   sync.Mutex
22 | }
23 | 
24 | func (c *captorImpl[T]) Capture() T {
25 | 	AddCaptor[T](c)
26 | 	var t T
27 | 	return t
28 | }
29 | 
30 | func (c *captorImpl[T]) Last() T {
31 | 	values := c.Values()
32 | 	if len(values) == 0 {
33 | 		c.ctx.reporter.ReportEmptyCaptor()
34 | 		var t T
35 | 		return t
36 | 	}
37 | 	return values[len(values)-1]
38 | }
39 | 
40 | func (c *captorImpl[T]) Values() []T {
41 | 	c.lock.Lock()
42 | 	defer c.lock.Unlock()
43 | 	result := make([]T, len(c.values))
44 | 	for i := range c.values {
45 | 		result[i] = c.values[i].value
46 | 	}
47 | 	return result
48 | }
49 | 
50 | func (c *captorImpl[T]) Record(call *MethodCall, value any) {
51 | 	c.lock.Lock()
52 | 	defer c.lock.Unlock()
53 | 	t, ok := value.(T)
54 | 	if !ok {
55 | 		tp := reflect.TypeOf(new(T)).Elem()
56 | 		c.ctx.reporter.ReportInvalidCaptorValue(tp, reflect.TypeOf(value))
57 | 		return
58 | 	}
59 | 	cv := &capturedValue[T]{
60 | 		value: t,
61 | 		call:  call,
62 | 	}
63 | 	c.values = append(c.values, cv)
64 | }
65 | 
66 | func (c *captorImpl[T]) RemoveRecord(call *MethodCall) {
67 | 	c.lock.Lock()
68 | 	defer c.lock.Unlock()
69 | 	wo := make([]*capturedValue[T], 0)
70 | 	for _, v := range c.values {
71 | 		if v.call != call {
72 | 			wo = append(wo, v)
73 | 		}
74 | 	}
75 | 	c.values = wo
76 | }
77 | 


--------------------------------------------------------------------------------
/registry/handler.go:
--------------------------------------------------------------------------------
  1 | package registry
  2 | 
  3 | import (
  4 | 	"fmt"
  5 | 	"reflect"
  6 | 	"sync"
  7 | 
  8 | 	"github.com/ovechkin-dm/mockio/matchers"
  9 | )
 10 | 
 11 | type invocationHandler struct {
 12 | 	ctx          *mockContext
 13 | 	methods      map[string]*methodRecorder
 14 | 	lock         sync.Mutex
 15 | 	instanceType reflect.Type
 16 | }
 17 | 
 18 | func (h *invocationHandler) Handle(method reflect.Method, values []reflect.Value) []reflect.Value {
 19 | 	h.lock.Lock()
 20 | 	defer h.lock.Unlock()
 21 | 	values = h.refineValues(method, values)
 22 | 	call := &MethodCall{
 23 | 		Method:     method,
 24 | 		Values:     values,
 25 | 		StackTrace: NewStackTrace(),
 26 | 	}
 27 | 	if h.ctx.getState().verifyState {
 28 | 		return h.DoVerifyMethod(call)
 29 | 	}
 30 | 	h.methods[method.Name].calls = append(h.methods[method.Name].calls, call)
 31 | 	return h.DoAnswer(call)
 32 | }
 33 | 
 34 | func (h *invocationHandler) DoAnswer(c *MethodCall) []reflect.Value {
 35 | 	rec := h.methods[c.Method.Name]
 36 | 	h.ctx.getState().whenHandler = h
 37 | 	h.ctx.getState().whenCall = c
 38 | 	var matched bool
 39 | 	for _, mm := range rec.methodMatches {
 40 | 		matched = true
 41 | 		if len(mm.matchers) != len(c.Values) {
 42 | 			continue
 43 | 		}
 44 | 		for argIdx, matcher := range mm.matchers {
 45 | 			if !matcher.matcher.Match(valueSliceToInterfaceSlice(c.Values), valueToInterface(c.Values[argIdx])) {
 46 | 				matched = false
 47 | 				break
 48 | 			}
 49 | 		}
 50 | 		if matched {
 51 | 			ifaces := valueSliceToInterfaceSlice(c.Values)
 52 | 
 53 | 			for i, m := range mm.matchers {
 54 | 				if m.rec != nil {
 55 | 					m.rec.Record(c, ifaces[i])
 56 | 				}
 57 | 			}
 58 | 
 59 | 			ansWrapper := mm.popAnswer()
 60 | 			if ansWrapper == nil {
 61 | 				return createDefaultReturnValues(c.Method)
 62 | 			}
 63 | 
 64 | 			retValues := ansWrapper.ans(ifaces)
 65 | 
 66 | 			h.ctx.getState().whenAnswer = ansWrapper
 67 | 			h.ctx.getState().whenMethodMatch = mm
 68 | 
 69 | 			if !h.validateReturnValues(retValues, c.Method) {
 70 | 				h.ctx.reporter.ReportInvalidReturnValues(h.instanceType, c.Method, retValues)
 71 | 				return createDefaultReturnValues(c.Method)
 72 | 			}
 73 | 
 74 | 			result := interfaceSliceToValueSlice(retValues, c.Method)
 75 | 			return result
 76 | 		}
 77 | 	}
 78 | 	return createDefaultReturnValues(c.Method)
 79 | }
 80 | 
 81 | func (h *invocationHandler) When() matchers.ReturnerAll {
 82 | 	h.lock.Lock()
 83 | 	defer h.lock.Unlock()
 84 | 
 85 | 	whenCall := h.ctx.getState().whenCall
 86 | 	whenAnswer := h.ctx.getState().whenAnswer
 87 | 	whenMethodMatch := h.ctx.getState().whenMethodMatch
 88 | 
 89 | 	if whenCall == nil {
 90 | 		h.ctx.reporter.ReportIncorrectWhenUsage()
 91 | 		return nil
 92 | 	}
 93 | 	whenCall.WhenCall = true
 94 | 
 95 | 	if whenMethodMatch != nil {
 96 | 		for _, m := range whenMethodMatch.matchers {
 97 | 			if m.rec != nil {
 98 | 				m.rec.RemoveRecord(whenCall)
 99 | 			}
100 | 		}
101 | 	}
102 | 
103 | 	h.ctx.getState().whenHandler = nil
104 | 	h.ctx.getState().whenCall = nil
105 | 	h.ctx.getState().whenMethodMatch = nil
106 | 	h.ctx.getState().whenAnswer = nil
107 | 
108 | 	if whenAnswer != nil && whenMethodMatch != nil {
109 | 		whenMethodMatch.putBackAnswer(whenAnswer)
110 | 	}
111 | 
112 | 	if !h.validateMatchers(whenCall) {
113 | 		return NewEmptyReturner()
114 | 	}
115 | 
116 | 	rec := h.methods[whenCall.Method.Name]
117 | 
118 | 	argMatchers := h.ctx.getState().matchers
119 | 
120 | 	h.ctx.getState().matchers = make([]*matcherWrapper, 0)
121 | 	m := &methodMatch{
122 | 		matchers:   argMatchers,
123 | 		unanswered: make([]*answerWrapper, 0),
124 | 		answered:   make([]*answerWrapper, 0),
125 | 		stackTrace: NewStackTrace(),
126 | 	}
127 | 	rec.methodMatches = append(rec.methodMatches, m)
128 | 	return NewReturnerAll(h.ctx, m)
129 | }
130 | 
131 | func (h *invocationHandler) VerifyMethod(verifier matchers.MethodVerifier) {
132 | 	h.lock.Lock()
133 | 	defer h.lock.Unlock()
134 | 	h.ctx.getState().verifyState = true
135 | 	h.ctx.getState().methodVerifier = verifier
136 | 	if len(h.ctx.getState().matchers) != 0 {
137 | 		h.ctx.reporter.ReportUnexpectedMatcherDeclaration(h.ctx.getState().matchers)
138 | 	}
139 | }
140 | 
141 | func (h *invocationHandler) DoVerifyMethod(call *MethodCall) []reflect.Value {
142 | 	matchersOk := h.validateMatchers(call)
143 | 	argMatchers := h.ctx.getState().matchers
144 | 
145 | 	h.ctx.getState().matchers = make([]*matcherWrapper, 0)
146 | 	h.ctx.getState().verifyState = false
147 | 
148 | 	if !matchersOk {
149 | 		return createDefaultReturnValues(call.Method)
150 | 	}
151 | 
152 | 	rec := h.methods[call.Method.Name]
153 | 	matchedInvocations := make([]*MethodCall, 0)
154 | 	for _, c := range rec.calls {
155 | 		if c.WhenCall {
156 | 			continue
157 | 		}
158 | 		matches := true
159 | 		if c.Method.Type != call.Method.Type {
160 | 			continue
161 | 		}
162 | 		if len(argMatchers) != len(c.Values) {
163 | 			continue
164 | 		}
165 | 
166 | 		for i := range argMatchers {
167 | 			if !argMatchers[i].matcher.Match(valueSliceToInterfaceSlice(c.Values), valueToInterface(c.Values[i])) {
168 | 				matches = false
169 | 				break
170 | 			}
171 | 		}
172 | 
173 | 		if matches {
174 | 			c.Verified = true
175 | 			matchedInvocations = append(matchedInvocations, c)
176 | 		}
177 | 	}
178 | 	verifyData := &matchers.MethodVerificationData{
179 | 		NumMethodCalls: len(matchedInvocations),
180 | 	}
181 | 	err := h.ctx.getState().methodVerifier.Verify(verifyData)
182 | 	h.ctx.getState().methodVerifier = nil
183 | 	if err != nil {
184 | 		h.ctx.reporter.ReportVerifyMethodError(
185 | 			true,
186 | 			h.instanceType,
187 | 			call.Method,
188 | 			matchedInvocations,
189 | 			argMatchers,
190 | 			h.methods[call.Method.Name],
191 | 			err,
192 | 			nil,
193 | 		)
194 | 	}
195 | 	for i, m := range argMatchers {
196 | 		if m.rec != nil {
197 | 			for _, inv := range matchedInvocations {
198 | 				argMatchers[i].rec.Record(inv, valueToInterface(inv.Values[i]))
199 | 			}
200 | 		}
201 | 	}
202 | 	return createDefaultReturnValues(call.Method)
203 | }
204 | 
205 | func newHandler[T any](holder *mockContext) *invocationHandler {
206 | 	tp := reflect.TypeOf(new(T)).Elem()
207 | 	recorders := make(map[string]*methodRecorder)
208 | 	for i := 0; i < tp.NumMethod(); i++ {
209 | 		recorders[tp.Method(i).Name] = &methodRecorder{
210 | 			methodMatches: make([]*methodMatch, 0),
211 | 			calls:         make([]*MethodCall, 0),
212 | 			methodType:    tp.Method(i),
213 | 		}
214 | 	}
215 | 	return &invocationHandler{
216 | 		ctx:          holder,
217 | 		methods:      recorders,
218 | 		instanceType: tp,
219 | 	}
220 | }
221 | 
222 | func (h *invocationHandler) validateMatchers(call *MethodCall) bool {
223 | 	argMatchers := h.ctx.getState().matchers
224 | 	if len(argMatchers) == 0 {
225 | 		ifaces := valueSliceToInterfaceSlice(call.Values)
226 | 		for _, v := range ifaces {
227 | 			cur := v
228 | 			desc := fmt.Sprintf("Equal(%v)", v)
229 | 			fm := FunMatcher(desc, func(call []any, a any) bool {
230 | 				return reflect.DeepEqual(cur, a)
231 | 			})
232 | 			mw := &matcherWrapper{
233 | 				matcher: fm,
234 | 				rec:     nil,
235 | 			}
236 | 			argMatchers = append(argMatchers, mw)
237 | 		}
238 | 		h.ctx.getState().matchers = argMatchers
239 | 	}
240 | 	if len(argMatchers) != len(call.Values) {
241 | 		h.ctx.reporter.ReportInvalidUseOfMatchers(h.instanceType, call, argMatchers)
242 | 		return false
243 | 	}
244 | 	return true
245 | }
246 | 
247 | func (h *invocationHandler) validateReturnValues(result []any, method reflect.Method) bool {
248 | 	if method.Type.NumOut() != len(result) {
249 | 		return false
250 | 	}
251 | 	for i := range result {
252 | 		if result[i] == nil {
253 | 			continue
254 | 		}
255 | 		retExpected := method.Type.Out(i)
256 | 		retActual := reflect.TypeOf(result[i])
257 | 		if retActual == nil {
258 | 			return false
259 | 		}
260 | 		if !retActual.AssignableTo(retExpected) {
261 | 			return false
262 | 		}
263 | 	}
264 | 	return true
265 | }
266 | 
267 | func (h *invocationHandler) VerifyNoMoreInteractions(tearDown bool) {
268 | 	h.PostponedVerify(tearDown)
269 | 	unexpected := make([]*MethodCall, 0)
270 | 	for _, rec := range h.methods {
271 | 		for _, call := range rec.calls {
272 | 			if call.WhenCall {
273 | 				continue
274 | 			}
275 | 			if !call.Verified {
276 | 				unexpected = append(unexpected, call)
277 | 			}
278 | 		}
279 | 	}
280 | 	reportFatal := !tearDown
281 | 	if len(unexpected) > 0 {
282 | 		h.ctx.reporter.ReportNoMoreInteractionsExpected(reportFatal, h.instanceType, unexpected)
283 | 	}
284 | }
285 | 
286 | func (h *invocationHandler) refineValues(method reflect.Method, values []reflect.Value) []reflect.Value {
287 | 	tp := method.Type
288 | 	if tp.IsVariadic() {
289 | 		result := make([]reflect.Value, 0)
290 | 		for i := 0; i < tp.NumIn()-1; i++ {
291 | 			result = append(result, values[i])
292 | 		}
293 | 		last := values[len(values)-1]
294 | 		for i := 0; i < last.Len(); i++ {
295 | 			result = append(result, last.Index(i))
296 | 		}
297 | 		return result
298 | 	}
299 | 	return values
300 | }
301 | 
302 | func (h *invocationHandler) PostponedVerify(tearDown bool) {
303 | 	for _, rec := range h.methods {
304 | 		for _, match := range rec.methodMatches {
305 | 			if len(match.verifiers) == 0 {
306 | 				continue
307 | 			}
308 | 			matchedInvocations := make([]*MethodCall, 0)
309 | 			for _, call := range rec.calls {
310 | 				if call.WhenCall {
311 | 					continue
312 | 				}
313 | 				matches := true
314 | 				for i := range match.matchers {
315 | 					if !match.matchers[i].matcher.Match(valueSliceToInterfaceSlice(call.Values), valueToInterface(call.Values[i])) {
316 | 						matches = false
317 | 						break
318 | 					}
319 | 				}
320 | 				if matches {
321 | 					call.Verified = true
322 | 					matchedInvocations = append(matchedInvocations, call)
323 | 				}
324 | 			}
325 | 			verifyData := &matchers.MethodVerificationData{
326 | 				NumMethodCalls: len(matchedInvocations),
327 | 			}
328 | 			for _, v := range match.verifiers {
329 | 				err := v.Verify(verifyData)
330 | 				if err != nil {
331 | 					var stackTrace *StackTrace
332 | 					if tearDown {
333 | 						stackTrace = match.stackTrace
334 | 					}
335 | 					h.ctx.reporter.ReportVerifyMethodError(
336 | 						!tearDown,
337 | 						h.instanceType,
338 | 						rec.methodType,
339 | 						matchedInvocations,
340 | 						match.matchers,
341 | 						rec,
342 | 						err,
343 | 						stackTrace,
344 | 					)
345 | 				}
346 | 			}
347 | 		}
348 | 	}
349 | }
350 | 
351 | func (h *invocationHandler) TearDown() {
352 | 	if h.ctx.cfg.StrictVerify {
353 | 		for _, m := range h.methods {
354 | 			for _, mm := range m.methodMatches {
355 | 				if len(mm.verifiers) == 0 {
356 | 					mm.verifiers = append(mm.verifiers, matchers.AtLeastOnce())
357 | 				}
358 | 			}
359 | 		}
360 | 		h.VerifyNoMoreInteractions(true)
361 | 	} else {
362 | 		h.PostponedVerify(true)
363 | 	}
364 | }
365 | 


--------------------------------------------------------------------------------
/registry/matchers.go:
--------------------------------------------------------------------------------
 1 | package registry
 2 | 
 3 | import (
 4 | 	"fmt"
 5 | 	"reflect"
 6 | 
 7 | 	"github.com/ovechkin-dm/mockio/matchers"
 8 | )
 9 | 
10 | func AnyMatcher[T any]() matchers.Matcher[T] {
11 | 	return &matcherImpl[T]{
12 | 		f: func(values []any, a T) bool {
13 | 			return true
14 | 		},
15 | 		desc: fmt.Sprintf("Any[%s]", reflect.TypeOf(new(T)).Elem().String()),
16 | 	}
17 | }
18 | 
19 | func FunMatcher[T any](description string, f func([]any, T) bool) matchers.Matcher[T] {
20 | 	return &matcherImpl[T]{
21 | 		f:    f,
22 | 		desc: description,
23 | 	}
24 | }
25 | 
26 | type matcherImpl[T any] struct {
27 | 	f    func([]any, T) bool
28 | 	desc string
29 | }
30 | 
31 | func (m *matcherImpl[T]) Description() string {
32 | 	return m.desc
33 | }
34 | 
35 | func (m *matcherImpl[T]) Match(allArgs []any, actual T) bool {
36 | 	return m.f(allArgs, actual)
37 | }
38 | 
39 | func untypedMatcher[T any](src matchers.Matcher[T]) matchers.Matcher[any] {
40 | 	return &matcherImpl[any]{
41 | 		f: func(args []any, a any) bool {
42 | 			var casted T
43 | 			if a == nil {
44 | 				return src.Match(args, casted)
45 | 			}
46 | 			c, ok := a.(T)
47 | 			if !ok {
48 | 				return false
49 | 			}
50 | 			casted = c
51 | 			return src.Match(args, casted)
52 | 		},
53 | 		desc: src.Description(),
54 | 	}
55 | }
56 | 


--------------------------------------------------------------------------------
/registry/registry.go:
--------------------------------------------------------------------------------
  1 | package registry
  2 | 
  3 | import (
  4 | 	"fmt"
  5 | 	"log"
  6 | 	"reflect"
  7 | 	"sync"
  8 | 
  9 | 	"github.com/ovechkin-dm/go-dyno/pkg/dyno"
 10 | 
 11 | 	"github.com/ovechkin-dm/mockio/config"
 12 | 	"github.com/ovechkin-dm/mockio/matchers"
 13 | 	"github.com/ovechkin-dm/mockio/threadlocal"
 14 | )
 15 | 
 16 | var (
 17 | 	instance = threadlocal.NewThreadLocal(newRegistry)
 18 | 	lock     sync.Mutex
 19 | )
 20 | 
 21 | type Registry struct {
 22 | 	mockContext *mockContext
 23 | 	mapping     map[any]*invocationHandler
 24 | }
 25 | 
 26 | func getInstance() *Registry {
 27 | 	v := instance.Get()
 28 | 	if v == nil {
 29 | 		v = newRegistry()
 30 | 		instance.Set(v)
 31 | 	}
 32 | 	return v.(*Registry)
 33 | }
 34 | 
 35 | func SetUp(reporter matchers.ErrorReporter, opts ...config.Option) {
 36 | 	if reporter == nil {
 37 | 		log.Println("Warn: call to SetUp with nil reporter")
 38 | 	}
 39 | 	cfg := config.NewConfig()
 40 | 	for _, opt := range opts {
 41 | 		opt(cfg)
 42 | 	}
 43 | 	getInstance().mockContext = newMockContext(newEnrichedReporter(reporter, cfg), cfg)
 44 | 	reporter.Cleanup(TearDown)
 45 | }
 46 | 
 47 | func TearDown() {
 48 | 	reg := getInstance()
 49 | 	if reg.mockContext.reporter == nil {
 50 | 		reg.mockContext.reporter.Errorf("Cannot Trigger Cleanup since SetUp function wasn't called")
 51 | 		return
 52 | 	}
 53 | 	for _, v := range reg.mapping {
 54 | 		v.TearDown()
 55 | 	}
 56 | 	instance.Clear()
 57 | }
 58 | 
 59 | func Mock[T any]() T {
 60 | 	return withCheck[T](func() T {
 61 | 		handler := newHandler[T](getInstance().mockContext)
 62 | 		t, err := dyno.Dynamic[T](handler.Handle)
 63 | 		if err != nil {
 64 | 			getInstance().mockContext.reporter.FailNow(fmt.Errorf("error creating mock: %w", err))
 65 | 			var zero T
 66 | 			return zero
 67 | 		}
 68 | 		getInstance().mapping[t] = handler
 69 | 		return t
 70 | 	})
 71 | }
 72 | 
 73 | func AddMatcher[T any](m matchers.Matcher[T]) {
 74 | 	withCheck[any](func() any {
 75 | 		w := &matcherWrapper{
 76 | 			matcher:    untypedMatcher(m),
 77 | 			rec:        nil,
 78 | 			stackTrace: NewStackTrace(),
 79 | 		}
 80 | 		getInstance().mockContext.getState().matchers = append(getInstance().mockContext.getState().matchers, w)
 81 | 		return nil
 82 | 	})
 83 | }
 84 | 
 85 | func AddCaptor[T any](c *captorImpl[T]) {
 86 | 	withCheck[any](func() any {
 87 | 		tp := reflect.TypeOf(new(T)).Elem()
 88 | 		w := &matcherWrapper{
 89 | 			matcher: FunMatcher(fmt.Sprintf("Captor[%s]", tp), func(call []any, a any) bool {
 90 | 				return true
 91 | 			}),
 92 | 			rec:        c,
 93 | 			stackTrace: NewStackTrace(),
 94 | 		}
 95 | 		getInstance().mockContext.getState().matchers = append(getInstance().mockContext.getState().matchers, w)
 96 | 		return nil
 97 | 	})
 98 | }
 99 | 
100 | func When() matchers.ReturnerAll {
101 | 	return withCheck(func() matchers.ReturnerAll {
102 | 		wh := getInstance().mockContext.getState().whenHandler
103 | 		if wh == nil {
104 | 			getInstance().mockContext.reporter.ReportIncorrectWhenUsage()
105 | 			return nil
106 | 		}
107 | 		return wh.When()
108 | 	})
109 | }
110 | 
111 | func VerifyMethod(t any, v matchers.MethodVerifier) {
112 | 	withCheck(func() any {
113 | 		handler, ok := getInstance().mapping[t]
114 | 		if !ok {
115 | 			getInstance().mockContext.reporter.ReportUnregisteredMockVerify(t)
116 | 			return nil
117 | 		}
118 | 		handler.VerifyMethod(v)
119 | 		return nil
120 | 	})
121 | }
122 | 
123 | func VerifyNoMoreInteractions(t any) {
124 | 	withCheck(func() any {
125 | 		handler, ok := getInstance().mapping[t]
126 | 		if !ok {
127 | 			getInstance().mockContext.reporter.ReportUnregisteredMockVerify(t)
128 | 			return nil
129 | 		}
130 | 		handler.VerifyNoMoreInteractions(false)
131 | 		return nil
132 | 	})
133 | }
134 | 
135 | func newRegistry() any {
136 | 	reporter := newEnrichedReporter(&panicReporter{}, config.NewConfig())
137 | 	cfg := config.NewConfig()
138 | 	return &Registry{
139 | 		mockContext: newMockContext(reporter, cfg),
140 | 		mapping:     make(map[any]*invocationHandler),
141 | 	}
142 | }
143 | 
144 | func withCheck[T any](f func() T) T {
145 | 	lock.Lock()
146 | 	defer lock.Unlock()
147 | 	rep, ok := getInstance().mockContext.reporter.reporter.(*panicReporter)
148 | 	if ok {
149 | 		log.Println("Warning: reporter is not initialized. You can initialize it with `SetUp(*testing.T)`. Defaulting to the panic reporter. This could also happen when using mocks concurrently")
150 | 	}
151 | 	initRoutineID := getInstance().mockContext.routineID
152 | 	if initRoutineID != threadlocal.GoId() {
153 | 		rep.Fatalf("Call to mock api from a different goroutine. `When` or `Verify` can only be used from the initial goroutine.")
154 | 	}
155 | 	return f()
156 | }
157 | 
158 | func NewArgumentCaptor[T any]() matchers.ArgumentCaptor[T] {
159 | 	return withCheck(func() matchers.ArgumentCaptor[T] {
160 | 		return &captorImpl[T]{
161 | 			values: make([]*capturedValue[T], 0),
162 | 			ctx:    getInstance().mockContext,
163 | 		}
164 | 	})
165 | }
166 | 


--------------------------------------------------------------------------------
/registry/reporter.go:
--------------------------------------------------------------------------------
  1 | package registry
  2 | 
  3 | import (
  4 | 	"fmt"
  5 | 	"reflect"
  6 | 	"strings"
  7 | 
  8 | 	"github.com/ovechkin-dm/mockio/config"
  9 | 	"github.com/ovechkin-dm/mockio/matchers"
 10 | )
 11 | 
 12 | type panicReporter struct{}
 13 | 
 14 | func (p *panicReporter) Cleanup(f func()) {
 15 | }
 16 | 
 17 | func (p *panicReporter) Fatalf(format string, args ...any) {
 18 | 	panic(fmt.Sprintf(format, args...))
 19 | }
 20 | 
 21 | func (p *panicReporter) Errorf(format string, args ...any) {
 22 | 	panic(fmt.Sprintf(format, args...))
 23 | }
 24 | 
 25 | type EnrichedReporter struct {
 26 | 	reporter matchers.ErrorReporter
 27 | 	cfg      *config.MockConfig
 28 | }
 29 | 
 30 | func (e *EnrichedReporter) Errorf(format string, args ...any) {
 31 | 	e.reporter.Errorf(format, args...)
 32 | }
 33 | 
 34 | func (e *EnrichedReporter) StackTraceFatalf(format string, args ...any) {
 35 | 	e.StackTraceErrorf(nil, true, format, args...)
 36 | }
 37 | 
 38 | func (e *EnrichedReporter) StackTraceErrorf(s *StackTrace, fatal bool, format string, args ...any) {
 39 | 	if s == nil {
 40 | 		s = NewStackTrace()
 41 | 	}
 42 | 	result := fmt.Sprintf(format, args...)
 43 | 	var st string
 44 | 	if e.cfg.PrintStackTrace {
 45 | 		st = fmt.Sprintf(`At:
 46 | 	%s
 47 | Cause:
 48 | 	%s
 49 | Trace:
 50 | %s
 51 | `, s.CallerLine(), result, s.WithoutLibraryCalls().String())
 52 | 	} else {
 53 | 		st = fmt.Sprintf(`At:
 54 | 	%s
 55 | Cause:
 56 | 	%s
 57 | `, s.CallerLine(), result)
 58 | 	}
 59 | 	if fatal {
 60 | 		e.Fatalf(st)
 61 | 	} else {
 62 | 		e.reporter.Errorf(st)
 63 | 	}
 64 | }
 65 | 
 66 | func (e *EnrichedReporter) FailNow(err error) {
 67 | 	e.Fatalf(err.Error())
 68 | }
 69 | 
 70 | func (e *EnrichedReporter) Fatal(format string) {
 71 | 	e.Fatalf(format)
 72 | }
 73 | 
 74 | func (e *EnrichedReporter) Fatalf(format string, args ...any) {
 75 | 	e.reporter.Fatalf(format, args...)
 76 | }
 77 | 
 78 | func (e *EnrichedReporter) ReportIncorrectWhenUsage() {
 79 | 	e.StackTraceFatalf(`When() requires an argument which has to be 'a method call on a mock'.
 80 | 	For example: When(mock.GetArticles()).ThenReturn(articles)`)
 81 | }
 82 | 
 83 | func (e *EnrichedReporter) ReportUnregisteredMockVerify(t any) {
 84 | 	e.StackTraceFatalf(`Argument passed to Verify() is %v and is not a mock, or a mock created in a different goroutine.
 85 | 	Make sure you place the parenthesis correctly.
 86 | 	Example of correct verification:
 87 | 		Verify(mock, Times(10)).SomeMethod()`, t)
 88 | }
 89 | 
 90 | func (e *EnrichedReporter) ReportInvalidUseOfMatchers(instanceType reflect.Type, call *MethodCall, m []*matcherWrapper) {
 91 | 	matcherArgs := make([]string, len(m))
 92 | 	for i := range m {
 93 | 		matcherArgs[i] = m[i].matcher.Description()
 94 | 	}
 95 | 	matchersString := strings.Join(matcherArgs, ",")
 96 | 	tp := call.Method.Type
 97 | 	inArgs := make([]string, 0)
 98 | 	methodSig := prettyPrintMethodSignature(instanceType, call.Method)
 99 | 	for i := 0; i < tp.NumIn(); i++ {
100 | 		inArgs = append(inArgs, tp.In(i).String())
101 | 	}
102 | 	inArgsStr := strings.Join(inArgs, ",")
103 | 	numExpected := call.Method.Type.NumIn()
104 | 	numActual := len(m)
105 | 	declarationLines := make([]string, 0)
106 | 	for i := range m {
107 | 		declarationLines = append(declarationLines, "\t\t"+m[i].stackTrace.CallerLine())
108 | 	}
109 | 	decl := strings.Join(declarationLines, "\n")
110 | 	expectedStr := fmt.Sprintf("%v expected, %v recorded:\n", numExpected, numActual)
111 | 	if call.Method.Type.IsVariadic() {
112 | 		expectedStr = ""
113 | 	}
114 | 	e.StackTraceFatalf(`Invalid use of matchers
115 | 	%s%v
116 | 	method:
117 | 		%v
118 | 	expected:
119 | 		(%s)
120 | 	got:
121 | 		(%s)
122 | 	This can happen for 2 reasons:
123 | 		1. Declaration of matcher outside When() call
124 | 		2. Mixing matchers and exact values in When() call. Is this case, consider using "Exact" matcher.`,
125 | 		expectedStr, decl, methodSig, inArgsStr, matchersString)
126 | }
127 | 
128 | func (e *EnrichedReporter) ReportVerifyMethodError(
129 | 	fatal bool,
130 | 	tp reflect.Type,
131 | 	method reflect.Method,
132 | 	invocations []*MethodCall,
133 | 	argMatchers []*matcherWrapper,
134 | 	recorder *methodRecorder,
135 | 	err error,
136 | 	stackTrace *StackTrace,
137 | ) {
138 | 	sb := strings.Builder{}
139 | 	for i, c := range invocations {
140 | 		if c.WhenCall {
141 | 			continue
142 | 		}
143 | 		sb.WriteString("\t\t" + c.StackTrace.CallerLine())
144 | 		if i != len(invocations)-1 {
145 | 			sb.WriteString("\n")
146 | 		}
147 | 	}
148 | 	args := make([]string, len(argMatchers))
149 | 	for i := range argMatchers {
150 | 		args[i] = argMatchers[i].matcher.Description()
151 | 	}
152 | 	callStr := PrettyPrintMethodInvocation(tp, method, args)
153 | 
154 | 	other := strings.Builder{}
155 | 	for j, c := range recorder.calls {
156 | 		if c.WhenCall {
157 | 			continue
158 | 		}
159 | 		callArgs := make([]string, len(c.Values))
160 | 		for i := range c.Values {
161 | 			callArgs[i] = fmt.Sprintf("%v", c.Values[i])
162 | 		}
163 | 		pretty := PrettyPrintMethodInvocation(tp, c.Method, callArgs)
164 | 		other.WriteString(fmt.Sprintf("\t\t%s at %s", pretty, c.StackTrace.CallerLine()))
165 | 		if j != len(recorder.calls)-1 {
166 | 			other.WriteString("\n")
167 | 		}
168 | 	}
169 | 	if len(other.String()) == 0 && len(sb.String()) == 0 {
170 | 		e.StackTraceErrorf(stackTrace, fatal, `%v
171 | 		%v
172 | `, err, callStr)
173 | 	} else if len(invocations) == 0 {
174 | 		e.StackTraceErrorf(stackTrace, fatal, `%v
175 | 		%v
176 | 	However, there were other interactions with this method:
177 | %v`, err, callStr, other.String())
178 | 	} else {
179 | 		e.StackTraceErrorf(stackTrace, fatal, `%v
180 | 		%v
181 | 	Invocations:
182 | %v`, err, callStr, sb.String())
183 | 	}
184 | }
185 | 
186 | func (e *EnrichedReporter) ReportEmptyCaptor() {
187 | 	e.StackTraceFatalf("no values were captured for captor")
188 | }
189 | 
190 | func (e *EnrichedReporter) ReportInvalidCaptorValue(expectedType reflect.Type, actualType reflect.Type) {
191 | 	e.StackTraceFatalf("captor contains unexpected type")
192 | }
193 | 
194 | func (e *EnrichedReporter) ReportInvalidReturnValues(instanceType reflect.Type, method reflect.Method, ret []any) {
195 | 	tp := method.Type
196 | 	outTypesSB := strings.Builder{}
197 | 
198 | 	interfaceName := instanceType.Name()
199 | 	methodName := method.Name
200 | 	outTypesSB.WriteString(interfaceName + "." + methodName)
201 | 	outTypesSB.WriteString("(")
202 | 	for i := 0; i < tp.NumIn(); i++ {
203 | 		outTypesSB.WriteString(tp.In(i).Name())
204 | 		if i != tp.NumIn()-1 {
205 | 			outTypesSB.WriteString(", ")
206 | 		}
207 | 	}
208 | 	outTypesSB.WriteString(")")
209 | 	if len(ret) > 0 {
210 | 		outTypesSB.WriteString(" ")
211 | 	}
212 | 	if len(ret) > 1 {
213 | 		outTypesSB.WriteString("(")
214 | 	}
215 | 	for i := 0; i < len(ret); i++ {
216 | 		of := reflect.ValueOf(ret[i])
217 | 		if of.Kind() == reflect.Invalid {
218 | 			outTypesSB.WriteString("nil")
219 | 		} else {
220 | 			outTypesSB.WriteString(of.Type().String())
221 | 		}
222 | 
223 | 		if i != len(ret)-1 {
224 | 			outTypesSB.WriteString(", ")
225 | 		}
226 | 	}
227 | 	if len(ret) > 1 {
228 | 		outTypesSB.WriteString(")")
229 | 	}
230 | 
231 | 	methodSig := prettyPrintMethodSignature(instanceType, method)
232 | 
233 | 	e.StackTraceFatalf(`invalid return values
234 | expected:
235 | 	%v
236 | got:
237 | 	%s
238 | `, methodSig, outTypesSB.String())
239 | }
240 | 
241 | func newEnrichedReporter(reporter matchers.ErrorReporter, cfg *config.MockConfig) *EnrichedReporter {
242 | 	return &EnrichedReporter{
243 | 		reporter: reporter,
244 | 		cfg:      cfg,
245 | 	}
246 | }
247 | 
248 | func prettyPrintMethodSignature(interfaceType reflect.Type, method reflect.Method) string {
249 | 	var signature string
250 | 
251 | 	interfaceName := interfaceType.Name()
252 | 	methodName := method.Name
253 | 	methodType := method.Type
254 | 	signature += interfaceName + "." + methodName
255 | 
256 | 	numParams := methodType.NumIn()
257 | 	signature += "("
258 | 	for i := 0; i < numParams; i++ {
259 | 		paramType := methodType.In(i)
260 | 		signature += paramType.String()
261 | 		if i != numParams-1 {
262 | 			signature += ", "
263 | 		}
264 | 	}
265 | 	signature += ")"
266 | 
267 | 	numReturns := methodType.NumOut()
268 | 	if numReturns > 0 {
269 | 		signature += " "
270 | 	}
271 | 	if numReturns > 1 {
272 | 		signature += "("
273 | 	}
274 | 	for i := 0; i < numReturns; i++ {
275 | 		returnType := methodType.Out(i)
276 | 		signature += returnType.String()
277 | 		if i != numReturns-1 {
278 | 			signature += ", "
279 | 		}
280 | 	}
281 | 	if numReturns > 1 {
282 | 		signature += ")"
283 | 	}
284 | 
285 | 	return signature
286 | }
287 | 
288 | func PrettyPrintMethodInvocation(interfaceType reflect.Type, method reflect.Method, args []string) string {
289 | 	sb := strings.Builder{}
290 | 	interfaceName := interfaceType.Name()
291 | 	methodName := method.Name
292 | 	sb.WriteString(interfaceName + "." + methodName)
293 | 	sb.WriteRune('(')
294 | 	for i, v := range args {
295 | 		sb.WriteString(fmt.Sprintf("%v", v))
296 | 		if i != len(args)-1 {
297 | 			sb.WriteString(", ")
298 | 		}
299 | 	}
300 | 	sb.WriteRune(')')
301 | 	return sb.String()
302 | }
303 | 
304 | func (e *EnrichedReporter) ReportNoMoreInteractionsExpected(fatal bool, instanceType reflect.Type, calls []*MethodCall) {
305 | 	sb := strings.Builder{}
306 | 	for i, c := range calls {
307 | 		args := make([]string, 0)
308 | 		for _, v := range c.Values {
309 | 			args = append(args, fmt.Sprintf("%v", v))
310 | 		}
311 | 		s := PrettyPrintMethodInvocation(instanceType, c.Method, args)
312 | 		line := fmt.Sprintf("\t\t%s at %s", s, c.StackTrace.CallerLine())
313 | 		sb.WriteString(line)
314 | 		if i != len(calls)-1 {
315 | 			sb.WriteString("\n")
316 | 		}
317 | 
318 | 	}
319 | 	e.StackTraceErrorf(nil, fatal, `No more interactions expected, but unverified interactions found:
320 | %v`, sb.String())
321 | }
322 | 
323 | func (e *EnrichedReporter) ReportUnexpectedMatcherDeclaration(m []*matcherWrapper) {
324 | 	sb := strings.Builder{}
325 | 	for i, v := range m {
326 | 		sb.WriteString("\t\tat " + v.stackTrace.CallerLine())
327 | 		if i != len(m)-1 {
328 | 			sb.WriteString("\n")
329 | 		}
330 | 	}
331 | 	e.StackTraceFatalf(`Unexpected matchers declaration.
332 | %s
333 | 	Matchers can only be used inside When() method call.`, sb.String())
334 | }
335 | 


--------------------------------------------------------------------------------
/registry/returners.go:
--------------------------------------------------------------------------------
  1 | package registry
  2 | 
  3 | import (
  4 | 	"github.com/ovechkin-dm/mockio/matchers"
  5 | )
  6 | 
  7 | func ToReturnerSingle[T any](retAll matchers.ReturnerAll) matchers.ReturnerSingle[T] {
  8 | 	return &returnerSingleImpl[T]{
  9 | 		all: retAll,
 10 | 	}
 11 | }
 12 | 
 13 | func ToReturnerDouble[A any, B any](retAll matchers.ReturnerAll) matchers.ReturnerDouble[A, B] {
 14 | 	return &returnerDoubleImpl[A, B]{
 15 | 		all: retAll,
 16 | 	}
 17 | }
 18 | 
 19 | type returnerDummyImpl struct{}
 20 | 
 21 | func (r *returnerDummyImpl) ThenReturn(values ...any) matchers.ReturnerAll {
 22 | 	return r
 23 | }
 24 | 
 25 | func (r *returnerDummyImpl) ThenAnswer(f matchers.Answer) matchers.ReturnerAll {
 26 | 	return r
 27 | }
 28 | 
 29 | func (r *returnerDummyImpl) Verify(m matchers.MethodVerifier) {
 30 | }
 31 | 
 32 | type returnerAllImpl struct {
 33 | 	methodMatch *methodMatch
 34 | 	ctx         *mockContext
 35 | }
 36 | 
 37 | type returnerSingleImpl[T any] struct {
 38 | 	all matchers.ReturnerAll
 39 | }
 40 | 
 41 | func (r *returnerSingleImpl[T]) ThenReturn(value T) matchers.ReturnerSingle[T] {
 42 | 	return r.ThenAnswer(func(args []any) T {
 43 | 		return value
 44 | 	})
 45 | }
 46 | 
 47 | func (r *returnerSingleImpl[T]) ThenAnswer(f func(args []any) T) matchers.ReturnerSingle[T] {
 48 | 	all := r.all.ThenAnswer(func(args []any) []any {
 49 | 		return []any{f(args)}
 50 | 	})
 51 | 	return &returnerSingleImpl[T]{
 52 | 		all: all,
 53 | 	}
 54 | }
 55 | 
 56 | func (r *returnerSingleImpl[T]) Verify(verifier matchers.MethodVerifier) {
 57 | 	r.all.Verify(verifier)
 58 | }
 59 | 
 60 | type returnerDoubleImpl[A any, B any] struct {
 61 | 	all matchers.ReturnerAll
 62 | }
 63 | 
 64 | func (r *returnerDoubleImpl[A, B]) ThenReturn(a A, b B) matchers.ReturnerDouble[A, B] {
 65 | 	return r.ThenAnswer(func(args []any) (A, B) {
 66 | 		return a, b
 67 | 	})
 68 | }
 69 | 
 70 | func (r *returnerDoubleImpl[A, B]) ThenAnswer(f func(args []any) (A, B)) matchers.ReturnerDouble[A, B] {
 71 | 	all := r.all.ThenAnswer(func(args []any) []any {
 72 | 		t, e := f(args)
 73 | 		return []any{t, e}
 74 | 	})
 75 | 	return &returnerDoubleImpl[A, B]{
 76 | 		all: all,
 77 | 	}
 78 | }
 79 | 
 80 | func (r *returnerDoubleImpl[A, B]) Verify(verifier matchers.MethodVerifier) {
 81 | 	r.all.Verify(verifier)
 82 | }
 83 | 
 84 | func (r *returnerAllImpl) ThenReturn(values ...any) matchers.ReturnerAll {
 85 | 	return r.ThenAnswer(makeReturnFunc(values))
 86 | }
 87 | 
 88 | func (r *returnerAllImpl) ThenAnswer(f matchers.Answer) matchers.ReturnerAll {
 89 | 	wrapper := &answerWrapper{
 90 | 		ans: f,
 91 | 	}
 92 | 	r.methodMatch.addAnswer(wrapper)
 93 | 	return r
 94 | }
 95 | 
 96 | func (r *returnerAllImpl) Verify(verifier matchers.MethodVerifier) {
 97 | 	r.methodMatch.verifiers = append(r.methodMatch.verifiers, verifier)
 98 | }
 99 | 
100 | func makeReturnFunc(values []any) matchers.Answer {
101 | 	return func(args []any) []interface{} {
102 | 		return values
103 | 	}
104 | }
105 | 
106 | func NewReturnerAll(ctx *mockContext, data *methodMatch) matchers.ReturnerAll {
107 | 	return &returnerAllImpl{
108 | 		methodMatch: data,
109 | 		ctx:         ctx,
110 | 	}
111 | }
112 | 
113 | func NewEmptyReturner() matchers.ReturnerAll {
114 | 	return &returnerDummyImpl{}
115 | }
116 | 


--------------------------------------------------------------------------------
/registry/state.go:
--------------------------------------------------------------------------------
  1 | package registry
  2 | 
  3 | import (
  4 | 	"reflect"
  5 | 	"sync"
  6 | 	"sync/atomic"
  7 | 
  8 | 	"github.com/ovechkin-dm/mockio/config"
  9 | 	"github.com/ovechkin-dm/mockio/matchers"
 10 | 	"github.com/ovechkin-dm/mockio/threadlocal"
 11 | )
 12 | 
 13 | type fiberState struct {
 14 | 	matchers        []*matcherWrapper
 15 | 	whenHandler     *invocationHandler
 16 | 	verifyState     bool
 17 | 	methodVerifier  matchers.MethodVerifier
 18 | 	whenCall        *MethodCall
 19 | 	whenAnswer      *answerWrapper
 20 | 	whenMethodMatch *methodMatch
 21 | }
 22 | 
 23 | type mockContext struct {
 24 | 	state     threadlocal.ThreadLocal[*fiberState]
 25 | 	reporter  *EnrichedReporter
 26 | 	lock      sync.Mutex
 27 | 	routineID int64
 28 | 	cfg       *config.MockConfig
 29 | }
 30 | 
 31 | type methodRecorder struct {
 32 | 	methodMatches []*methodMatch
 33 | 	calls         []*MethodCall
 34 | 	methodType    reflect.Method
 35 | }
 36 | 
 37 | type methodMatch struct {
 38 | 	matchers    []*matcherWrapper
 39 | 	unanswered  []*answerWrapper
 40 | 	answered    []*answerWrapper
 41 | 	lock        sync.Mutex
 42 | 	lastAnswer  *answerWrapper
 43 | 	invocations int64
 44 | 	verifiers   []matchers.MethodVerifier
 45 | 	stackTrace  *StackTrace
 46 | }
 47 | 
 48 | func (m *methodMatch) popAnswer() *answerWrapper {
 49 | 	m.lock.Lock()
 50 | 	defer m.lock.Unlock()
 51 | 	atomic.AddInt64(&m.invocations, 1)
 52 | 	if len(m.unanswered) == 0 {
 53 | 		return m.lastAnswer
 54 | 	}
 55 | 	last := m.unanswered[0]
 56 | 	m.unanswered = m.unanswered[1:]
 57 | 	m.answered = append(m.answered, last)
 58 | 	m.lastAnswer = last
 59 | 	return last
 60 | }
 61 | 
 62 | func (m *methodMatch) addAnswer(wrapper *answerWrapper) {
 63 | 	m.lock.Lock()
 64 | 	defer m.lock.Unlock()
 65 | 	m.unanswered = append(m.unanswered, wrapper)
 66 | }
 67 | 
 68 | func (m *methodMatch) putBackAnswer(wrapper *answerWrapper) {
 69 | 	m.lock.Lock()
 70 | 	defer m.lock.Unlock()
 71 | 	atomic.AddInt64(&m.invocations, -1)
 72 | 	foundIdx := -1
 73 | 	for i := len(m.answered) - 1; i >= 0; i-- {
 74 | 		if wrapper == m.answered[i] {
 75 | 			foundIdx = i
 76 | 			break
 77 | 		}
 78 | 	}
 79 | 	if foundIdx == -1 {
 80 | 		return
 81 | 	}
 82 | 	for i := foundIdx; i < len(m.unanswered)-1; i++ {
 83 | 		m.answered[i] = m.answered[i+1]
 84 | 	}
 85 | 	m.answered = m.answered[0 : len(m.answered)-1]
 86 | 	m.unanswered = append(m.unanswered, wrapper)
 87 | }
 88 | 
 89 | type answerWrapper struct {
 90 | 	ans matchers.Answer
 91 | }
 92 | 
 93 | type matcherWrapper struct {
 94 | 	matcher    matchers.Matcher[any]
 95 | 	rec        recordable
 96 | 	stackTrace *StackTrace
 97 | }
 98 | 
 99 | func (ctx *mockContext) getState() *fiberState {
100 | 	return ctx.state.Get()
101 | }
102 | 
103 | func newMockContext(reporter *EnrichedReporter, cfg *config.MockConfig) *mockContext {
104 | 	return &mockContext{
105 | 		state: threadlocal.NewThreadLocal(func() *fiberState {
106 | 			return &fiberState{
107 | 				matchers:       make([]*matcherWrapper, 0),
108 | 				whenHandler:    nil,
109 | 				whenCall:       nil,
110 | 				methodVerifier: nil,
111 | 				verifyState:    false,
112 | 			}
113 | 		}),
114 | 		reporter:  reporter,
115 | 		lock:      sync.Mutex{},
116 | 		routineID: threadlocal.GoId(),
117 | 		cfg:       cfg,
118 | 	}
119 | }
120 | 
121 | type MethodCall struct {
122 | 	Method     reflect.Method
123 | 	Values     []reflect.Value
124 | 	WhenCall   bool
125 | 	Verified   bool
126 | 	StackTrace *StackTrace
127 | }
128 | 


--------------------------------------------------------------------------------
/registry/util.go:
--------------------------------------------------------------------------------
  1 | package registry
  2 | 
  3 | import (
  4 | 	"fmt"
  5 | 	"reflect"
  6 | 	"runtime/debug"
  7 | 	"strings"
  8 | )
  9 | 
 10 | const (
 11 | 	PackageName     = "github.com/ovechkin-dm/mockio"
 12 | 	DynoPackageName = "github.com/ovechkin-dm/go-dyno"
 13 | 	TestPackageName = "github.com/ovechkin-dm/mockio/tests"
 14 | 	DebugPackage    = "runtime/debug.Stack()"
 15 | 	GOIDPackageName = "github.com/petermattis/goid"
 16 | )
 17 | 
 18 | func createDefaultReturnValues(m reflect.Method) []reflect.Value {
 19 | 	result := make([]reflect.Value, m.Type.NumOut())
 20 | 	for i := 0; i < m.Type.NumOut(); i++ {
 21 | 		result[i] = reflect.New(m.Type.Out(i)).Elem()
 22 | 	}
 23 | 	return result
 24 | }
 25 | 
 26 | func valueSliceToInterfaceSlice(values []reflect.Value) []any {
 27 | 	result := make([]any, len(values))
 28 | 	for i := range values {
 29 | 		result[i] = valueToInterface(values[i])
 30 | 	}
 31 | 	return result
 32 | }
 33 | 
 34 | func valueToInterface(value reflect.Value) any {
 35 | 	return value.Interface()
 36 | }
 37 | 
 38 | func interfaceSliceToValueSlice(values []any, m reflect.Method) []reflect.Value {
 39 | 	result := make([]reflect.Value, len(values))
 40 | 	for i := range values {
 41 | 		retV := reflect.New(m.Type.Out(i)).Elem()
 42 | 		if values[i] != nil {
 43 | 			retV.Set(reflect.ValueOf(values[i]))
 44 | 		}
 45 | 		result[i] = retV
 46 | 	}
 47 | 	return result
 48 | }
 49 | 
 50 | type StackTrace struct {
 51 | 	goroutine string
 52 | 	lines     []*StackLine
 53 | }
 54 | 
 55 | type StackLine struct {
 56 | 	Path string
 57 | 	Line string
 58 | }
 59 | 
 60 | func (s *StackLine) String() string {
 61 | 	return fmt.Sprintf("%s\n\t%s", s.Path, s.Line)
 62 | }
 63 | 
 64 | func (s *StackLine) IsLibraryStackLine() bool {
 65 | 	if strings.Contains(s.Path, DebugPackage) {
 66 | 		return true
 67 | 	}
 68 | 	if strings.Contains(s.Path, DynoPackageName) {
 69 | 		return true
 70 | 	}
 71 | 	if strings.Contains(s.Path, GOIDPackageName) {
 72 | 		return true
 73 | 	}
 74 | 	return strings.Contains(s.Path, PackageName) && !strings.Contains(s.Path, TestPackageName)
 75 | }
 76 | 
 77 | func (s *StackTrace) String() string {
 78 | 	result := make([]string, 0)
 79 | 	for i := range s.lines {
 80 | 		result = append(result, s.lines[i].String()+"\n")
 81 | 	}
 82 | 	return strings.Join(result, "")
 83 | }
 84 | 
 85 | func (s *StackTrace) CallerLine() string {
 86 | 	for i := range s.lines {
 87 | 		if s.lines[i].IsLibraryStackLine() {
 88 | 			if i < len(s.lines)-1 && !s.lines[i+1].IsLibraryStackLine() {
 89 | 				return s.lines[i+1].Line
 90 | 			}
 91 | 		}
 92 | 	}
 93 | 	return ""
 94 | }
 95 | 
 96 | func (s *StackTrace) WithoutLibraryCalls() *StackTrace {
 97 | 	var result []*StackLine
 98 | 	for i := range s.lines {
 99 | 		if !s.lines[i].IsLibraryStackLine() {
100 | 			result = append(result, s.lines[i])
101 | 		}
102 | 	}
103 | 	return &StackTrace{
104 | 		lines: result,
105 | 	}
106 | }
107 | 
108 | func NewStackTrace() *StackTrace {
109 | 	stack := string(debug.Stack())
110 | 	lines := strings.Split(stack, "\n")
111 | 	goroutine := lines[0]
112 | 	stackLines := make([]*StackLine, 0)
113 | 	for i := 1; i < len(lines)-1; i += 2 {
114 | 		l := &StackLine{
115 | 			Path: strings.TrimSpace(lines[i]),
116 | 			Line: strings.TrimSpace(lines[i+1]),
117 | 		}
118 | 		stackLines = append(stackLines, l)
119 | 	}
120 | 	return &StackTrace{
121 | 		goroutine: goroutine,
122 | 		lines:     stackLines,
123 | 	}
124 | }
125 | 


--------------------------------------------------------------------------------
/tests/captor/captor_test.go:
--------------------------------------------------------------------------------
 1 | package captor
 2 | 
 3 | import (
 4 | 	"testing"
 5 | 
 6 | 	"github.com/ovechkin-dm/mockio/tests/common"
 7 | 
 8 | 	. "github.com/ovechkin-dm/mockio/mock"
 9 | )
10 | 
11 | type iface interface {
12 | 	Foo(i int) int
13 | 	VoidFoo(i int, j int)
14 | }
15 | 
16 | func TestCaptorBasic(t *testing.T) {
17 | 	r := common.NewMockReporter(t)
18 | 	SetUp(r)
19 | 	m := Mock[iface]()
20 | 	c := Captor[int]()
21 | 	WhenSingle(m.Foo(c.Capture())).ThenReturn(10)
22 | 	m.Foo(11)
23 | 	r.AssertEqual(c.Last(), 11)
24 | }
25 | 
26 | func TestCaptorMatches(t *testing.T) {
27 | 	r := common.NewMockReporter(t)
28 | 	SetUp(r)
29 | 	m := Mock[iface]()
30 | 	c := Captor[int]()
31 | 	WhenSingle(m.Foo(c.Capture())).ThenReturn(10)
32 | 	ans := m.Foo(11)
33 | 	r.AssertEqual(ans, 10)
34 | }
35 | 
36 | func TestCaptorMultiCalls(t *testing.T) {
37 | 	r := common.NewMockReporter(t)
38 | 	SetUp(r)
39 | 	m := Mock[iface]()
40 | 	c := Captor[int]()
41 | 	WhenSingle(m.Foo(c.Capture())).ThenReturn(10)
42 | 	m.Foo(11)
43 | 	m.Foo(12)
44 | 	r.AssertEqual(c.Last(), 12)
45 | 	r.AssertEqual(c.Values()[0], 11)
46 | 	r.AssertEqual(c.Values()[1], 12)
47 | }
48 | 
49 | func TestCaptorMultiUsage(t *testing.T) {
50 | 	r := common.NewMockReporter(t)
51 | 	SetUp(r)
52 | 	m1 := Mock[iface]()
53 | 	m2 := Mock[iface]()
54 | 	c := Captor[int]()
55 | 	WhenSingle(m1.Foo(c.Capture())).ThenReturn(10)
56 | 	WhenSingle(m2.Foo(c.Capture())).ThenReturn(10)
57 | 	m1.Foo(10)
58 | 	m2.Foo(11)
59 | 	r.AssertEqual(c.Values()[0], 10)
60 | 	r.AssertEqual(c.Values()[1], 11)
61 | }
62 | 
63 | func TestCaptorVerify(t *testing.T) {
64 | 	r := common.NewMockReporter(t)
65 | 	SetUp(r)
66 | 	m := Mock[iface]()
67 | 	c := Captor[int]()
68 | 	m.VoidFoo(10, 20)
69 | 	Verify(m, Once()).VoidFoo(c.Capture(), Exact(20))
70 | 	r.AssertNoError()
71 | 	r.AssertEqual(10, c.Last())
72 | }
73 | 


--------------------------------------------------------------------------------
/tests/check/check_test.go:
--------------------------------------------------------------------------------
 1 | package check
 2 | 
 3 | import (
 4 | 	"testing"
 5 | 
 6 | 	"github.com/ovechkin-dm/mockio/tests/common"
 7 | 
 8 | 	. "github.com/ovechkin-dm/mockio/mock"
 9 | )
10 | 
11 | type St struct{}
12 | 
13 | func TestNonInterfaceNotAllowed(t *testing.T) {
14 | 	r := common.NewMockReporter(t)
15 | 	SetUp(r)
16 | 	_ = Mock[St]()
17 | 	r.AssertError()
18 | }
19 | 


--------------------------------------------------------------------------------
/tests/common/common.go:
--------------------------------------------------------------------------------
  1 | package common
  2 | 
  3 | import (
  4 | 	"errors"
  5 | 	"fmt"
  6 | 	"reflect"
  7 | 	"strings"
  8 | 	"testing"
  9 | )
 10 | 
 11 | type MockReporter struct {
 12 | 	reported   string
 13 | 	t          *testing.T
 14 | 	cleanups   []func()
 15 | 	fatalCount int
 16 | 	errorCount int
 17 | }
 18 | 
 19 | func (m *MockReporter) Fatalf(format string, args ...any) {
 20 | 	m.reported = fmt.Sprintf(format, args...)
 21 | 	m.fatalCount++
 22 | }
 23 | 
 24 | func (m *MockReporter) Errorf(format string, args ...any) {
 25 | 	m.reported = fmt.Sprintf(format, args...)
 26 | 	m.errorCount++
 27 | }
 28 | 
 29 | func (m *MockReporter) IsError() bool {
 30 | 	return m.reported != ""
 31 | }
 32 | 
 33 | func (m *MockReporter) ErrorContains(s string) bool {
 34 | 	return m.IsError() && strings.Contains(strings.ToLower(m.reported), strings.ToLower(s))
 35 | }
 36 | 
 37 | func (m *MockReporter) GetErrorString() string {
 38 | 	return m.reported
 39 | }
 40 | 
 41 | func (m *MockReporter) GetError() error {
 42 | 	return errors.New(m.reported)
 43 | }
 44 | 
 45 | func (m *MockReporter) AssertNoError() {
 46 | 	if m.IsError() {
 47 | 		m.t.Fatalf("Expected no error, got: %s", m.reported)
 48 | 	}
 49 | }
 50 | 
 51 | func (m *MockReporter) AssertError() {
 52 | 	if !m.IsError() {
 53 | 		m.t.Fatalf("Expected error, got nothing")
 54 | 	}
 55 | }
 56 | 
 57 | func (m *MockReporter) AssertEqual(expected any, actual any) {
 58 | 	if !reflect.DeepEqual(expected, actual) {
 59 | 		m.t.Fatalf("Values not equal. \n Expected: %v \n actual: %v", expected, actual)
 60 | 	}
 61 | }
 62 | 
 63 | func (m *MockReporter) AssertErrorContains(err error, s string) {
 64 | 	if err == nil {
 65 | 		m.t.Fatalf("expected error, got nil")
 66 | 	}
 67 | 	if !strings.Contains(err.Error(), s) {
 68 | 		m.t.Fatalf("expected error to contain %s", s)
 69 | 	}
 70 | }
 71 | 
 72 | func (m *MockReporter) Cleanup(clean func()) {
 73 | 	m.cleanups = append(m.cleanups, clean)
 74 | }
 75 | 
 76 | func (m *MockReporter) TriggerCleanup() {
 77 | 	for _, clean := range m.cleanups {
 78 | 		clean()
 79 | 	}
 80 | }
 81 | 
 82 | func (m *MockReporter) PrintError() {
 83 | 	fmt.Println(m.reported)
 84 | }
 85 | 
 86 | func (m *MockReporter) GetFatalCount() int {
 87 | 	return m.fatalCount
 88 | }
 89 | 
 90 | func (m *MockReporter) GetErrorCount() int {
 91 | 	return m.errorCount
 92 | }
 93 | 
 94 | func NewMockReporter(t *testing.T) *MockReporter {
 95 | 	rep := &MockReporter{
 96 | 		reported: "",
 97 | 		t:        t,
 98 | 		cleanups: make([]func(), 0),
 99 | 	}
100 | 	return rep
101 | }
102 | 


--------------------------------------------------------------------------------
/tests/concurrent/concurrent_test.go:
--------------------------------------------------------------------------------
 1 | package concurrent
 2 | 
 3 | import (
 4 | 	"sync"
 5 | 	"testing"
 6 | 
 7 | 	"github.com/ovechkin-dm/mockio/tests/common"
 8 | 
 9 | 	. "github.com/ovechkin-dm/mockio/mock"
10 | )
11 | 
12 | type myInterface interface {
13 | 	Foo(a int) int
14 | }
15 | 
16 | func TestNewMockInOtherFiber(t *testing.T) {
17 | 	r := common.NewMockReporter(t)
18 | 	SetUp(r)
19 | 	m := Mock[myInterface]()
20 | 	wg := sync.WaitGroup{}
21 | 	wg.Add(1)
22 | 	WhenSingle(m.Foo(Any[int]())).ThenReturn(42)
23 | 	ans := 0
24 | 	go func() {
25 | 		ans = m.Foo(10)
26 | 		wg.Done()
27 | 	}()
28 | 	wg.Wait()
29 | 
30 | 	r.AssertEqual(42, ans)
31 | 	r.AssertNoError()
32 | }
33 | 


--------------------------------------------------------------------------------
/tests/match/match_test.go:
--------------------------------------------------------------------------------
  1 | package match
  2 | 
  3 | import (
  4 | 	"testing"
  5 | 
  6 | 	"github.com/ovechkin-dm/mockio/tests/common"
  7 | 
  8 | 	. "github.com/ovechkin-dm/mockio/mock"
  9 | )
 10 | 
 11 | type Iface interface {
 12 | 	Test(i interface{}) bool
 13 | }
 14 | 
 15 | type Greeter interface {
 16 | 	Greet(name any) string
 17 | }
 18 | 
 19 | type St struct {
 20 | 	value int
 21 | }
 22 | 
 23 | type MyStruct struct {
 24 | 	items any
 25 | }
 26 | 
 27 | type MyInterface interface {
 28 | 	Test(m *MyStruct) int
 29 | }
 30 | 
 31 | type SliceInterface interface {
 32 | 	Test(m []int) int
 33 | }
 34 | 
 35 | type MapInterface interface {
 36 | 	Test(m map[int]int) int
 37 | }
 38 | 
 39 | func TestAny(t *testing.T) {
 40 | 	r := common.NewMockReporter(t)
 41 | 	SetUp(r)
 42 | 	m := Mock[Iface]()
 43 | 	WhenSingle(m.Test(Any[string]())).ThenReturn(true)
 44 | 	ret := m.Test("test")
 45 | 	r.AssertEqual(true, ret)
 46 | }
 47 | 
 48 | func TestAnyStruct(t *testing.T) {
 49 | 	r := common.NewMockReporter(t)
 50 | 	SetUp(r)
 51 | 	m := Mock[Iface]()
 52 | 	WhenSingle(m.Test(Any[*St]())).ThenReturn(true)
 53 | 	st := &St{}
 54 | 	ret := m.Test(st)
 55 | 	r.AssertEqual(true, ret)
 56 | }
 57 | 
 58 | func TestAnyWrongType(t *testing.T) {
 59 | 	r := common.NewMockReporter(t)
 60 | 	SetUp(r)
 61 | 	m := Mock[Iface]()
 62 | 	WhenSingle(m.Test(Any[int]())).ThenReturn(true)
 63 | 	ret := m.Test("test")
 64 | 	r.AssertEqual(false, ret)
 65 | }
 66 | 
 67 | func TestExactStruct(t *testing.T) {
 68 | 	r := common.NewMockReporter(t)
 69 | 	SetUp(r)
 70 | 	a := St{}
 71 | 	m := Mock[Iface]()
 72 | 	WhenSingle(m.Test(Exact(&a))).ThenReturn(true)
 73 | 	ret := m.Test(&a)
 74 | 	r.AssertEqual(true, ret)
 75 | }
 76 | 
 77 | func TestExactWrongStruct(t *testing.T) {
 78 | 	r := common.NewMockReporter(t)
 79 | 	SetUp(r)
 80 | 	a := &St{10}
 81 | 	b := &St{10}
 82 | 	m := Mock[Iface]()
 83 | 	WhenSingle(m.Test(Exact(a))).ThenReturn(true)
 84 | 	ret := m.Test(b)
 85 | 	r.AssertEqual(false, ret)
 86 | }
 87 | 
 88 | func TestEqualStruct(t *testing.T) {
 89 | 	r := common.NewMockReporter(t)
 90 | 	SetUp(r)
 91 | 	a := &St{10}
 92 | 	b := &St{10}
 93 | 	m := Mock[Iface]()
 94 | 	WhenSingle(m.Test(Equal(a))).ThenReturn(true)
 95 | 	ret := m.Test(b)
 96 | 	r.AssertEqual(true, ret)
 97 | }
 98 | 
 99 | func TestNonEqualStruct(t *testing.T) {
100 | 	r := common.NewMockReporter(t)
101 | 	SetUp(r)
102 | 	a := &St{11}
103 | 	b := &St{10}
104 | 	m := Mock[Iface]()
105 | 	WhenSingle(m.Test(Equal(a))).ThenReturn(true)
106 | 	ret := m.Test(b)
107 | 	r.AssertEqual(false, ret)
108 | }
109 | 
110 | func TestCustomMatcher(t *testing.T) {
111 | 	r := common.NewMockReporter(t)
112 | 	SetUp(r)
113 | 	even := CreateMatcher[int]("even", func(allArgs []any, actual int) bool {
114 | 		return actual%2 == 0
115 | 	})
116 | 	m := Mock[Iface]()
117 | 	WhenSingle(m.Test(even())).ThenReturn(true)
118 | 	ret1 := m.Test(10)
119 | 	ret2 := m.Test(11)
120 | 	r.AssertEqual(ret1, true)
121 | 	r.AssertEqual(ret2, false)
122 | }
123 | 
124 | func TestNotEqual(t *testing.T) {
125 | 	r := common.NewMockReporter(t)
126 | 	SetUp(r)
127 | 	m := Mock[Iface]()
128 | 	WhenSingle(m.Test(NotEqual("test"))).ThenReturn(true)
129 | 	ret := m.Test("test1")
130 | 	r.AssertEqual(true, ret)
131 | }
132 | 
133 | func TestOneOf(t *testing.T) {
134 | 	r := common.NewMockReporter(t)
135 | 	SetUp(r)
136 | 	m := Mock[Iface]()
137 | 	WhenSingle(m.Test(OneOf("test1", "test2"))).ThenReturn(true)
138 | 	ret := m.Test("test2")
139 | 	r.AssertEqual(true, ret)
140 | }
141 | 
142 | func TestDeepEqual(t *testing.T) {
143 | 	r := common.NewMockReporter(t)
144 | 	SetUp(r)
145 | 	m := Mock[MyInterface]()
146 | 	s1 := MyStruct{
147 | 		items: &[]int{1, 2, 3},
148 | 	}
149 | 	s2 := MyStruct{
150 | 		items: &[]int{1, 2, 3},
151 | 	}
152 | 	WhenSingle(m.Test(&s1)).ThenReturn(9)
153 | 	result := m.Test(&s2)
154 | 	r.AssertEqual(result, 9)
155 | }
156 | 
157 | func TestNilMatch(t *testing.T) {
158 | 	r := common.NewMockReporter(t)
159 | 	SetUp(r)
160 | 	m := Mock[Iface]()
161 | 	WhenSingle(m.Test(Nil[any]())).ThenReturn(true)
162 | 	ret := m.Test(nil)
163 | 	r.AssertEqual(true, ret)
164 | }
165 | 
166 | func TestNilNoMatch(t *testing.T) {
167 | 	r := common.NewMockReporter(t)
168 | 	SetUp(r)
169 | 	m := Mock[Iface]()
170 | 	WhenSingle(m.Test(Nil[any]())).ThenReturn(true)
171 | 	ret := m.Test(10)
172 | 	r.AssertEqual(false, ret)
173 | }
174 | 
175 | func TestSubstringMatch(t *testing.T) {
176 | 	r := common.NewMockReporter(t)
177 | 	SetUp(r)
178 | 	m := Mock[Iface]()
179 | 	WhenSingle(m.Test(Substring("test"))).ThenReturn(true)
180 | 	ret := m.Test("123test123")
181 | 	r.AssertEqual(true, ret)
182 | }
183 | 
184 | func TestSubstringNoMatch(t *testing.T) {
185 | 	r := common.NewMockReporter(t)
186 | 	SetUp(r)
187 | 	m := Mock[Iface]()
188 | 	WhenSingle(m.Test(Substring("test321"))).ThenReturn(true)
189 | 	ret := m.Test("123test123")
190 | 	r.AssertEqual(false, ret)
191 | }
192 | 
193 | func TestNotNilMatch(t *testing.T) {
194 | 	r := common.NewMockReporter(t)
195 | 	SetUp(r)
196 | 	m := Mock[Iface]()
197 | 	WhenSingle(m.Test(NotNil[any]())).ThenReturn(true)
198 | 	ret := m.Test(10)
199 | 	r.AssertEqual(true, ret)
200 | }
201 | 
202 | func TestNotNilNoMatch(t *testing.T) {
203 | 	r := common.NewMockReporter(t)
204 | 	SetUp(r)
205 | 	m := Mock[Iface]()
206 | 	WhenSingle(m.Test(NotNil[any]())).ThenReturn(true)
207 | 	ret := m.Test(nil)
208 | 	r.AssertEqual(false, ret)
209 | }
210 | 
211 | func TestRegexMatch(t *testing.T) {
212 | 	r := common.NewMockReporter(t)
213 | 	SetUp(r)
214 | 	m := Mock[Iface]()
215 | 	WhenSingle(m.Test(Regex("test"))).ThenReturn(true)
216 | 	ret := m.Test("123test123")
217 | 	r.AssertEqual(true, ret)
218 | }
219 | 
220 | func TestRegexNoMatch(t *testing.T) {
221 | 	r := common.NewMockReporter(t)
222 | 	SetUp(r)
223 | 	m := Mock[Iface]()
224 | 	WhenSingle(m.Test(Regex("test321"))).ThenReturn(true)
225 | 	ret := m.Test("123test123")
226 | 	r.AssertEqual(false, ret)
227 | }
228 | 
229 | func TestSliceLenMatch(t *testing.T) {
230 | 	r := common.NewMockReporter(t)
231 | 	SetUp(r)
232 | 	m := Mock[SliceInterface]()
233 | 	WhenSingle(m.Test(SliceLen[int](3))).ThenReturn(3)
234 | 	ret := m.Test([]int{1, 2, 3})
235 | 	r.AssertEqual(3, ret)
236 | }
237 | 
238 | func TestSliceLenNoMatch(t *testing.T) {
239 | 	r := common.NewMockReporter(t)
240 | 	SetUp(r)
241 | 	m := Mock[SliceInterface]()
242 | 	WhenSingle(m.Test(SliceLen[int](4))).ThenReturn(3)
243 | 	ret := m.Test([]int{1, 2, 3})
244 | 	r.AssertEqual(0, ret)
245 | }
246 | 
247 | func TestMapLenMatch(t *testing.T) {
248 | 	r := common.NewMockReporter(t)
249 | 	SetUp(r)
250 | 	m := Mock[MapInterface]()
251 | 	WhenSingle(m.Test(MapLen[int, int](3))).ThenReturn(3)
252 | 	ret := m.Test(map[int]int{1: 1, 2: 2, 3: 3})
253 | 	r.AssertEqual(3, ret)
254 | }
255 | 
256 | func TestMapLenNoMatch(t *testing.T) {
257 | 	r := common.NewMockReporter(t)
258 | 	SetUp(r)
259 | 	m := Mock[MapInterface]()
260 | 	WhenSingle(m.Test(MapLen[int, int](3))).ThenReturn(3)
261 | 	ret := m.Test(map[int]int{1: 1, 2: 2, 3: 3, 4: 4})
262 | 	r.AssertEqual(0, ret)
263 | }
264 | 
265 | func TestSliceContainsMatch(t *testing.T) {
266 | 	r := common.NewMockReporter(t)
267 | 	SetUp(r)
268 | 	m := Mock[SliceInterface]()
269 | 	WhenSingle(m.Test(SliceContains[int](3))).ThenReturn(3)
270 | 	ret := m.Test([]int{1, 2, 3})
271 | 	r.AssertEqual(3, ret)
272 | }
273 | 
274 | func TestSliceContainsNoMatch(t *testing.T) {
275 | 	r := common.NewMockReporter(t)
276 | 	SetUp(r)
277 | 	m := Mock[SliceInterface]()
278 | 	WhenSingle(m.Test(SliceContains[int](4))).ThenReturn(3)
279 | 	ret := m.Test([]int{1, 2, 3})
280 | 	r.AssertEqual(0, ret)
281 | }
282 | 
283 | func TestMapContainsMatch(t *testing.T) {
284 | 	r := common.NewMockReporter(t)
285 | 	SetUp(r)
286 | 	m := Mock[MapInterface]()
287 | 	WhenSingle(m.Test(MapContains[int, int](3))).ThenReturn(3)
288 | 	ret := m.Test(map[int]int{1: 1, 2: 2, 3: 3})
289 | 	r.AssertEqual(3, ret)
290 | }
291 | 
292 | func TestMapContainsNoMatch(t *testing.T) {
293 | 	r := common.NewMockReporter(t)
294 | 	SetUp(r)
295 | 	m := Mock[MapInterface]()
296 | 	WhenSingle(m.Test(MapContains[int, int](4))).ThenReturn(3)
297 | 	ret := m.Test(map[int]int{1: 1, 2: 2, 3: 3})
298 | 	r.AssertEqual(0, ret)
299 | }
300 | 
301 | func TestSliceEqualUnorderedMatch(t *testing.T) {
302 | 	r := common.NewMockReporter(t)
303 | 	SetUp(r)
304 | 	m := Mock[SliceInterface]()
305 | 	WhenSingle(m.Test(SliceEqualUnordered[int]([]int{1, 2, 3}))).ThenReturn(3)
306 | 	ret := m.Test([]int{3, 2, 1})
307 | 	r.AssertEqual(3, ret)
308 | }
309 | 
310 | func TestSliceEqualUnorderedNoMatch(t *testing.T) {
311 | 	r := common.NewMockReporter(t)
312 | 	SetUp(r)
313 | 	m := Mock[SliceInterface]()
314 | 	WhenSingle(m.Test(SliceEqualUnordered[int]([]int{1, 2, 3}))).ThenReturn(3)
315 | 	ret := m.Test([]int{3, 2, 1, 4})
316 | 	r.AssertEqual(0, ret)
317 | }
318 | 
319 | func TestUnexpectedUseOfMatchers(t *testing.T) {
320 | 	r := common.NewMockReporter(t)
321 | 	SetUp(r)
322 | 	m := Mock[Iface]()
323 | 	m.Test(AnyString())
324 | 	Verify(m, Once()).Test("test")
325 | 	r.AssertErrorContains(r.GetError(), "Unexpected matchers declaration")
326 | }
327 | 
328 | func TestExactNotComparable(t *testing.T) {
329 | 	SetUp(t)
330 | 	greeter := Mock[Greeter]()
331 | 	var data any = []int{1, 2}
332 | 	When(greeter.Greet(Exact(data))).ThenReturn("hello world")
333 | 	greeter.Greet(data)
334 | }
335 | 


--------------------------------------------------------------------------------
/tests/mocking/mock_test.go:
--------------------------------------------------------------------------------
  1 | package mocking
  2 | 
  3 | import (
  4 | 	"errors"
  5 | 	"testing"
  6 | 
  7 | 	"github.com/ovechkin-dm/mockio/tests/common"
  8 | 
  9 | 	. "github.com/ovechkin-dm/mockio/mock"
 10 | )
 11 | 
 12 | type ByteArrInterface interface {
 13 | 	DoSomething(b [16]byte) string
 14 | }
 15 | type OtherIface interface {
 16 | 	SomeMethod() bool
 17 | }
 18 | 
 19 | type CallingIface interface {
 20 | 	GetMocked(appClient OtherIface) OtherIface
 21 | }
 22 | 
 23 | type SingleArgIface interface {
 24 | 	SingleArgMethod(other OtherIface) error
 25 | }
 26 | 
 27 | type MultiMethod interface {
 28 | 	One(int) int
 29 | 	Two(int) int
 30 | 	Three(int) int
 31 | 	Four(int) int
 32 | }
 33 | 
 34 | type ParentIface interface {
 35 | 	Foo(int) int
 36 | }
 37 | 
 38 | type ChildIface interface {
 39 | 	ParentIface
 40 | 	Bar(int) int
 41 | }
 42 | 
 43 | type PrivateIface interface {
 44 | 	privateMethod() bool
 45 | }
 46 | 
 47 | func TestMockWithMockedArg(t *testing.T) {
 48 | 	r := common.NewMockReporter(t)
 49 | 	SetUp(r)
 50 | 	callingMock := Mock[CallingIface]()
 51 | 	otherMock := Mock[OtherIface]()
 52 | 	WhenSingle(callingMock.GetMocked(Exact(otherMock))).ThenReturn(otherMock)
 53 | 	res := callingMock.GetMocked(otherMock)
 54 | 	Verify(callingMock, Times(1)).GetMocked(Exact(otherMock))
 55 | 	VerifyNoMoreInteractions(callingMock)
 56 | 	r.AssertEqual(otherMock, res)
 57 | 	r.AssertNoError()
 58 | }
 59 | 
 60 | func TestByteArrayArgs(t *testing.T) {
 61 | 	r := common.NewMockReporter(t)
 62 | 	SetUp(r)
 63 | 	myMock := Mock[ByteArrInterface]()
 64 | 	myBytes := [16]byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}
 65 | 	WhenSingle(myMock.DoSomething(myBytes)).ThenReturn("test")
 66 | 	result := myMock.DoSomething(myBytes)
 67 | 	r.AssertEqual(result, "test")
 68 | }
 69 | 
 70 | func TestNilArgs(t *testing.T) {
 71 | 	r := common.NewMockReporter(t)
 72 | 	SetUp(r)
 73 | 	myMock := Mock[SingleArgIface]()
 74 | 	WhenSingle(myMock.SingleArgMethod(Any[OtherIface]())).ThenReturn(errors.New("test"))
 75 | 	result := myMock.SingleArgMethod(nil)
 76 | 	r.AssertEqual(result.Error(), "test")
 77 | }
 78 | 
 79 | func TestMultiMethodOrder(t *testing.T) {
 80 | 	r := common.NewMockReporter(t)
 81 | 	SetUp(r)
 82 | 	myMock := Mock[MultiMethod]()
 83 | 	WhenSingle(myMock.One(1)).ThenReturn(1)
 84 | 	WhenSingle(myMock.Two(2)).ThenReturn(2)
 85 | 	WhenSingle(myMock.Three(3)).ThenReturn(3)
 86 | 	WhenSingle(myMock.Four(4)).ThenReturn(4)
 87 | 	r.AssertEqual(myMock.One(1), 1)
 88 | 	r.AssertEqual(myMock.Two(2), 2)
 89 | 	r.AssertEqual(myMock.Three(3), 3)
 90 | 	r.AssertEqual(myMock.Four(4), 4)
 91 | }
 92 | 
 93 | func TestMockSimpleCasting(t *testing.T) {
 94 | 	r := common.NewMockReporter(t)
 95 | 	SetUp(r)
 96 | 	myMock := Mock[OtherIface]()
 97 | 	WhenSingle(myMock.SomeMethod()).ThenReturn(true)
 98 | 	var casted any = myMock
 99 | 	source := casted.(OtherIface)
100 | 	result := source.SomeMethod()
101 | 	r.AssertEqual(result, true)
102 | }
103 | 
104 | func TestMockCasting(t *testing.T) {
105 | 	r := common.NewMockReporter(t)
106 | 	SetUp(r)
107 | 	myMock := Mock[ChildIface]()
108 | 	WhenSingle(myMock.Foo(1)).ThenReturn(1)
109 | 	WhenSingle(myMock.Bar(1)).ThenReturn(2)
110 | 	var casted any = myMock
111 | 	source := casted.(ParentIface)
112 | 	result := source.Foo(1)
113 | 	r.AssertEqual(result, 1)
114 | }
115 | 
116 | func TestMockPrivate(t *testing.T) {
117 | 	r := common.NewMockReporter(t)
118 | 	SetUp(r)
119 | 	myMock := Mock[PrivateIface]()
120 | 	WhenSingle(myMock.privateMethod()).ThenReturn(true)
121 | 	var casted any = myMock
122 | 	source := casted.(PrivateIface)
123 | 	result := source.privateMethod()
124 | 	r.AssertNoError()
125 | 	r.AssertEqual(result, true)
126 | }
127 | 


--------------------------------------------------------------------------------
/tests/reporting/error_reporting_test.go:
--------------------------------------------------------------------------------
  1 | package reporting
  2 | 
  3 | import (
  4 | 	"sync"
  5 | 	"testing"
  6 | 
  7 | 	"github.com/ovechkin-dm/mockio/mockopts"
  8 | 	"github.com/ovechkin-dm/mockio/tests/common"
  9 | 
 10 | 	. "github.com/ovechkin-dm/mockio/mock"
 11 | )
 12 | 
 13 | type Foo interface {
 14 | 	Bar()
 15 | 	Baz(a int, b int, c int) int
 16 | 	VarArgs(a string, b ...int) int
 17 | }
 18 | 
 19 | func TestReportIncorrectWhenUsage(t *testing.T) {
 20 | 	r := common.NewMockReporter(t)
 21 | 	SetUp(r)
 22 | 	When(1)
 23 | 	r.AssertError()
 24 | 	r.PrintError()
 25 | }
 26 | 
 27 | func TestReportVerifyFromDifferentGoroutine(t *testing.T) {
 28 | 	r := common.NewMockReporter(t)
 29 | 	SetUp(r)
 30 | 	mock := Mock[Foo]()
 31 | 	wg := sync.WaitGroup{}
 32 | 	wg.Add(1)
 33 | 	go func() {
 34 | 		SetUp(r)
 35 | 		Verify(mock, Once())
 36 | 		wg.Done()
 37 | 	}()
 38 | 	wg.Wait()
 39 | 	r.AssertError()
 40 | 	r.PrintError()
 41 | }
 42 | 
 43 | func TestReportVerifyNotAMock(t *testing.T) {
 44 | 	r := common.NewMockReporter(t)
 45 | 	SetUp(r)
 46 | 	Verify(100, Once())
 47 | 	r.AssertError()
 48 | 	r.PrintError()
 49 | }
 50 | 
 51 | func TestInvalidUseOfMatchers(t *testing.T) {
 52 | 	r := common.NewMockReporter(t)
 53 | 	SetUp(r)
 54 | 	mock := Mock[Foo]()
 55 | 	When(mock.Baz(AnyInt(), AnyInt(), 10)).ThenReturn(10)
 56 | 	mock.Baz(1, 2, 3)
 57 | 	r.AssertError()
 58 | 	r.PrintError()
 59 | }
 60 | 
 61 | func TestInvalidUseOfMatchersVarArgs(t *testing.T) {
 62 | 	r := common.NewMockReporter(t)
 63 | 	SetUp(r)
 64 | 	mock := Mock[Foo]()
 65 | 	When(mock.VarArgs(AnyString(), AnyInt(), 10)).ThenReturn(10)
 66 | 	mock.VarArgs("a", 2)
 67 | 	r.AssertError()
 68 | 	r.PrintError()
 69 | }
 70 | 
 71 | func TestCaptorInsideVerify(t *testing.T) {
 72 | 	r := common.NewMockReporter(t)
 73 | 	SetUp(r)
 74 | 	mock := Mock[Foo]()
 75 | 	When(mock.Baz(AnyInt(), AnyInt(), AnyInt())).ThenReturn(10)
 76 | 	c := Captor[int]()
 77 | 	Verify(mock, Once()).Baz(AnyInt(), AnyInt(), c.Capture())
 78 | 	r.AssertError()
 79 | 	r.PrintError()
 80 | }
 81 | 
 82 | func TestVerify(t *testing.T) {
 83 | 	r := common.NewMockReporter(t)
 84 | 	SetUp(r)
 85 | 	mock := Mock[Foo]()
 86 | 	When(mock.Baz(AnyInt(), AnyInt(), AnyInt())).ThenReturn(10)
 87 | 	_ = mock.Baz(10, 10, 11)
 88 | 	Verify(mock, Once()).Baz(AnyInt(), AnyInt(), Exact(10))
 89 | 	r.AssertError()
 90 | 	r.PrintError()
 91 | }
 92 | 
 93 | func TestVerifyVarArgs(t *testing.T) {
 94 | 	r := common.NewMockReporter(t)
 95 | 	SetUp(r)
 96 | 	mock := Mock[Foo]()
 97 | 	When(mock.VarArgs(AnyString(), AnyInt(), AnyInt())).ThenReturn(10)
 98 | 	_ = mock.VarArgs("a", 10, 11)
 99 | 	Verify(mock, Once()).VarArgs(AnyString(), AnyInt(), Exact(10))
100 | 	r.AssertError()
101 | 	r.PrintError()
102 | }
103 | 
104 | func TestVerifyDifferentVarArgs(t *testing.T) {
105 | 	r := common.NewMockReporter(t)
106 | 	SetUp(r)
107 | 	mock := Mock[Foo]()
108 | 	When(mock.VarArgs(AnyString(), AnyInt(), AnyInt())).ThenReturn(10)
109 | 	_ = mock.VarArgs("a", 10, 11)
110 | 	Verify(mock, Once()).VarArgs(AnyString(), AnyInt(), AnyInt(), AnyInt())
111 | 	r.AssertError()
112 | 	r.PrintError()
113 | }
114 | 
115 | func TestVerifyTimes(t *testing.T) {
116 | 	r := common.NewMockReporter(t)
117 | 	SetUp(r)
118 | 	mock := Mock[Foo]()
119 | 	When(mock.Baz(AnyInt(), AnyInt(), AnyInt())).ThenReturn(10)
120 | 	_ = mock.Baz(10, 10, 10)
121 | 	Verify(mock, Times(20)).Baz(AnyInt(), AnyInt(), AnyInt())
122 | 	r.AssertError()
123 | 	r.PrintError()
124 | }
125 | 
126 | func TestEmptyCaptor(t *testing.T) {
127 | 	r := common.NewMockReporter(t)
128 | 	SetUp(r)
129 | 	c := Captor[int]()
130 | 	_ = c.Last()
131 | 	r.AssertError()
132 | 	r.PrintError()
133 | }
134 | 
135 | func TestInvalidReturnValues(t *testing.T) {
136 | 	r := common.NewMockReporter(t)
137 | 	SetUp(r)
138 | 	mock := Mock[Foo]()
139 | 	When(mock.Baz(AnyInt(), AnyInt(), AnyInt())).ThenReturn("test", 10)
140 | 	_ = mock.Baz(10, 10, 10)
141 | 	r.AssertError()
142 | 	r.PrintError()
143 | }
144 | 
145 | func TestNoMoreInteractions(t *testing.T) {
146 | 	r := common.NewMockReporter(t)
147 | 	SetUp(r)
148 | 	mock := Mock[Foo]()
149 | 	When(mock.Baz(AnyInt(), AnyInt(), AnyInt())).ThenReturn("test", 10)
150 | 	_ = mock.Baz(10, 10, 10)
151 | 	_ = mock.Baz(10, 20, 10)
152 | 	VerifyNoMoreInteractions(mock)
153 | 	r.AssertError()
154 | 	r.PrintError()
155 | }
156 | 
157 | func TestNoMoreInteractionsVarArgs(t *testing.T) {
158 | 	r := common.NewMockReporter(t)
159 | 	SetUp(r)
160 | 	mock := Mock[Foo]()
161 | 	When(mock.VarArgs(AnyString(), AnyInt(), AnyInt())).ThenReturn("test", 10)
162 | 	_ = mock.Baz(10, 10, 10)
163 | 	_ = mock.Baz(10, 20, 10)
164 | 	VerifyNoMoreInteractions(mock)
165 | 	r.AssertError()
166 | 	r.PrintError()
167 | }
168 | 
169 | func TestUnexpectedMatchers(t *testing.T) {
170 | 	r := common.NewMockReporter(t)
171 | 	SetUp(r)
172 | 	mock := Mock[Foo]()
173 | 	When(mock.Baz(AnyInt(), AnyInt(), AnyInt())).ThenReturn(10)
174 | 	mock.Baz(AnyInt(), AnyInt(), AnyInt())
175 | 	Verify(mock, Once()).Baz(10, 10, 10)
176 | 	r.AssertError()
177 | 	r.PrintError()
178 | }
179 | 
180 | func TestStackTraceDisabled(t *testing.T) {
181 | 	r := common.NewMockReporter(t)
182 | 	SetUp(r, mockopts.WithoutStackTrace())
183 | 	mock := Mock[Foo]()
184 | 	WhenSingle(mock.Baz(1, 2, AnyInt())).ThenReturn(10)
185 | 	_ = mock.Baz(1, 2, 3)
186 | 	r.AssertError()
187 | 	r.PrintError()
188 | }
189 | 
190 | func TestStackTraceEnabled(t *testing.T) {
191 | 	r := common.NewMockReporter(t)
192 | 	SetUp(r)
193 | 	mock := Mock[Foo]()
194 | 	WhenSingle(mock.Baz(1, 2, AnyInt())).ThenReturn(10)
195 | 	_ = mock.Baz(1, 2, 3)
196 | 	r.AssertError()
197 | 	r.PrintError()
198 | }
199 | 
200 | func TestImplicitMatchersLogValue(t *testing.T) {
201 | 	r := common.NewMockReporter(t)
202 | 	SetUp(r)
203 | 	mock := Mock[Foo]()
204 | 	WhenSingle(mock.Baz(1, 2, 3)).ThenReturn(10).Verify(Once())
205 | 	r.TriggerCleanup()
206 | 	r.AssertError()
207 | 	r.PrintError()
208 | }
209 | 


--------------------------------------------------------------------------------
/tests/returners/returners_test.go:
--------------------------------------------------------------------------------
 1 | package returners
 2 | 
 3 | import (
 4 | 	"testing"
 5 | 
 6 | 	"github.com/ovechkin-dm/mockio/tests/common"
 7 | 
 8 | 	. "github.com/ovechkin-dm/mockio/mock"
 9 | )
10 | 
11 | type iface interface {
12 | 	Test(i interface{}) bool
13 | 	Foo(i int) int
14 | }
15 | 
16 | func TestReturnSimple(t *testing.T) {
17 | 	r := common.NewMockReporter(t)
18 | 	SetUp(r)
19 | 	m := Mock[iface]()
20 | 	WhenSingle(m.Test(10)).ThenReturn(true)
21 | 	ret := m.Test(10)
22 | 	r.AssertEqual(true, ret)
23 | }
24 | 
25 | func TestAnswerSimple(t *testing.T) {
26 | 	r := common.NewMockReporter(t)
27 | 	SetUp(r)
28 | 	m := Mock[iface]()
29 | 	WhenSingle(m.Test(10)).ThenAnswer(func(args []any) bool {
30 | 		return args[0].(int) > 0
31 | 	})
32 | 	ret1 := m.Test(10)
33 | 	ret2 := m.Test(-10)
34 | 	r.AssertEqual(true, ret1)
35 | 	r.AssertEqual(false, ret2)
36 | }
37 | 
38 | func TestMultiReturn(t *testing.T) {
39 | 	r := common.NewMockReporter(t)
40 | 	SetUp(r)
41 | 	m := Mock[iface]()
42 | 	WhenSingle(m.Foo(10)).
43 | 		ThenReturn(1).
44 | 		ThenReturn(2)
45 | 	ret1 := m.Foo(10)
46 | 	ret2 := m.Foo(10)
47 | 	ret3 := m.Foo(10)
48 | 	r.AssertEqual(1, ret1)
49 | 	r.AssertEqual(2, ret2)
50 | 	r.AssertEqual(2, ret3)
51 | }
52 | 
53 | func TestMultiAnswer(t *testing.T) {
54 | 	r := common.NewMockReporter(t)
55 | 	SetUp(r)
56 | 	m := Mock[iface]()
57 | 	WhenSingle(m.Foo(10)).
58 | 		ThenAnswer(func(args []any) int {
59 | 			return 1
60 | 		}).
61 | 		ThenAnswer(func(args []any) int {
62 | 			return 2
63 | 		})
64 | 	ret1 := m.Foo(10)
65 | 	ret2 := m.Foo(10)
66 | 	ret3 := m.Foo(10)
67 | 	r.AssertEqual(1, ret1)
68 | 	r.AssertEqual(2, ret2)
69 | 	r.AssertEqual(2, ret3)
70 | }
71 | 
72 | func TestReturnBetweenCalls(t *testing.T) {
73 | 	r := common.NewMockReporter(t)
74 | 	SetUp(r)
75 | 	m := Mock[iface]()
76 | 	ret := WhenSingle(m.Foo(10))
77 | 	ret.ThenReturn(1)
78 | 	r1 := m.Foo(10)
79 | 	ret.ThenReturn(2)
80 | 	r2 := m.Foo(10)
81 | 	r3 := m.Foo(10)
82 | 	r.AssertEqual(1, r1)
83 | 	r.AssertEqual(2, r2)
84 | 	r.AssertEqual(2, r3)
85 | }
86 | 
87 | func TestReturnWrongType(t *testing.T) {
88 | 	r := common.NewMockReporter(t)
89 | 	SetUp(r)
90 | 	m := Mock[iface]()
91 | 	When(m.Test(Any[any]())).ThenReturn(10)
92 | 	m.Test(10)
93 | 	r.AssertError()
94 | }
95 | 


--------------------------------------------------------------------------------
/tests/simple/simple_test.go:
--------------------------------------------------------------------------------
 1 | package simple
 2 | 
 3 | import (
 4 | 	"testing"
 5 | 
 6 | 	"github.com/ovechkin-dm/mockio/tests/common"
 7 | 
 8 | 	. "github.com/ovechkin-dm/mockio/mock"
 9 | )
10 | 
11 | type myInterface interface {
12 | 	Foo(a int) int
13 | }
14 | 
15 | func TestSimple(t *testing.T) {
16 | 	r := common.NewMockReporter(t)
17 | 	SetUp(r)
18 | 	m := Mock[myInterface]()
19 | 	WhenSingle(m.Foo(Any[int]())).ThenReturn(42)
20 | 	ret := m.Foo(10)
21 | 	r.AssertEqual(42, ret)
22 | 	Verify(m, AtLeastOnce()).Foo(10)
23 | }
24 | 


--------------------------------------------------------------------------------
/tests/variadic/variadic_test.go:
--------------------------------------------------------------------------------
 1 | package variadic
 2 | 
 3 | import (
 4 | 	"testing"
 5 | 
 6 | 	"github.com/ovechkin-dm/mockio/tests/common"
 7 | 
 8 | 	. "github.com/ovechkin-dm/mockio/mock"
 9 | )
10 | 
11 | type myInterface interface {
12 | 	Foo(a ...int) int
13 | }
14 | 
15 | func TestVariadicSimple(t *testing.T) {
16 | 	r := common.NewMockReporter(t)
17 | 	SetUp(r)
18 | 	m := Mock[myInterface]()
19 | 	WhenSingle(m.Foo(1, 1)).ThenReturn(1)
20 | 	WhenSingle(m.Foo(1)).ThenReturn(2)
21 | 	ret := m.Foo(1)
22 | 	r.AssertEqual(2, ret)
23 | 	Verify(m, AtLeastOnce()).Foo(1)
24 | 	r.AssertNoError()
25 | }
26 | 
27 | func TestCaptor(t *testing.T) {
28 | 	r := common.NewMockReporter(t)
29 | 	SetUp(r)
30 | 	m := Mock[myInterface]()
31 | 	c1 := Captor[int]()
32 | 	c2 := Captor[int]()
33 | 	WhenSingle(m.Foo(c1.Capture(), c2.Capture())).ThenReturn(1)
34 | 	ret := m.Foo(1, 2)
35 | 	r.AssertEqual(1, ret)
36 | 	r.AssertEqual(c1.Last(), 1)
37 | 	r.AssertEqual(c2.Last(), 2)
38 | 	r.AssertNoError()
39 | }
40 | 


--------------------------------------------------------------------------------
/tests/verify/verify_test.go:
--------------------------------------------------------------------------------
  1 | package verify
  2 | 
  3 | import (
  4 | 	"testing"
  5 | 
  6 | 	"github.com/ovechkin-dm/mockio/mockopts"
  7 | 	"github.com/ovechkin-dm/mockio/tests/common"
  8 | 
  9 | 	. "github.com/ovechkin-dm/mockio/mock"
 10 | )
 11 | 
 12 | type iface interface {
 13 | 	Foo(a int) int
 14 | }
 15 | 
 16 | type ifaceMockArg interface {
 17 | 	MockAsArg(m iface)
 18 | }
 19 | 
 20 | func TestVerifySimple(t *testing.T) {
 21 | 	r := common.NewMockReporter(t)
 22 | 	SetUp(r)
 23 | 	m := Mock[iface]()
 24 | 	WhenSingle(m.Foo(Any[int]())).ThenReturn(10)
 25 | 	m.Foo(10)
 26 | 	Verify(m, Once()).Foo(10)
 27 | 	r.AssertNoError()
 28 | }
 29 | 
 30 | func TestVerifyAny(t *testing.T) {
 31 | 	r := common.NewMockReporter(t)
 32 | 	SetUp(r)
 33 | 	m := Mock[iface]()
 34 | 	WhenSingle(m.Foo(Any[int]())).ThenReturn(10)
 35 | 	m.Foo(10)
 36 | 	Verify(m, Once()).Foo(Any[int]())
 37 | 	r.AssertNoError()
 38 | }
 39 | 
 40 | func TestVerifyMultipleAny(t *testing.T) {
 41 | 	r := common.NewMockReporter(t)
 42 | 	SetUp(r)
 43 | 	m := Mock[iface]()
 44 | 	WhenSingle(m.Foo(Any[int]())).ThenReturn(10)
 45 | 	m.Foo(10)
 46 | 	m.Foo(11)
 47 | 	Verify(m, Times(2)).Foo(Any[int]())
 48 | 	r.AssertNoError()
 49 | }
 50 | 
 51 | func TestVerifyNever(t *testing.T) {
 52 | 	r := common.NewMockReporter(t)
 53 | 	SetUp(r)
 54 | 	m := Mock[iface]()
 55 | 	WhenSingle(m.Foo(Any[int]())).ThenReturn(10)
 56 | 	m.Foo(10)
 57 | 	m.Foo(11)
 58 | 	Verify(m, Never()).Foo(13)
 59 | 	r.AssertNoError()
 60 | }
 61 | 
 62 | func TestVerifyNeverFails(t *testing.T) {
 63 | 	r := common.NewMockReporter(t)
 64 | 	SetUp(r)
 65 | 	m := Mock[iface]()
 66 | 	WhenSingle(m.Foo(Any[int]())).ThenReturn(10)
 67 | 	m.Foo(10)
 68 | 	m.Foo(11)
 69 | 	Verify(m, Never()).Foo(10)
 70 | 	r.AssertError()
 71 | }
 72 | 
 73 | func TestNoMoreInteractionsFails(t *testing.T) {
 74 | 	r := common.NewMockReporter(t)
 75 | 	SetUp(r)
 76 | 	m := Mock[iface]()
 77 | 	WhenSingle(m.Foo(Any[int]())).ThenReturn(10)
 78 | 	m.Foo(10)
 79 | 	VerifyNoMoreInteractions(m)
 80 | 	r.AssertError()
 81 | }
 82 | 
 83 | func TestNoMoreInteractionsSuccess(t *testing.T) {
 84 | 	r := common.NewMockReporter(t)
 85 | 	SetUp(r)
 86 | 	m := Mock[iface]()
 87 | 	WhenSingle(m.Foo(Any[int]())).ThenReturn(10)
 88 | 	m.Foo(10)
 89 | 	Verify(m, Once()).Foo(10)
 90 | 	VerifyNoMoreInteractions(m)
 91 | 	r.AssertNoError()
 92 | }
 93 | 
 94 | func TestNoMoreInteractionsComplexFail(t *testing.T) {
 95 | 	r := common.NewMockReporter(t)
 96 | 	SetUp(r)
 97 | 	m := Mock[iface]()
 98 | 	WhenSingle(m.Foo(10)).ThenReturn(10)
 99 | 	WhenSingle(m.Foo(11)).ThenReturn(10)
100 | 	m.Foo(10)
101 | 	m.Foo(11)
102 | 	Verify(m, Once()).Foo(10)
103 | 	VerifyNoMoreInteractions(m)
104 | 	r.AssertError()
105 | }
106 | 
107 | func TestNoMoreInteractionsComplexSuccess(t *testing.T) {
108 | 	r := common.NewMockReporter(t)
109 | 	SetUp(r)
110 | 	m := Mock[iface]()
111 | 	WhenSingle(m.Foo(10)).ThenReturn(10)
112 | 	WhenSingle(m.Foo(11)).ThenReturn(10)
113 | 	m.Foo(10)
114 | 	m.Foo(11)
115 | 	Verify(m, AtLeastOnce()).Foo(AnyInt())
116 | 	Verify(m, Once()).Foo(11)
117 | 	VerifyNoMoreInteractions(m)
118 | 	r.AssertNoError()
119 | }
120 | 
121 | func TestVerifyInsideReturnerPass(t *testing.T) {
122 | 	r := common.NewMockReporter(t)
123 | 	SetUp(r)
124 | 	m := Mock[iface]()
125 | 	WhenSingle(m.Foo(AnyInt())).ThenReturn(11).Verify(Once())
126 | 	m.Foo(10)
127 | 	r.TriggerCleanup()
128 | 	r.AssertNoError()
129 | }
130 | 
131 | func TestVerifyInsideReturnerNoMoreInteractionsFail(t *testing.T) {
132 | 	r := common.NewMockReporter(t)
133 | 	SetUp(r)
134 | 	m := Mock[iface]()
135 | 	WhenSingle(m.Foo(AnyInt())).ThenReturn(11).Verify(Once())
136 | 	VerifyNoMoreInteractions(m)
137 | 	r.AssertError()
138 | }
139 | 
140 | func TestVerifyInsideReturnerFail(t *testing.T) {
141 | 	r := common.NewMockReporter(t)
142 | 	SetUp(r)
143 | 	m := Mock[iface]()
144 | 	WhenSingle(m.Foo(AnyInt())).ThenReturn(11).Verify(Once())
145 | 	r.TriggerCleanup()
146 | 	r.AssertError()
147 | }
148 | 
149 | func TestVerifyMockAsArg(t *testing.T) {
150 | 	r := common.NewMockReporter(t)
151 | 	SetUp(r)
152 | 	m := Mock[iface]()
153 | 	m2 := Mock[ifaceMockArg]()
154 | 
155 | 	m2.MockAsArg(m)
156 | 
157 | 	Verify(m2, Once()).MockAsArg(Any[iface]())
158 | 
159 | 	r.AssertNoError()
160 | }
161 | 
162 | func TestPostponedVerifyNotFailingImmediately(t *testing.T) {
163 | 	r := common.NewMockReporter(t)
164 | 	SetUp(r)
165 | 	m := Mock[iface]()
166 | 	WhenSingle(m.Foo(12)).ThenReturn(11).Verify(Once())
167 | 	m.Foo(10)
168 | 	r.TriggerCleanup()
169 | 	r.AssertError()
170 | 	r.AssertEqual(r.GetErrorCount(), 1)
171 | }
172 | 
173 | func TestStrictVerifyUnwantedInvocation(t *testing.T) {
174 | 	r := common.NewMockReporter(t)
175 | 	SetUp(r, mockopts.StrictVerify())
176 | 	m := Mock[iface]()
177 | 	m.Foo(12)
178 | 	r.TriggerCleanup()
179 | 	r.AssertError()
180 | }
181 | 
182 | func TestStrictVerifyUnverifiedStub(t *testing.T) {
183 | 	r := common.NewMockReporter(t)
184 | 	SetUp(r, mockopts.StrictVerify())
185 | 	m := Mock[iface]()
186 | 	WhenSingle(m.Foo(12)).ThenReturn(11)
187 | 	r.TriggerCleanup()
188 | 	r.AssertError()
189 | }
190 | 
191 | func TestVerifyNeverInReturner(t *testing.T) {
192 | 	SetUp(t, mockopts.StrictVerify())
193 | 	m := Mock[iface]()
194 | 	WhenSingle(m.Foo(12)).Verify(Never())
195 | }
196 | 


--------------------------------------------------------------------------------
/tests/when/when_double_test.go:
--------------------------------------------------------------------------------
  1 | package when
  2 | 
  3 | import (
  4 | 	"errors"
  5 | 	"testing"
  6 | 
  7 | 	"github.com/ovechkin-dm/mockio/tests/common"
  8 | 
  9 | 	. "github.com/ovechkin-dm/mockio/mock"
 10 | )
 11 | 
 12 | type WhenDoubleInterface interface {
 13 | 	Foo(a int) (int, error)
 14 | 	FooNullable(a int) (*int, error)
 15 | }
 16 | 
 17 | func TestWhenDoubleRet(t *testing.T) {
 18 | 	r := common.NewMockReporter(t)
 19 | 	SetUp(r)
 20 | 	m := Mock[WhenDoubleInterface]()
 21 | 	WhenDouble(m.Foo(Any[int]())).ThenReturn(42, nil)
 22 | 	ret, _ := m.Foo(10)
 23 | 	r.AssertEqual(42, ret)
 24 | }
 25 | 
 26 | func TestWhenDoubleAnswer(t *testing.T) {
 27 | 	r := common.NewMockReporter(t)
 28 | 	SetUp(r)
 29 | 	m := Mock[WhenDoubleInterface]()
 30 | 	WhenDouble(m.Foo(Any[int]())).ThenAnswer(func(args []any) (int, error) {
 31 | 		return 42, nil
 32 | 	})
 33 | 	ret, _ := m.Foo(10)
 34 | 	r.AssertEqual(42, ret)
 35 | }
 36 | 
 37 | func TestWhenDoubleAnswerWithArgs(t *testing.T) {
 38 | 	r := common.NewMockReporter(t)
 39 | 	SetUp(r)
 40 | 	m := Mock[WhenDoubleInterface]()
 41 | 	WhenDouble(m.Foo(Any[int]())).ThenAnswer(func(args []any) (int, error) {
 42 | 		return args[0].(int) + 1, nil
 43 | 	})
 44 | 	ret, _ := m.Foo(10)
 45 | 	r.AssertEqual(11, ret)
 46 | }
 47 | 
 48 | func TestWhenDoubleMultiAnswer(t *testing.T) {
 49 | 	r := common.NewMockReporter(t)
 50 | 	SetUp(r)
 51 | 	m := Mock[WhenDoubleInterface]()
 52 | 	WhenDouble(m.Foo(Any[int]())).
 53 | 		ThenAnswer(func(args []any) (int, error) {
 54 | 			return args[0].(int) + 1, nil
 55 | 		}).
 56 | 		ThenAnswer(func(args []any) (int, error) {
 57 | 			return args[0].(int) + 2, nil
 58 | 		})
 59 | 	ret1, _ := m.Foo(10)
 60 | 	ret2, _ := m.Foo(11)
 61 | 	r.AssertEqual(11, ret1)
 62 | 	r.AssertEqual(13, ret2)
 63 | }
 64 | 
 65 | func TestWhenDoubleMultiReturn(t *testing.T) {
 66 | 	r := common.NewMockReporter(t)
 67 | 	SetUp(r)
 68 | 	m := Mock[WhenDoubleInterface]()
 69 | 	WhenDouble(m.Foo(Any[int]())).
 70 | 		ThenReturn(10, nil).
 71 | 		ThenReturn(11, nil)
 72 | 	ret1, _ := m.Foo(12)
 73 | 	ret2, _ := m.Foo(13)
 74 | 	r.AssertEqual(10, ret1)
 75 | 	r.AssertEqual(11, ret2)
 76 | }
 77 | 
 78 | func TestWhenDoubleAnswerAndReturn(t *testing.T) {
 79 | 	r := common.NewMockReporter(t)
 80 | 	SetUp(r)
 81 | 	m := Mock[WhenDoubleInterface]()
 82 | 	WhenDouble(m.Foo(Any[int]())).
 83 | 		ThenReturn(10, nil).
 84 | 		ThenAnswer(func(args []any) (int, error) {
 85 | 			return args[0].(int) + 1, nil
 86 | 		}).
 87 | 		ThenReturn(11, nil)
 88 | 	ret1, _ := m.Foo(12)
 89 | 	ret2, _ := m.Foo(14)
 90 | 	ret3, _ := m.Foo(15)
 91 | 	r.AssertEqual(10, ret1)
 92 | 	r.AssertEqual(15, ret2)
 93 | 	r.AssertEqual(11, ret3)
 94 | }
 95 | 
 96 | func TestWhenDoubleReturnError(t *testing.T) {
 97 | 	r := common.NewMockReporter(t)
 98 | 	SetUp(r)
 99 | 	m := Mock[WhenDoubleInterface]()
100 | 	WhenDouble(m.Foo(Any[int]())).
101 | 		ThenReturn(1, errors.New("err"))
102 | 	ret, err := m.Foo(12)
103 | 	r.AssertEqual(1, ret)
104 | 	r.AssertErrorContains(err, "err")
105 | }
106 | 
107 | func TestWhenDoubleAnswerError(t *testing.T) {
108 | 	r := common.NewMockReporter(t)
109 | 	SetUp(r)
110 | 	m := Mock[WhenDoubleInterface]()
111 | 	WhenDouble(m.Foo(Any[int]())).
112 | 		ThenAnswer(func(args []any) (int, error) {
113 | 			return 0, errors.New("err")
114 | 		})
115 | 	ret, err := m.Foo(12)
116 | 	r.AssertEqual(0, ret)
117 | 	r.AssertErrorContains(err, "err")
118 | }
119 | 


--------------------------------------------------------------------------------
/tests/when/when_single_test.go:
--------------------------------------------------------------------------------
  1 | package when
  2 | 
  3 | import (
  4 | 	"testing"
  5 | 
  6 | 	"github.com/ovechkin-dm/mockio/tests/common"
  7 | 
  8 | 	. "github.com/ovechkin-dm/mockio/mock"
  9 | )
 10 | 
 11 | type whenSingleInterface interface {
 12 | 	Foo(a int) int
 13 | }
 14 | 
 15 | type whenSingleMockAsArgInterface interface {
 16 | 	MockAsArg(m whenSingleInterface) bool
 17 | }
 18 | 
 19 | func TestWhenSingleRet(t *testing.T) {
 20 | 	r := common.NewMockReporter(t)
 21 | 	SetUp(r)
 22 | 	m := Mock[whenSingleInterface]()
 23 | 	WhenSingle(m.Foo(Any[int]())).ThenReturn(42)
 24 | 	ret := m.Foo(10)
 25 | 	r.AssertEqual(42, ret)
 26 | }
 27 | 
 28 | func TestWhenSingleAnswer(t *testing.T) {
 29 | 	r := common.NewMockReporter(t)
 30 | 	SetUp(r)
 31 | 	m := Mock[whenSingleInterface]()
 32 | 	WhenSingle(m.Foo(Any[int]())).ThenAnswer(func(args []any) int {
 33 | 		return 42
 34 | 	})
 35 | 	ret := m.Foo(10)
 36 | 	r.AssertEqual(42, ret)
 37 | }
 38 | 
 39 | func TestWhenSingleAnswerWithArgs(t *testing.T) {
 40 | 	r := common.NewMockReporter(t)
 41 | 	SetUp(r)
 42 | 	m := Mock[whenSingleInterface]()
 43 | 	WhenSingle(m.Foo(Any[int]())).ThenAnswer(func(args []any) int {
 44 | 		return args[0].(int) + 1
 45 | 	})
 46 | 	ret := m.Foo(10)
 47 | 	r.AssertEqual(11, ret)
 48 | }
 49 | 
 50 | func TestWhenSingleMultiAnswer(t *testing.T) {
 51 | 	r := common.NewMockReporter(t)
 52 | 	SetUp(r)
 53 | 	m := Mock[whenSingleInterface]()
 54 | 	WhenSingle(m.Foo(Any[int]())).
 55 | 		ThenAnswer(func(args []any) int {
 56 | 			return args[0].(int) + 1
 57 | 		}).
 58 | 		ThenAnswer(func(args []any) int {
 59 | 			return args[0].(int) + 2
 60 | 		})
 61 | 	ret1 := m.Foo(10)
 62 | 	ret2 := m.Foo(11)
 63 | 	r.AssertEqual(11, ret1)
 64 | 	r.AssertEqual(13, ret2)
 65 | }
 66 | 
 67 | func TestWhenSingleMultiReturn(t *testing.T) {
 68 | 	r := common.NewMockReporter(t)
 69 | 	SetUp(r)
 70 | 	m := Mock[whenSingleInterface]()
 71 | 	WhenSingle(m.Foo(Any[int]())).
 72 | 		ThenReturn(10).
 73 | 		ThenReturn(11)
 74 | 	ret1 := m.Foo(12)
 75 | 	ret2 := m.Foo(13)
 76 | 	r.AssertEqual(10, ret1)
 77 | 	r.AssertEqual(11, ret2)
 78 | }
 79 | 
 80 | func TestWhenSingleAnswerAndReturn(t *testing.T) {
 81 | 	r := common.NewMockReporter(t)
 82 | 	SetUp(r)
 83 | 	m := Mock[whenSingleInterface]()
 84 | 	WhenSingle(m.Foo(Any[int]())).
 85 | 		ThenReturn(10).
 86 | 		ThenAnswer(func(args []any) int {
 87 | 			return args[0].(int) + 1
 88 | 		}).
 89 | 		ThenReturn(11)
 90 | 	ret1 := m.Foo(12)
 91 | 	ret2 := m.Foo(14)
 92 | 	ret3 := m.Foo(15)
 93 | 	r.AssertEqual(10, ret1)
 94 | 	r.AssertEqual(15, ret2)
 95 | 	r.AssertEqual(11, ret3)
 96 | }
 97 | 
 98 | func TestWhenSingleMockAsArg(t *testing.T) {
 99 | 	r := common.NewMockReporter(t)
100 | 	SetUp(r)
101 | 	m := Mock[whenSingleInterface]()
102 | 	m2 := Mock[whenSingleMockAsArgInterface]()
103 | 
104 | 	WhenSingle(m2.MockAsArg(Any[whenSingleInterface]())).ThenReturn(true)
105 | 
106 | 	res := m2.MockAsArg(m)
107 | 
108 | 	r.AssertEqual(true, res)
109 | 	r.AssertNoError()
110 | }
111 | 


--------------------------------------------------------------------------------
/tests/when/when_test.go:
--------------------------------------------------------------------------------
  1 | package when
  2 | 
  3 | import (
  4 | 	"testing"
  5 | 
  6 | 	"github.com/ovechkin-dm/mockio/tests/common"
  7 | 
  8 | 	. "github.com/ovechkin-dm/mockio/mock"
  9 | )
 10 | 
 11 | type WhenInterface interface {
 12 | 	Foo(a int) (int, string)
 13 | 	Bar(a int, b string, c string) (int, string)
 14 | 	NullableBar(a int, b string, c string) (*int, *string)
 15 | 	Empty() int
 16 | 	RespondWithMock() Nested
 17 | 	RespondWithSlice() []int
 18 | }
 19 | 
 20 | type WhenInterface2 interface {
 21 | 	Bar(a int, b string, c string) (int, string)
 22 | }
 23 | 
 24 | type Nested interface {
 25 | 	Foo() int
 26 | }
 27 | 
 28 | type WhenStruct struct{}
 29 | 
 30 | func (w *WhenStruct) foo() int {
 31 | 	return 10
 32 | }
 33 | 
 34 | func TestWhenRet(t *testing.T) {
 35 | 	r := common.NewMockReporter(t)
 36 | 	SetUp(r)
 37 | 	m := Mock[WhenInterface]()
 38 | 	When(m.Foo(Any[int]())).ThenReturn(42, "test")
 39 | 	i, s := m.Foo(10)
 40 | 	r.AssertEqual(42, i)
 41 | 	r.AssertEqual("test", s)
 42 | }
 43 | 
 44 | func TestEmptyWhenErr(t *testing.T) {
 45 | 	r := common.NewMockReporter(t)
 46 | 	SetUp(r)
 47 | 	ws := &WhenStruct{}
 48 | 	When(ws.foo())
 49 | 	r.AssertError()
 50 | }
 51 | 
 52 | func TestIncorrectNumMatchers(t *testing.T) {
 53 | 	r := common.NewMockReporter(t)
 54 | 	SetUp(r)
 55 | 	m := Mock[WhenInterface]()
 56 | 	When(m.Bar(10, Any[string](), Any[string]()))
 57 | 	r.AssertError()
 58 | }
 59 | 
 60 | func TestIncorrectMatchersReuse(t *testing.T) {
 61 | 	r := common.NewMockReporter(t)
 62 | 	SetUp(r)
 63 | 	m := Mock[WhenInterface]()
 64 | 	anyS := Any[string]()
 65 | 	When(m.Bar(10, anyS, anyS))
 66 | 	r.AssertError()
 67 | }
 68 | 
 69 | func TestNoMatchersAreExactOnReturn(t *testing.T) {
 70 | 	r := common.NewMockReporter(t)
 71 | 	SetUp(r)
 72 | 	m := Mock[WhenInterface]()
 73 | 	When(m.Bar(10, "test1", "test2")).ThenReturn(10, "2")
 74 | 	r.AssertNoError()
 75 | 	i, s := m.Bar(10, "test1", "test2")
 76 | 	r.AssertEqual(10, i)
 77 | 	r.AssertEqual("2", s)
 78 | }
 79 | 
 80 | func TestIncorrectNumberReturnNullable(t *testing.T) {
 81 | 	r := common.NewMockReporter(t)
 82 | 	SetUp(r)
 83 | 	m := Mock[WhenInterface]()
 84 | 	When(m.NullableBar(10, "test1", "test2")).ThenReturn(nil)
 85 | 	_, _ = m.NullableBar(10, "test1", "test2")
 86 | 	r.AssertError()
 87 | 	r.ErrorContains("invalid return values")
 88 | }
 89 | 
 90 | func TestNoMatchersAreExactOnAnswer(t *testing.T) {
 91 | 	r := common.NewMockReporter(t)
 92 | 	SetUp(r)
 93 | 	m := Mock[WhenInterface]()
 94 | 	When(m.Bar(10, "test1", "test2")).ThenAnswer(func(args []any) []any {
 95 | 		return []any{args[0].(int) + 1, "2"}
 96 | 	})
 97 | 	r.AssertNoError()
 98 | 	i, s := m.Bar(10, "test1", "test2")
 99 | 	r.AssertEqual(11, i)
100 | 	r.AssertEqual("2", s)
101 | }
102 | 
103 | func TestEmptyArgs(t *testing.T) {
104 | 	r := common.NewMockReporter(t)
105 | 	SetUp(r)
106 | 	m := Mock[WhenInterface]()
107 | 	When(m.Empty()).ThenReturn(10)
108 | 	ret := m.Empty()
109 | 	r.AssertEqual(10, ret)
110 | }
111 | 
112 | func TestWhenMultipleIfaces(t *testing.T) {
113 | 	r := common.NewMockReporter(t)
114 | 	SetUp(r)
115 | 	m1 := Mock[WhenInterface]()
116 | 	m2 := Mock[WhenInterface2]()
117 | 	When(m1.Bar(10, "test", "test")).ThenReturn(10, "test")
118 | 	When(m2.Bar(10, "test", "test")).ThenReturn(11, "test1")
119 | 	i1, s1 := m1.Bar(10, "test", "test")
120 | 	i2, s2 := m2.Bar(10, "test", "test")
121 | 	r.AssertEqual(10, i1)
122 | 	r.AssertEqual("test", s1)
123 | 	r.AssertEqual(11, i2)
124 | 	r.AssertEqual("test1", s2)
125 | 	r.AssertNoError()
126 | }
127 | 
128 | func TestWhenWithinWhen(t *testing.T) {
129 | 	r := common.NewMockReporter(t)
130 | 	SetUp(r)
131 | 	m1 := Mock[WhenInterface]()
132 | 	When(m1.RespondWithMock()).ThenAnswer(func(args []any) []any {
133 | 		n := Mock[Nested]()
134 | 		WhenSingle(n.Foo()).ThenReturn(10)
135 | 		return []any{n}
136 | 	})
137 | 	nested := m1.RespondWithMock()
138 | 	result := nested.Foo()
139 | 	r.AssertNoError()
140 | 	r.AssertEqual(10, result)
141 | }
142 | 
143 | func TestSliceReturn(t *testing.T) {
144 | 	r := common.NewMockReporter(t)
145 | 	SetUp(r)
146 | 	m1 := Mock[WhenInterface]()
147 | 	expected := []int{1, 2, 3}
148 | 	When(m1.RespondWithSlice()).ThenReturn(expected)
149 | 	result := m1.RespondWithSlice()
150 | 	r.AssertEqual(expected, result)
151 | 	r.AssertNoError()
152 | }
153 | 


--------------------------------------------------------------------------------
/threadlocal/threadlocal.go:
--------------------------------------------------------------------------------
 1 | package threadlocal
 2 | 
 3 | import (
 4 | 	"sync"
 5 | 
 6 | 	"github.com/petermattis/goid"
 7 | )
 8 | 
 9 | type ThreadLocal[T any] interface {
10 | 	Get() T
11 | 	Set(t T)
12 | 	Clear()
13 | }
14 | 
15 | type impl[T any] struct {
16 | 	data sync.Map
17 | 	init func() T
18 | }
19 | 
20 | func (i *impl[T]) Get() T {
21 | 	id := goid.Get()
22 | 	v, ok := i.data.Load(id)
23 | 	if !ok {
24 | 		nv := i.init()
25 | 		i.data.Store(id, nv)
26 | 		return nv
27 | 	}
28 | 	return v.(T)
29 | }
30 | 
31 | func (i *impl[T]) Set(t T) {
32 | 	id := goid.Get()
33 | 	i.data.Store(id, t)
34 | }
35 | 
36 | func (i *impl[T]) Clear() {
37 | 	id := goid.Get()
38 | 	i.data.Delete(id)
39 | }
40 | 
41 | func NewThreadLocal[T any](initFunc func() T) ThreadLocal[T] {
42 | 	return &impl[T]{
43 | 		data: sync.Map{},
44 | 		init: initFunc,
45 | 	}
46 | }
47 | 
48 | func GoId() int64 {
49 | 	return goid.Get()
50 | }
51 | 


--------------------------------------------------------------------------------