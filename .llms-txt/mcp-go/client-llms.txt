└── client
    ├── client.go
    ├── sse.go
    ├── sse_test.go
    ├── stdio.go
    ├── stdio_test.go
    └── types.go


/client/client.go:
--------------------------------------------------------------------------------
  1 | // Package client provides MCP (Model Control Protocol) client implementations.
  2 | package client
  3 | 
  4 | import (
  5 | 	"context"
  6 | 	"encoding/json"
  7 | 	"fmt"
  8 | 
  9 | 	"github.com/mark3labs/mcp-go/mcp"
 10 | )
 11 | 
 12 | // MCPClient represents an MCP client interface
 13 | type MCPClient interface {
 14 | 	// Initialize sends the initial connection request to the server
 15 | 	Initialize(
 16 | 		ctx context.Context,
 17 | 		request mcp.InitializeRequest,
 18 | 	) (*mcp.InitializeResult, error)
 19 | 
 20 | 	// Ping checks if the server is alive
 21 | 	Ping(ctx context.Context) error
 22 | 
 23 | 	// ListResourcesByPage manually list resources by page.
 24 | 	ListResourcesByPage(
 25 | 		ctx context.Context,
 26 | 		request mcp.ListResourcesRequest,
 27 | 	) (*mcp.ListResourcesResult, error)
 28 | 
 29 | 	// ListResources requests a list of available resources from the server
 30 | 	ListResources(
 31 | 		ctx context.Context,
 32 | 		request mcp.ListResourcesRequest,
 33 | 	) (*mcp.ListResourcesResult, error)
 34 | 
 35 | 	// ListResourceTemplatesByPage manually list resource templates by page.
 36 | 	ListResourceTemplatesByPage(
 37 | 		ctx context.Context,
 38 | 		request mcp.ListResourceTemplatesRequest,
 39 | 	) (*mcp.ListResourceTemplatesResult,
 40 | 		error)
 41 | 
 42 | 	// ListResourceTemplates requests a list of available resource templates from the server
 43 | 	ListResourceTemplates(
 44 | 		ctx context.Context,
 45 | 		request mcp.ListResourceTemplatesRequest,
 46 | 	) (*mcp.ListResourceTemplatesResult,
 47 | 		error)
 48 | 
 49 | 	// ReadResource reads a specific resource from the server
 50 | 	ReadResource(
 51 | 		ctx context.Context,
 52 | 		request mcp.ReadResourceRequest,
 53 | 	) (*mcp.ReadResourceResult, error)
 54 | 
 55 | 	// Subscribe requests notifications for changes to a specific resource
 56 | 	Subscribe(ctx context.Context, request mcp.SubscribeRequest) error
 57 | 
 58 | 	// Unsubscribe cancels notifications for a specific resource
 59 | 	Unsubscribe(ctx context.Context, request mcp.UnsubscribeRequest) error
 60 | 
 61 | 	// ListPromptsByPage manually list prompts by page.
 62 | 	ListPromptsByPage(
 63 | 		ctx context.Context,
 64 | 		request mcp.ListPromptsRequest,
 65 | 	) (*mcp.ListPromptsResult, error)
 66 | 
 67 | 	// ListPrompts requests a list of available prompts from the server
 68 | 	ListPrompts(
 69 | 		ctx context.Context,
 70 | 		request mcp.ListPromptsRequest,
 71 | 	) (*mcp.ListPromptsResult, error)
 72 | 
 73 | 	// GetPrompt retrieves a specific prompt from the server
 74 | 	GetPrompt(
 75 | 		ctx context.Context,
 76 | 		request mcp.GetPromptRequest,
 77 | 	) (*mcp.GetPromptResult, error)
 78 | 
 79 | 	// ListToolsByPage manually list tools by page.
 80 | 	ListToolsByPage(
 81 | 		ctx context.Context,
 82 | 		request mcp.ListToolsRequest,
 83 | 	) (*mcp.ListToolsResult, error)
 84 | 
 85 | 	// ListTools requests a list of available tools from the server
 86 | 	ListTools(
 87 | 		ctx context.Context,
 88 | 		request mcp.ListToolsRequest,
 89 | 	) (*mcp.ListToolsResult, error)
 90 | 
 91 | 	// CallTool invokes a specific tool on the server
 92 | 	CallTool(
 93 | 		ctx context.Context,
 94 | 		request mcp.CallToolRequest,
 95 | 	) (*mcp.CallToolResult, error)
 96 | 
 97 | 	// SetLevel sets the logging level for the server
 98 | 	SetLevel(ctx context.Context, request mcp.SetLevelRequest) error
 99 | 
100 | 	// Complete requests completion options for a given argument
101 | 	Complete(
102 | 		ctx context.Context,
103 | 		request mcp.CompleteRequest,
104 | 	) (*mcp.CompleteResult, error)
105 | 
106 | 	// Close client connection and cleanup resources
107 | 	Close() error
108 | 
109 | 	// OnNotification registers a handler for notifications
110 | 	OnNotification(handler func(notification mcp.JSONRPCNotification))
111 | }
112 | 
113 | type mcpClient interface {
114 | 	MCPClient
115 | 
116 | 	sendRequest(ctx context.Context, method string, params interface{}) (*json.RawMessage, error)
117 | }
118 | 
119 | func listByPage[T any](
120 | 	ctx context.Context,
121 | 	client mcpClient,
122 | 	request mcp.PaginatedRequest,
123 | 	method string,
124 | ) (*T, error) {
125 | 	response, err := client.sendRequest(ctx, method, request.Params)
126 | 	if err != nil {
127 | 		return nil, err
128 | 	}
129 | 	var result T
130 | 	if err := json.Unmarshal(*response, &result); err != nil {
131 | 		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
132 | 	}
133 | 	return &result, nil
134 | }
135 | 


--------------------------------------------------------------------------------
/client/sse.go:
--------------------------------------------------------------------------------
  1 | package client
  2 | 
  3 | import (
  4 | 	"bufio"
  5 | 	"bytes"
  6 | 	"context"
  7 | 	"encoding/json"
  8 | 	"errors"
  9 | 	"fmt"
 10 | 	"io"
 11 | 	"net/http"
 12 | 	"net/url"
 13 | 	"strings"
 14 | 	"sync"
 15 | 	"sync/atomic"
 16 | 	"time"
 17 | 
 18 | 	"github.com/mark3labs/mcp-go/mcp"
 19 | )
 20 | 
 21 | // SSEMCPClient implements the MCPClient interface using Server-Sent Events (SSE).
 22 | // It maintains a persistent HTTP connection to receive server-pushed events
 23 | // while sending requests over regular HTTP POST calls. The client handles
 24 | // automatic reconnection and message routing between requests and responses.
 25 | type SSEMCPClient struct {
 26 | 	baseURL       *url.URL
 27 | 	endpoint      *url.URL
 28 | 	httpClient    *http.Client
 29 | 	requestID     atomic.Int64
 30 | 	responses     map[int64]chan RPCResponse
 31 | 	mu            sync.RWMutex
 32 | 	done          chan struct{}
 33 | 	initialized   bool
 34 | 	notifications []func(mcp.JSONRPCNotification)
 35 | 	notifyMu      sync.RWMutex
 36 | 	endpointChan  chan struct{}
 37 | 	capabilities  mcp.ServerCapabilities
 38 | 	headers       map[string]string
 39 | }
 40 | 
 41 | type ClientOption func(*SSEMCPClient)
 42 | 
 43 | func WithHeaders(headers map[string]string) ClientOption {
 44 | 	return func(sc *SSEMCPClient) {
 45 | 		sc.headers = headers
 46 | 	}
 47 | }
 48 | 
 49 | // NewSSEMCPClient creates a new SSE-based MCP client with the given base URL.
 50 | // Returns an error if the URL is invalid.
 51 | func NewSSEMCPClient(baseURL string, options ...ClientOption) (*SSEMCPClient, error) {
 52 | 	parsedURL, err := url.Parse(baseURL)
 53 | 	if err != nil {
 54 | 		return nil, fmt.Errorf("invalid URL: %w", err)
 55 | 	}
 56 | 
 57 | 	smc := &SSEMCPClient{
 58 | 		baseURL:      parsedURL,
 59 | 		httpClient:   &http.Client{},
 60 | 		responses:    make(map[int64]chan RPCResponse),
 61 | 		done:         make(chan struct{}),
 62 | 		endpointChan: make(chan struct{}),
 63 | 		headers:      make(map[string]string),
 64 | 	}
 65 | 
 66 | 	for _, opt := range options {
 67 | 		opt(smc)
 68 | 	}
 69 | 
 70 | 	return smc, nil
 71 | }
 72 | 
 73 | // Start initiates the SSE connection to the server and waits for the endpoint information.
 74 | // Returns an error if the connection fails or times out waiting for the endpoint.
 75 | func (c *SSEMCPClient) Start(ctx context.Context) error {
 76 | 
 77 | 	req, err := http.NewRequestWithContext(ctx, "GET", c.baseURL.String(), nil)
 78 | 
 79 | 	if err != nil {
 80 | 
 81 | 		return fmt.Errorf("failed to create request: %w", err)
 82 | 
 83 | 	}
 84 | 
 85 | 	req.Header.Set("Accept", "text/event-stream")
 86 | 	req.Header.Set("Cache-Control", "no-cache")
 87 | 	req.Header.Set("Connection", "keep-alive")
 88 | 	for k, v := range c.headers {
 89 | 		req.Header.Set(k, v)
 90 | 	}
 91 | 
 92 | 	resp, err := c.httpClient.Do(req)
 93 | 	if err != nil {
 94 | 		return fmt.Errorf("failed to connect to SSE stream: %w", err)
 95 | 	}
 96 | 
 97 | 	if resp.StatusCode != http.StatusOK {
 98 | 		resp.Body.Close()
 99 | 		return fmt.Errorf("unexpected status code: %d", resp.StatusCode)
100 | 	}
101 | 
102 | 	go c.readSSE(resp.Body)
103 | 
104 | 	// Wait for the endpoint to be received
105 | 
106 | 	select {
107 | 	case <-c.endpointChan:
108 | 		// Endpoint received, proceed
109 | 	case <-ctx.Done():
110 | 		return fmt.Errorf("context cancelled while waiting for endpoint")
111 | 	case <-time.After(30 * time.Second): // Add a timeout
112 | 		return fmt.Errorf("timeout waiting for endpoint")
113 | 	}
114 | 
115 | 	return nil
116 | }
117 | 
118 | // readSSE continuously reads the SSE stream and processes events.
119 | // It runs until the connection is closed or an error occurs.
120 | func (c *SSEMCPClient) readSSE(reader io.ReadCloser) {
121 | 	defer reader.Close()
122 | 
123 | 	br := bufio.NewReader(reader)
124 | 	var event, data string
125 | 
126 | 	for {
127 | 		select {
128 | 		case <-c.done:
129 | 			return
130 | 		default:
131 | 			line, err := br.ReadString('\n')
132 | 			if err != nil {
133 | 				if err == io.EOF {
134 | 					// Process any pending event before exit
135 | 					if event != "" && data != "" {
136 | 						c.handleSSEEvent(event, data)
137 | 					}
138 | 					break
139 | 				}
140 | 				select {
141 | 				case <-c.done:
142 | 					return
143 | 				default:
144 | 					fmt.Printf("SSE stream error: %v\n", err)
145 | 					return
146 | 				}
147 | 			}
148 | 
149 | 			// Remove only newline markers
150 | 			line = strings.TrimRight(line, "\r\n")
151 | 			if line == "" {
152 | 				// Empty line means end of event
153 | 				if event != "" && data != "" {
154 | 					c.handleSSEEvent(event, data)
155 | 					event = ""
156 | 					data = ""
157 | 				}
158 | 				continue
159 | 			}
160 | 
161 | 			if strings.HasPrefix(line, "event:") {
162 | 				event = strings.TrimSpace(strings.TrimPrefix(line, "event:"))
163 | 			} else if strings.HasPrefix(line, "data:") {
164 | 				data = strings.TrimSpace(strings.TrimPrefix(line, "data:"))
165 | 			}
166 | 		}
167 | 	}
168 | }
169 | 
170 | // handleSSEEvent processes SSE events based on their type.
171 | // Handles 'endpoint' events for connection setup and 'message' events for JSON-RPC communication.
172 | func (c *SSEMCPClient) handleSSEEvent(event, data string) {
173 | 	switch event {
174 | 	case "endpoint":
175 | 		endpoint, err := c.baseURL.Parse(data)
176 | 		if err != nil {
177 | 			fmt.Printf("Error parsing endpoint URL: %v\n", err)
178 | 			return
179 | 		}
180 | 		if endpoint.Host != c.baseURL.Host {
181 | 			fmt.Printf("Endpoint origin does not match connection origin\n")
182 | 			return
183 | 		}
184 | 		c.endpoint = endpoint
185 | 		close(c.endpointChan)
186 | 
187 | 	case "message":
188 | 		var baseMessage struct {
189 | 			JSONRPC string          `json:"jsonrpc"`
190 | 			ID      *int64          `json:"id,omitempty"`
191 | 			Method  string          `json:"method,omitempty"`
192 | 			Result  json.RawMessage `json:"result,omitempty"`
193 | 			Error   *struct {
194 | 				Code    int    `json:"code"`
195 | 				Message string `json:"message"`
196 | 			} `json:"error,omitempty"`
197 | 		}
198 | 
199 | 		if err := json.Unmarshal([]byte(data), &baseMessage); err != nil {
200 | 			fmt.Printf("Error unmarshaling message: %v\n", err)
201 | 			return
202 | 		}
203 | 
204 | 		// Handle notification
205 | 		if baseMessage.ID == nil {
206 | 			var notification mcp.JSONRPCNotification
207 | 			if err := json.Unmarshal([]byte(data), &notification); err != nil {
208 | 				return
209 | 			}
210 | 			c.notifyMu.RLock()
211 | 			for _, handler := range c.notifications {
212 | 				handler(notification)
213 | 			}
214 | 			c.notifyMu.RUnlock()
215 | 			return
216 | 		}
217 | 
218 | 		c.mu.RLock()
219 | 		ch, ok := c.responses[*baseMessage.ID]
220 | 		c.mu.RUnlock()
221 | 
222 | 		if ok {
223 | 			if baseMessage.Error != nil {
224 | 				ch <- RPCResponse{
225 | 					Error: &baseMessage.Error.Message,
226 | 				}
227 | 			} else {
228 | 				ch <- RPCResponse{
229 | 					Response: &baseMessage.Result,
230 | 				}
231 | 			}
232 | 			c.mu.Lock()
233 | 			delete(c.responses, *baseMessage.ID)
234 | 			c.mu.Unlock()
235 | 		}
236 | 	}
237 | }
238 | 
239 | // OnNotification registers a handler function to be called when notifications are received.
240 | // Multiple handlers can be registered and will be called in the order they were added.
241 | func (c *SSEMCPClient) OnNotification(
242 | 	handler func(notification mcp.JSONRPCNotification),
243 | ) {
244 | 	c.notifyMu.Lock()
245 | 	defer c.notifyMu.Unlock()
246 | 	c.notifications = append(c.notifications, handler)
247 | }
248 | 
249 | // sendRequest sends a JSON-RPC request to the server and waits for a response.
250 | // Returns the raw JSON response message or an error if the request fails.
251 | func (c *SSEMCPClient) sendRequest(
252 | 	ctx context.Context,
253 | 	method string,
254 | 	params interface{},
255 | ) (*json.RawMessage, error) {
256 | 	if !c.initialized && method != "initialize" {
257 | 		return nil, fmt.Errorf("client not initialized")
258 | 	}
259 | 
260 | 	if c.endpoint == nil {
261 | 		return nil, fmt.Errorf("endpoint not received")
262 | 	}
263 | 
264 | 	id := c.requestID.Add(1)
265 | 
266 | 	request := mcp.JSONRPCRequest{
267 | 		JSONRPC: mcp.JSONRPC_VERSION,
268 | 		ID:      id,
269 | 		Request: mcp.Request{
270 | 			Method: method,
271 | 		},
272 | 		Params: params,
273 | 	}
274 | 
275 | 	requestBytes, err := json.Marshal(request)
276 | 	if err != nil {
277 | 		return nil, fmt.Errorf("failed to marshal request: %w", err)
278 | 	}
279 | 
280 | 	responseChan := make(chan RPCResponse, 1)
281 | 	c.mu.Lock()
282 | 	c.responses[id] = responseChan
283 | 	c.mu.Unlock()
284 | 
285 | 	req, err := http.NewRequestWithContext(
286 | 		ctx,
287 | 		"POST",
288 | 		c.endpoint.String(),
289 | 		bytes.NewReader(requestBytes),
290 | 	)
291 | 	if err != nil {
292 | 		return nil, fmt.Errorf("failed to create request: %w", err)
293 | 	}
294 | 
295 | 	req.Header.Set("Content-Type", "application/json")
296 | 	// set custom http headers
297 | 	for k, v := range c.headers {
298 | 		req.Header.Set(k, v)
299 | 	}
300 | 
301 | 	resp, err := c.httpClient.Do(req)
302 | 	if err != nil {
303 | 		return nil, fmt.Errorf("failed to send request: %w", err)
304 | 	}
305 | 	defer resp.Body.Close()
306 | 
307 | 	if resp.StatusCode != http.StatusOK &&
308 | 		resp.StatusCode != http.StatusAccepted {
309 | 		body, _ := io.ReadAll(resp.Body)
310 | 		return nil, fmt.Errorf(
311 | 			"request failed with status %d: %s",
312 | 			resp.StatusCode,
313 | 			body,
314 | 		)
315 | 	}
316 | 
317 | 	select {
318 | 	case <-ctx.Done():
319 | 		c.mu.Lock()
320 | 		delete(c.responses, id)
321 | 		c.mu.Unlock()
322 | 		return nil, ctx.Err()
323 | 	case response := <-responseChan:
324 | 		if response.Error != nil {
325 | 			return nil, errors.New(*response.Error)
326 | 		}
327 | 		return response.Response, nil
328 | 	}
329 | }
330 | 
331 | func (c *SSEMCPClient) Initialize(
332 | 	ctx context.Context,
333 | 	request mcp.InitializeRequest,
334 | ) (*mcp.InitializeResult, error) {
335 | 	// Ensure we send a params object with all required fields
336 | 	params := struct {
337 | 		ProtocolVersion string                 `json:"protocolVersion"`
338 | 		ClientInfo      mcp.Implementation     `json:"clientInfo"`
339 | 		Capabilities    mcp.ClientCapabilities `json:"capabilities"`
340 | 	}{
341 | 		ProtocolVersion: request.Params.ProtocolVersion,
342 | 		ClientInfo:      request.Params.ClientInfo,
343 | 		Capabilities:    request.Params.Capabilities, // Will be empty struct if not set
344 | 	}
345 | 
346 | 	response, err := c.sendRequest(ctx, "initialize", params)
347 | 	if err != nil {
348 | 		return nil, err
349 | 	}
350 | 
351 | 	var result mcp.InitializeResult
352 | 	if err := json.Unmarshal(*response, &result); err != nil {
353 | 		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
354 | 	}
355 | 
356 | 	// Store capabilities
357 | 	c.capabilities = result.Capabilities
358 | 
359 | 	// Send initialized notification
360 | 	notification := mcp.JSONRPCNotification{
361 | 		JSONRPC: mcp.JSONRPC_VERSION,
362 | 		Notification: mcp.Notification{
363 | 			Method: "notifications/initialized",
364 | 		},
365 | 	}
366 | 
367 | 	notificationBytes, err := json.Marshal(notification)
368 | 	if err != nil {
369 | 		return nil, fmt.Errorf(
370 | 			"failed to marshal initialized notification: %w",
371 | 			err,
372 | 		)
373 | 	}
374 | 
375 | 	req, err := http.NewRequestWithContext(
376 | 		ctx,
377 | 		"POST",
378 | 		c.endpoint.String(),
379 | 		bytes.NewReader(notificationBytes),
380 | 	)
381 | 	if err != nil {
382 | 		return nil, fmt.Errorf("failed to create notification request: %w", err)
383 | 	}
384 | 
385 | 	req.Header.Set("Content-Type", "application/json")
386 | 
387 | 	resp, err := c.httpClient.Do(req)
388 | 	if err != nil {
389 | 		return nil, fmt.Errorf(
390 | 			"failed to send initialized notification: %w",
391 | 			err,
392 | 		)
393 | 	}
394 | 	defer resp.Body.Close()
395 | 
396 | 	c.initialized = true
397 | 	return &result, nil
398 | }
399 | 
400 | func (c *SSEMCPClient) Ping(ctx context.Context) error {
401 | 	_, err := c.sendRequest(ctx, "ping", nil)
402 | 	return err
403 | }
404 | 
405 | // ListResourcesByPage manually list resources by page.
406 | func (c *SSEMCPClient) ListResourcesByPage(
407 | 	ctx context.Context,
408 | 	request mcp.ListResourcesRequest,
409 | ) (*mcp.ListResourcesResult, error) {
410 | 	result, err := listByPage[mcp.ListResourcesResult](ctx, c, request.PaginatedRequest, "resources/list")
411 | 	if err != nil {
412 | 		return nil, err
413 | 	}
414 | 	return result, nil
415 | }
416 | 
417 | func (c *SSEMCPClient) ListResources(
418 | 	ctx context.Context,
419 | 	request mcp.ListResourcesRequest,
420 | ) (*mcp.ListResourcesResult, error) {
421 | 	result, err := c.ListResourcesByPage(ctx, request)
422 | 	if err != nil {
423 | 		return nil, err
424 | 	}
425 | 	for result.NextCursor != "" {
426 | 		select {
427 | 		case <-ctx.Done():
428 | 			return nil, ctx.Err()
429 | 		default:
430 | 			request.Params.Cursor = result.NextCursor
431 | 			newPageRes, err := c.ListResourcesByPage(ctx, request)
432 | 			if err != nil {
433 | 				return nil, err
434 | 			}
435 | 			result.Resources = append(result.Resources, newPageRes.Resources...)
436 | 			result.NextCursor = newPageRes.NextCursor
437 | 		}
438 | 	}
439 | 	return result, nil
440 | }
441 | 
442 | func (c *SSEMCPClient) ListResourceTemplatesByPage(
443 | 	ctx context.Context,
444 | 	request mcp.ListResourceTemplatesRequest,
445 | ) (*mcp.ListResourceTemplatesResult, error) {
446 | 	result, err := listByPage[mcp.ListResourceTemplatesResult](ctx, c, request.PaginatedRequest, "resources/templates/list")
447 | 	if err != nil {
448 | 		return nil, err
449 | 	}
450 | 	return result, nil
451 | }
452 | 
453 | func (c *SSEMCPClient) ListResourceTemplates(
454 | 	ctx context.Context,
455 | 	request mcp.ListResourceTemplatesRequest,
456 | ) (*mcp.ListResourceTemplatesResult, error) {
457 | 	result, err := c.ListResourceTemplatesByPage(ctx, request)
458 | 	if err != nil {
459 | 		return nil, err
460 | 	}
461 | 	for result.NextCursor != "" {
462 | 		select {
463 | 		case <-ctx.Done():
464 | 			return nil, ctx.Err()
465 | 		default:
466 | 			request.Params.Cursor = result.NextCursor
467 | 			newPageRes, err := c.ListResourceTemplatesByPage(ctx, request)
468 | 			if err != nil {
469 | 				return nil, err
470 | 			}
471 | 			result.ResourceTemplates = append(result.ResourceTemplates, newPageRes.ResourceTemplates...)
472 | 			result.NextCursor = newPageRes.NextCursor
473 | 		}
474 | 	}
475 | 	return result, nil
476 | }
477 | 
478 | func (c *SSEMCPClient) ReadResource(
479 | 	ctx context.Context,
480 | 	request mcp.ReadResourceRequest,
481 | ) (*mcp.ReadResourceResult, error) {
482 | 	response, err := c.sendRequest(ctx, "resources/read", request.Params)
483 | 	if err != nil {
484 | 		return nil, err
485 | 	}
486 | 
487 | 	return mcp.ParseReadResourceResult(response)
488 | }
489 | 
490 | func (c *SSEMCPClient) Subscribe(
491 | 	ctx context.Context,
492 | 	request mcp.SubscribeRequest,
493 | ) error {
494 | 	_, err := c.sendRequest(ctx, "resources/subscribe", request.Params)
495 | 	return err
496 | }
497 | 
498 | func (c *SSEMCPClient) Unsubscribe(
499 | 	ctx context.Context,
500 | 	request mcp.UnsubscribeRequest,
501 | ) error {
502 | 	_, err := c.sendRequest(ctx, "resources/unsubscribe", request.Params)
503 | 	return err
504 | }
505 | 
506 | func (c *SSEMCPClient) ListPromptsByPage(
507 | 	ctx context.Context,
508 | 	request mcp.ListPromptsRequest,
509 | ) (*mcp.ListPromptsResult, error) {
510 | 	result, err := listByPage[mcp.ListPromptsResult](ctx, c, request.PaginatedRequest, "prompts/list")
511 | 	if err != nil {
512 | 		return nil, err
513 | 	}
514 | 	return result, nil
515 | }
516 | 
517 | func (c *SSEMCPClient) ListPrompts(
518 | 	ctx context.Context,
519 | 	request mcp.ListPromptsRequest,
520 | ) (*mcp.ListPromptsResult, error) {
521 | 	result, err := c.ListPromptsByPage(ctx, request)
522 | 	if err != nil {
523 | 		return nil, err
524 | 	}
525 | 	for result.NextCursor != "" {
526 | 		select {
527 | 		case <-ctx.Done():
528 | 			return nil, ctx.Err()
529 | 		default:
530 | 			request.Params.Cursor = result.NextCursor
531 | 			newPageRes, err := c.ListPromptsByPage(ctx, request)
532 | 			if err != nil {
533 | 				return nil, err
534 | 			}
535 | 			result.Prompts = append(result.Prompts, newPageRes.Prompts...)
536 | 			result.NextCursor = newPageRes.NextCursor
537 | 		}
538 | 	}
539 | 	return result, nil
540 | }
541 | 
542 | func (c *SSEMCPClient) GetPrompt(
543 | 	ctx context.Context,
544 | 	request mcp.GetPromptRequest,
545 | ) (*mcp.GetPromptResult, error) {
546 | 	response, err := c.sendRequest(ctx, "prompts/get", request.Params)
547 | 	if err != nil {
548 | 		return nil, err
549 | 	}
550 | 
551 | 	return mcp.ParseGetPromptResult(response)
552 | }
553 | 
554 | func (c *SSEMCPClient) ListToolsByPage(
555 | 	ctx context.Context,
556 | 	request mcp.ListToolsRequest,
557 | ) (*mcp.ListToolsResult, error) {
558 | 	result, err := listByPage[mcp.ListToolsResult](ctx, c, request.PaginatedRequest, "tools/list")
559 | 	if err != nil {
560 | 		return nil, err
561 | 	}
562 | 	return result, nil
563 | }
564 | 
565 | func (c *SSEMCPClient) ListTools(
566 | 	ctx context.Context,
567 | 	request mcp.ListToolsRequest,
568 | ) (*mcp.ListToolsResult, error) {
569 | 	result, err := c.ListToolsByPage(ctx, request)
570 | 	if err != nil {
571 | 		return nil, err
572 | 	}
573 | 	for result.NextCursor != "" {
574 | 		select {
575 | 		case <-ctx.Done():
576 | 			return nil, ctx.Err()
577 | 		default:
578 | 			request.Params.Cursor = result.NextCursor
579 | 			newPageRes, err := c.ListToolsByPage(ctx, request)
580 | 			if err != nil {
581 | 				return nil, err
582 | 			}
583 | 			result.Tools = append(result.Tools, newPageRes.Tools...)
584 | 			result.NextCursor = newPageRes.NextCursor
585 | 		}
586 | 	}
587 | 	return result, nil
588 | }
589 | 
590 | func (c *SSEMCPClient) CallTool(
591 | 	ctx context.Context,
592 | 	request mcp.CallToolRequest,
593 | ) (*mcp.CallToolResult, error) {
594 | 	response, err := c.sendRequest(ctx, "tools/call", request.Params)
595 | 	if err != nil {
596 | 		return nil, err
597 | 	}
598 | 
599 | 	return mcp.ParseCallToolResult(response)
600 | }
601 | 
602 | func (c *SSEMCPClient) SetLevel(
603 | 	ctx context.Context,
604 | 	request mcp.SetLevelRequest,
605 | ) error {
606 | 	_, err := c.sendRequest(ctx, "logging/setLevel", request.Params)
607 | 	return err
608 | }
609 | 
610 | func (c *SSEMCPClient) Complete(
611 | 	ctx context.Context,
612 | 	request mcp.CompleteRequest,
613 | ) (*mcp.CompleteResult, error) {
614 | 	response, err := c.sendRequest(ctx, "completion/complete", request.Params)
615 | 	if err != nil {
616 | 		return nil, err
617 | 	}
618 | 
619 | 	var result mcp.CompleteResult
620 | 	if err := json.Unmarshal(*response, &result); err != nil {
621 | 		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
622 | 	}
623 | 
624 | 	return &result, nil
625 | }
626 | 
627 | // Helper methods
628 | 
629 | // GetEndpoint returns the current endpoint URL for the SSE connection.
630 | func (c *SSEMCPClient) GetEndpoint() *url.URL {
631 | 	return c.endpoint
632 | }
633 | 
634 | // Close shuts down the SSE client connection and cleans up any pending responses.
635 | // Returns an error if the shutdown process fails.
636 | func (c *SSEMCPClient) Close() error {
637 | 	select {
638 | 	case <-c.done:
639 | 		return nil // Already closed
640 | 	default:
641 | 		close(c.done)
642 | 	}
643 | 
644 | 	// Clean up any pending responses
645 | 	c.mu.Lock()
646 | 	for _, ch := range c.responses {
647 | 		close(ch)
648 | 	}
649 | 	c.responses = make(map[int64]chan RPCResponse)
650 | 	c.mu.Unlock()
651 | 
652 | 	return nil
653 | }
654 | 


--------------------------------------------------------------------------------
/client/sse_test.go:
--------------------------------------------------------------------------------
  1 | package client
  2 | 
  3 | import (
  4 | 	"context"
  5 | 	"testing"
  6 | 	"time"
  7 | 
  8 | 	"github.com/mark3labs/mcp-go/mcp"
  9 | 	"github.com/mark3labs/mcp-go/server"
 10 | )
 11 | 
 12 | func TestSSEMCPClient(t *testing.T) {
 13 | 	// Create MCP server with capabilities
 14 | 	mcpServer := server.NewMCPServer(
 15 | 		"test-server",
 16 | 		"1.0.0",
 17 | 		server.WithResourceCapabilities(true, true),
 18 | 		server.WithPromptCapabilities(true),
 19 | 		server.WithToolCapabilities(true),
 20 | 	)
 21 | 
 22 | 	// Add a test tool
 23 | 	mcpServer.AddTool(mcp.NewTool(
 24 | 		"test-tool",
 25 | 		mcp.WithDescription("Test tool"),
 26 | 		mcp.WithString("parameter-1", mcp.Description("A string tool parameter")),
 27 | 	), func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
 28 | 		return &mcp.CallToolResult{
 29 | 			Content: []mcp.Content{
 30 | 				mcp.TextContent{
 31 | 					Type: "text",
 32 | 					Text: "Input parameter: " + request.Params.Arguments["parameter-1"].(string),
 33 | 				},
 34 | 			},
 35 | 		}, nil
 36 | 	})
 37 | 
 38 | 	// Initialize
 39 | 	testServer := server.NewTestServer(mcpServer)
 40 | 	defer testServer.Close()
 41 | 
 42 | 	t.Run("Can create client", func(t *testing.T) {
 43 | 		client, err := NewSSEMCPClient(testServer.URL + "/sse")
 44 | 		if err != nil {
 45 | 			t.Fatalf("Failed to create client: %v", err)
 46 | 		}
 47 | 		defer client.Close()
 48 | 
 49 | 		if client.baseURL == nil {
 50 | 			t.Error("Base URL should not be nil")
 51 | 		}
 52 | 	})
 53 | 
 54 | 	t.Run("Can initialize and make requests", func(t *testing.T) {
 55 | 		client, err := NewSSEMCPClient(testServer.URL + "/sse")
 56 | 		if err != nil {
 57 | 			t.Fatalf("Failed to create client: %v", err)
 58 | 		}
 59 | 		defer client.Close()
 60 | 
 61 | 		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
 62 | 		defer cancel()
 63 | 
 64 | 		// Start the client
 65 | 		if err := client.Start(ctx); err != nil {
 66 | 			t.Fatalf("Failed to start client: %v", err)
 67 | 		}
 68 | 
 69 | 		// Initialize
 70 | 		initRequest := mcp.InitializeRequest{}
 71 | 		initRequest.Params.ProtocolVersion = mcp.LATEST_PROTOCOL_VERSION
 72 | 		initRequest.Params.ClientInfo = mcp.Implementation{
 73 | 			Name:    "test-client",
 74 | 			Version: "1.0.0",
 75 | 		}
 76 | 
 77 | 		result, err := client.Initialize(ctx, initRequest)
 78 | 		if err != nil {
 79 | 			t.Fatalf("Failed to initialize: %v", err)
 80 | 		}
 81 | 
 82 | 		if result.ServerInfo.Name != "test-server" {
 83 | 			t.Errorf(
 84 | 				"Expected server name 'test-server', got '%s'",
 85 | 				result.ServerInfo.Name,
 86 | 			)
 87 | 		}
 88 | 
 89 | 		// Test Ping
 90 | 		if err := client.Ping(ctx); err != nil {
 91 | 			t.Errorf("Ping failed: %v", err)
 92 | 		}
 93 | 
 94 | 		// Test ListTools
 95 | 		toolsRequest := mcp.ListToolsRequest{}
 96 | 		_, err = client.ListTools(ctx, toolsRequest)
 97 | 		if err != nil {
 98 | 			t.Errorf("ListTools failed: %v", err)
 99 | 		}
100 | 	})
101 | 
102 | 	// t.Run("Can handle notifications", func(t *testing.T) {
103 | 	// 	client, err := NewSSEMCPClient(testServer.URL + "/sse")
104 | 	// 	if err != nil {
105 | 	// 		t.Fatalf("Failed to create client: %v", err)
106 | 	// 	}
107 | 	// 	defer client.Close()
108 | 
109 | 	// 	notificationReceived := make(chan mcp.JSONRPCNotification, 1)
110 | 	// 	client.OnNotification(func(notification mcp.JSONRPCNotification) {
111 | 	// 		notificationReceived <- notification
112 | 	// 	})
113 | 
114 | 	// 	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
115 | 	// 	defer cancel()
116 | 
117 | 	// 	if err := client.Start(ctx); err != nil {
118 | 	// 		t.Fatalf("Failed to start client: %v", err)
119 | 	// 	}
120 | 
121 | 	// 	// Initialize first
122 | 	// 	initRequest := mcp.InitializeRequest{}
123 | 	// 	initRequest.Params.ProtocolVersion = mcp.LATEST_PROTOCOL_VERSION
124 | 	// 	initRequest.Params.ClientInfo = mcp.Implementation{
125 | 	// 		Name:    "test-client",
126 | 	// 		Version: "1.0.0",
127 | 	// 	}
128 | 
129 | 	// 	_, err = client.Initialize(ctx, initRequest)
130 | 	// 	if err != nil {
131 | 	// 		t.Fatalf("Failed to initialize: %v", err)
132 | 	// 	}
133 | 
134 | 	// 	// Subscribe to a resource to test notifications
135 | 	// 	subRequest := mcp.SubscribeRequest{}
136 | 	// 	subRequest.Params.URI = "test://resource"
137 | 	// 	if err := client.Subscribe(ctx, subRequest); err != nil {
138 | 	// 		t.Fatalf("Failed to subscribe: %v", err)
139 | 	// 	}
140 | 
141 | 	// 	select {
142 | 	// 	case <-notificationReceived:
143 | 	// 		// Success
144 | 	// 	case <-time.After(time.Second):
145 | 	// 		t.Error("Timeout waiting for notification")
146 | 	// 	}
147 | 	// })
148 | 
149 | 	t.Run("Handles errors properly", func(t *testing.T) {
150 | 		client, err := NewSSEMCPClient(testServer.URL + "/sse")
151 | 		if err != nil {
152 | 			t.Fatalf("Failed to create client: %v", err)
153 | 		}
154 | 		defer client.Close()
155 | 
156 | 		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
157 | 		defer cancel()
158 | 
159 | 		if err := client.Start(ctx); err != nil {
160 | 			t.Fatalf("Failed to start client: %v", err)
161 | 		}
162 | 
163 | 		// Try to make a request without initializing
164 | 		toolsRequest := mcp.ListToolsRequest{}
165 | 		_, err = client.ListTools(ctx, toolsRequest)
166 | 		if err == nil {
167 | 			t.Error("Expected error when making request before initialization")
168 | 		}
169 | 	})
170 | 
171 | 	// t.Run("Handles context cancellation", func(t *testing.T) {
172 | 	// 	client, err := NewSSEMCPClient(testServer.URL + "/sse")
173 | 	// 	if err != nil {
174 | 	// 		t.Fatalf("Failed to create client: %v", err)
175 | 	// 	}
176 | 	// 	defer client.Close()
177 | 
178 | 	// 	if err := client.Start(context.Background()); err != nil {
179 | 	// 		t.Fatalf("Failed to start client: %v", err)
180 | 	// 	}
181 | 
182 | 	// 	ctx, cancel := context.WithCancel(context.Background())
183 | 	// 	cancel() // Cancel immediately
184 | 
185 | 	// 	toolsRequest := mcp.ListToolsRequest{}
186 | 	// 	_, err = client.ListTools(ctx, toolsRequest)
187 | 	// 	if err == nil {
188 | 	// 		t.Error("Expected error when context is cancelled")
189 | 	// 	}
190 | 	// })
191 | 
192 | 	t.Run("CallTool", func(t *testing.T) {
193 | 		client, err := NewSSEMCPClient(testServer.URL + "/sse")
194 | 		if err != nil {
195 | 			t.Fatalf("Failed to create client: %v", err)
196 | 		}
197 | 		defer client.Close()
198 | 
199 | 		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
200 | 		defer cancel()
201 | 
202 | 		if err := client.Start(ctx); err != nil {
203 | 			t.Fatalf("Failed to start client: %v", err)
204 | 		}
205 | 
206 | 		// Initialize
207 | 		initRequest := mcp.InitializeRequest{}
208 | 		initRequest.Params.ProtocolVersion = mcp.LATEST_PROTOCOL_VERSION
209 | 		initRequest.Params.ClientInfo = mcp.Implementation{
210 | 			Name:    "test-client",
211 | 			Version: "1.0.0",
212 | 		}
213 | 
214 | 		_, err = client.Initialize(ctx, initRequest)
215 | 		if err != nil {
216 | 			t.Fatalf("Failed to initialize: %v", err)
217 | 		}
218 | 
219 | 		request := mcp.CallToolRequest{}
220 | 		request.Params.Name = "test-tool"
221 | 		request.Params.Arguments = map[string]interface{}{
222 | 			"parameter-1": "value1",
223 | 		}
224 | 
225 | 		result, err := client.CallTool(ctx, request)
226 | 		if err != nil {
227 | 			t.Fatalf("CallTool failed: %v", err)
228 | 		}
229 | 
230 | 		if len(result.Content) != 1 {
231 | 			t.Errorf("Expected 1 content item, got %d", len(result.Content))
232 | 		}
233 | 	})
234 | }
235 | 


--------------------------------------------------------------------------------
/client/stdio.go:
--------------------------------------------------------------------------------
  1 | package client
  2 | 
  3 | import (
  4 | 	"bufio"
  5 | 	"context"
  6 | 	"encoding/json"
  7 | 	"errors"
  8 | 	"fmt"
  9 | 	"io"
 10 | 	"os"
 11 | 	"os/exec"
 12 | 	"sync"
 13 | 	"sync/atomic"
 14 | 
 15 | 	"github.com/mark3labs/mcp-go/mcp"
 16 | )
 17 | 
 18 | // StdioMCPClient implements the MCPClient interface using stdio communication.
 19 | // It launches a subprocess and communicates with it via standard input/output streams
 20 | // using JSON-RPC messages. The client handles message routing between requests and
 21 | // responses, and supports asynchronous notifications.
 22 | type StdioMCPClient struct {
 23 | 	cmd           *exec.Cmd
 24 | 	stdin         io.WriteCloser
 25 | 	stdout        *bufio.Reader
 26 | 	stderr        io.ReadCloser
 27 | 	requestID     atomic.Int64
 28 | 	responses     map[int64]chan RPCResponse
 29 | 	mu            sync.RWMutex
 30 | 	done          chan struct{}
 31 | 	initialized   bool
 32 | 	notifications []func(mcp.JSONRPCNotification)
 33 | 	notifyMu      sync.RWMutex
 34 | 	capabilities  mcp.ServerCapabilities
 35 | }
 36 | 
 37 | // NewStdioMCPClient creates a new stdio-based MCP client that communicates with a subprocess.
 38 | // It launches the specified command with given arguments and sets up stdin/stdout pipes for communication.
 39 | // Returns an error if the subprocess cannot be started or the pipes cannot be created.
 40 | func NewStdioMCPClient(
 41 | 	command string,
 42 | 	env []string,
 43 | 	args ...string,
 44 | ) (*StdioMCPClient, error) {
 45 | 	cmd := exec.Command(command, args...)
 46 | 
 47 | 	mergedEnv := os.Environ()
 48 | 	mergedEnv = append(mergedEnv, env...)
 49 | 
 50 | 	cmd.Env = mergedEnv
 51 | 
 52 | 	stdin, err := cmd.StdinPipe()
 53 | 	if err != nil {
 54 | 		return nil, fmt.Errorf("failed to create stdin pipe: %w", err)
 55 | 	}
 56 | 
 57 | 	stdout, err := cmd.StdoutPipe()
 58 | 	if err != nil {
 59 | 		return nil, fmt.Errorf("failed to create stdout pipe: %w", err)
 60 | 	}
 61 | 
 62 | 	stderr, err := cmd.StderrPipe()
 63 | 	if err != nil {
 64 | 		return nil, fmt.Errorf("failed to create stderr pipe: %w", err)
 65 | 	}
 66 | 
 67 | 	client := &StdioMCPClient{
 68 | 		cmd:       cmd,
 69 | 		stdin:     stdin,
 70 | 		stderr:    stderr,
 71 | 		stdout:    bufio.NewReader(stdout),
 72 | 		responses: make(map[int64]chan RPCResponse),
 73 | 		done:      make(chan struct{}),
 74 | 	}
 75 | 
 76 | 	if err := cmd.Start(); err != nil {
 77 | 		return nil, fmt.Errorf("failed to start command: %w", err)
 78 | 	}
 79 | 
 80 | 	// Start reading responses in a goroutine and wait for it to be ready
 81 | 	ready := make(chan struct{})
 82 | 	go func() {
 83 | 		close(ready)
 84 | 		client.readResponses()
 85 | 	}()
 86 | 	<-ready
 87 | 
 88 | 	return client, nil
 89 | }
 90 | 
 91 | // Close shuts down the stdio client, closing the stdin pipe and waiting for the subprocess to exit.
 92 | // Returns an error if there are issues closing stdin or waiting for the subprocess to terminate.
 93 | func (c *StdioMCPClient) Close() error {
 94 | 	close(c.done)
 95 | 	if err := c.stdin.Close(); err != nil {
 96 | 		return fmt.Errorf("failed to close stdin: %w", err)
 97 | 	}
 98 | 	if err := c.stderr.Close(); err != nil {
 99 | 		return fmt.Errorf("failed to close stderr: %w", err)
100 | 	}
101 | 	return c.cmd.Wait()
102 | }
103 | 
104 | // Stderr returns a reader for the stderr output of the subprocess.
105 | // This can be used to capture error messages or logs from the subprocess.
106 | func (c *StdioMCPClient) Stderr() io.Reader {
107 | 	return c.stderr
108 | }
109 | 
110 | // OnNotification registers a handler function to be called when notifications are received.
111 | // Multiple handlers can be registered and will be called in the order they were added.
112 | func (c *StdioMCPClient) OnNotification(
113 | 	handler func(notification mcp.JSONRPCNotification),
114 | ) {
115 | 	c.notifyMu.Lock()
116 | 	defer c.notifyMu.Unlock()
117 | 	c.notifications = append(c.notifications, handler)
118 | }
119 | 
120 | // readResponses continuously reads and processes responses from the server's stdout.
121 | // It handles both responses to requests and notifications, routing them appropriately.
122 | // Runs until the done channel is closed or an error occurs reading from stdout.
123 | func (c *StdioMCPClient) readResponses() {
124 | 	for {
125 | 		select {
126 | 		case <-c.done:
127 | 			return
128 | 		default:
129 | 			line, err := c.stdout.ReadString('\n')
130 | 			if err != nil {
131 | 				if err != io.EOF {
132 | 					fmt.Printf("Error reading response: %v\n", err)
133 | 				}
134 | 				return
135 | 			}
136 | 
137 | 			var baseMessage struct {
138 | 				JSONRPC string          `json:"jsonrpc"`
139 | 				ID      *int64          `json:"id,omitempty"`
140 | 				Method  string          `json:"method,omitempty"`
141 | 				Result  json.RawMessage `json:"result,omitempty"`
142 | 				Error   *struct {
143 | 					Code    int    `json:"code"`
144 | 					Message string `json:"message"`
145 | 				} `json:"error,omitempty"`
146 | 			}
147 | 
148 | 			if err := json.Unmarshal([]byte(line), &baseMessage); err != nil {
149 | 				continue
150 | 			}
151 | 
152 | 			// Handle notification
153 | 			if baseMessage.ID == nil {
154 | 				var notification mcp.JSONRPCNotification
155 | 				if err := json.Unmarshal([]byte(line), &notification); err != nil {
156 | 					continue
157 | 				}
158 | 				c.notifyMu.RLock()
159 | 				for _, handler := range c.notifications {
160 | 					handler(notification)
161 | 				}
162 | 				c.notifyMu.RUnlock()
163 | 				continue
164 | 			}
165 | 
166 | 			c.mu.RLock()
167 | 			ch, ok := c.responses[*baseMessage.ID]
168 | 			c.mu.RUnlock()
169 | 
170 | 			if ok {
171 | 				if baseMessage.Error != nil {
172 | 					ch <- RPCResponse{
173 | 						Error: &baseMessage.Error.Message,
174 | 					}
175 | 				} else {
176 | 					ch <- RPCResponse{
177 | 						Response: &baseMessage.Result,
178 | 					}
179 | 				}
180 | 				c.mu.Lock()
181 | 				delete(c.responses, *baseMessage.ID)
182 | 				c.mu.Unlock()
183 | 			}
184 | 		}
185 | 	}
186 | }
187 | 
188 | // sendRequest sends a JSON-RPC request to the server and waits for a response.
189 | // It creates a unique request ID, sends the request over stdin, and waits for
190 | // the corresponding response or context cancellation.
191 | // Returns the raw JSON response message or an error if the request fails.
192 | func (c *StdioMCPClient) sendRequest(
193 | 	ctx context.Context,
194 | 	method string,
195 | 	params interface{},
196 | ) (*json.RawMessage, error) {
197 | 	if !c.initialized && method != "initialize" {
198 | 		return nil, fmt.Errorf("client not initialized")
199 | 	}
200 | 
201 | 	id := c.requestID.Add(1)
202 | 
203 | 	// Create the complete request structure
204 | 	request := mcp.JSONRPCRequest{
205 | 		JSONRPC: mcp.JSONRPC_VERSION,
206 | 		ID:      id,
207 | 		Request: mcp.Request{
208 | 			Method: method,
209 | 		},
210 | 		Params: params,
211 | 	}
212 | 
213 | 	responseChan := make(chan RPCResponse, 1)
214 | 	c.mu.Lock()
215 | 	c.responses[id] = responseChan
216 | 	c.mu.Unlock()
217 | 
218 | 	requestBytes, err := json.Marshal(request)
219 | 	if err != nil {
220 | 		return nil, fmt.Errorf("failed to marshal request: %w", err)
221 | 	}
222 | 	requestBytes = append(requestBytes, '\n')
223 | 
224 | 	if _, err := c.stdin.Write(requestBytes); err != nil {
225 | 		return nil, fmt.Errorf("failed to write request: %w", err)
226 | 	}
227 | 
228 | 	select {
229 | 	case <-ctx.Done():
230 | 		c.mu.Lock()
231 | 		delete(c.responses, id)
232 | 		c.mu.Unlock()
233 | 		return nil, ctx.Err()
234 | 	case response := <-responseChan:
235 | 		if response.Error != nil {
236 | 			return nil, errors.New(*response.Error)
237 | 		}
238 | 		return response.Response, nil
239 | 	}
240 | }
241 | 
242 | func (c *StdioMCPClient) Ping(ctx context.Context) error {
243 | 	_, err := c.sendRequest(ctx, "ping", nil)
244 | 	return err
245 | }
246 | 
247 | func (c *StdioMCPClient) Initialize(
248 | 	ctx context.Context,
249 | 	request mcp.InitializeRequest,
250 | ) (*mcp.InitializeResult, error) {
251 | 	// This structure ensures Capabilities is always included in JSON
252 | 	params := struct {
253 | 		ProtocolVersion string                 `json:"protocolVersion"`
254 | 		ClientInfo      mcp.Implementation     `json:"clientInfo"`
255 | 		Capabilities    mcp.ClientCapabilities `json:"capabilities"`
256 | 	}{
257 | 		ProtocolVersion: request.Params.ProtocolVersion,
258 | 		ClientInfo:      request.Params.ClientInfo,
259 | 		Capabilities:    request.Params.Capabilities, // Will be empty struct if not set
260 | 	}
261 | 
262 | 	response, err := c.sendRequest(ctx, "initialize", params)
263 | 	if err != nil {
264 | 		return nil, err
265 | 	}
266 | 
267 | 	var result mcp.InitializeResult
268 | 	if err := json.Unmarshal(*response, &result); err != nil {
269 | 		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
270 | 	}
271 | 
272 | 	// Store capabilities
273 | 	c.capabilities = result.Capabilities
274 | 
275 | 	// Send initialized notification
276 | 	notification := mcp.JSONRPCNotification{
277 | 		JSONRPC: mcp.JSONRPC_VERSION,
278 | 		Notification: mcp.Notification{
279 | 			Method: "notifications/initialized",
280 | 		},
281 | 	}
282 | 
283 | 	notificationBytes, err := json.Marshal(notification)
284 | 	if err != nil {
285 | 		return nil, fmt.Errorf(
286 | 			"failed to marshal initialized notification: %w",
287 | 			err,
288 | 		)
289 | 	}
290 | 	notificationBytes = append(notificationBytes, '\n')
291 | 
292 | 	if _, err := c.stdin.Write(notificationBytes); err != nil {
293 | 		return nil, fmt.Errorf(
294 | 			"failed to send initialized notification: %w",
295 | 			err,
296 | 		)
297 | 	}
298 | 
299 | 	c.initialized = true
300 | 	return &result, nil
301 | }
302 | 
303 | // ListResourcesByPage manually list resources by page.
304 | func (c *StdioMCPClient) ListResourcesByPage(
305 | 	ctx context.Context,
306 | 	request mcp.ListResourcesRequest,
307 | ) (*mcp.ListResourcesResult, error) {
308 | 	result, err := listByPage[mcp.ListResourcesResult](ctx, c, request.PaginatedRequest, "resources/list")
309 | 	if err != nil {
310 | 		return nil, err
311 | 	}
312 | 	return result, nil
313 | }
314 | 
315 | func (c *StdioMCPClient) ListResources(
316 | 	ctx context.Context,
317 | 	request mcp.ListResourcesRequest,
318 | ) (*mcp.ListResourcesResult, error) {
319 | 	result, err := c.ListResourcesByPage(ctx, request)
320 | 	if err != nil {
321 | 		return nil, err
322 | 	}
323 | 	for result.NextCursor != "" {
324 | 		select {
325 | 		case <-ctx.Done():
326 | 			return nil, ctx.Err()
327 | 		default:
328 | 			request.Params.Cursor = result.NextCursor
329 | 			newPageRes, err := c.ListResourcesByPage(ctx, request)
330 | 			if err != nil {
331 | 				return nil, err
332 | 			}
333 | 			result.Resources = append(result.Resources, newPageRes.Resources...)
334 | 			result.NextCursor = newPageRes.NextCursor
335 | 		}
336 | 	}
337 | 	return result, nil
338 | }
339 | 
340 | func (c *StdioMCPClient) ListResourceTemplatesByPage(
341 | 	ctx context.Context,
342 | 	request mcp.ListResourceTemplatesRequest,
343 | ) (*mcp.ListResourceTemplatesResult, error) {
344 | 	result, err := listByPage[mcp.ListResourceTemplatesResult](ctx, c, request.PaginatedRequest, "resources/templates/list")
345 | 	if err != nil {
346 | 		return nil, err
347 | 	}
348 | 	return result, nil
349 | }
350 | 
351 | func (c *StdioMCPClient) ListResourceTemplates(
352 | 	ctx context.Context,
353 | 	request mcp.ListResourceTemplatesRequest,
354 | ) (*mcp.ListResourceTemplatesResult, error) {
355 | 	result, err := c.ListResourceTemplatesByPage(ctx, request)
356 | 	if err != nil {
357 | 		return nil, err
358 | 	}
359 | 	for result.NextCursor != "" {
360 | 		select {
361 | 		case <-ctx.Done():
362 | 			return nil, ctx.Err()
363 | 		default:
364 | 			request.Params.Cursor = result.NextCursor
365 | 			newPageRes, err := c.ListResourceTemplatesByPage(ctx, request)
366 | 			if err != nil {
367 | 				return nil, err
368 | 			}
369 | 			result.ResourceTemplates = append(result.ResourceTemplates, newPageRes.ResourceTemplates...)
370 | 			result.NextCursor = newPageRes.NextCursor
371 | 		}
372 | 	}
373 | 	return result, nil
374 | }
375 | 
376 | func (c *StdioMCPClient) ReadResource(
377 | 	ctx context.Context,
378 | 	request mcp.ReadResourceRequest,
379 | ) (*mcp.ReadResourceResult,
380 | 	error) {
381 | 	response, err := c.sendRequest(ctx, "resources/read", request.Params)
382 | 	if err != nil {
383 | 		return nil, err
384 | 	}
385 | 
386 | 	return mcp.ParseReadResourceResult(response)
387 | }
388 | 
389 | func (c *StdioMCPClient) Subscribe(
390 | 	ctx context.Context,
391 | 	request mcp.SubscribeRequest,
392 | ) error {
393 | 	_, err := c.sendRequest(ctx, "resources/subscribe", request.Params)
394 | 	return err
395 | }
396 | 
397 | func (c *StdioMCPClient) Unsubscribe(
398 | 	ctx context.Context,
399 | 	request mcp.UnsubscribeRequest,
400 | ) error {
401 | 	_, err := c.sendRequest(ctx, "resources/unsubscribe", request.Params)
402 | 	return err
403 | }
404 | 
405 | func (c *StdioMCPClient) ListPromptsByPage(
406 | 	ctx context.Context,
407 | 	request mcp.ListPromptsRequest,
408 | ) (*mcp.ListPromptsResult, error) {
409 | 	result, err := listByPage[mcp.ListPromptsResult](ctx, c, request.PaginatedRequest, "prompts/list")
410 | 	if err != nil {
411 | 		return nil, err
412 | 	}
413 | 	return result, nil
414 | }
415 | 
416 | func (c *StdioMCPClient) ListPrompts(
417 | 	ctx context.Context,
418 | 	request mcp.ListPromptsRequest,
419 | ) (*mcp.ListPromptsResult, error) {
420 | 	result, err := c.ListPromptsByPage(ctx, request)
421 | 	if err != nil {
422 | 		return nil, err
423 | 	}
424 | 	for result.NextCursor != "" {
425 | 		select {
426 | 		case <-ctx.Done():
427 | 			return nil, ctx.Err()
428 | 		default:
429 | 			request.Params.Cursor = result.NextCursor
430 | 			newPageRes, err := c.ListPromptsByPage(ctx, request)
431 | 			if err != nil {
432 | 				return nil, err
433 | 			}
434 | 			result.Prompts = append(result.Prompts, newPageRes.Prompts...)
435 | 			result.NextCursor = newPageRes.NextCursor
436 | 		}
437 | 	}
438 | 	return result, nil
439 | }
440 | 
441 | func (c *StdioMCPClient) GetPrompt(
442 | 	ctx context.Context,
443 | 	request mcp.GetPromptRequest,
444 | ) (*mcp.GetPromptResult, error) {
445 | 	response, err := c.sendRequest(ctx, "prompts/get", request.Params)
446 | 	if err != nil {
447 | 		return nil, err
448 | 	}
449 | 
450 | 	return mcp.ParseGetPromptResult(response)
451 | }
452 | 
453 | func (c *StdioMCPClient) ListToolsByPage(
454 | 	ctx context.Context,
455 | 	request mcp.ListToolsRequest,
456 | ) (*mcp.ListToolsResult, error) {
457 | 	result, err := listByPage[mcp.ListToolsResult](ctx, c, request.PaginatedRequest, "tools/list")
458 | 	if err != nil {
459 | 		return nil, err
460 | 	}
461 | 	return result, nil
462 | }
463 | 
464 | func (c *StdioMCPClient) ListTools(
465 | 	ctx context.Context,
466 | 	request mcp.ListToolsRequest,
467 | ) (*mcp.ListToolsResult, error) {
468 | 	result, err := c.ListToolsByPage(ctx, request)
469 | 	if err != nil {
470 | 		return nil, err
471 | 	}
472 | 	for result.NextCursor != "" {
473 | 		select {
474 | 		case <-ctx.Done():
475 | 			return nil, ctx.Err()
476 | 		default:
477 | 			request.Params.Cursor = result.NextCursor
478 | 			newPageRes, err := c.ListToolsByPage(ctx, request)
479 | 			if err != nil {
480 | 				return nil, err
481 | 			}
482 | 			result.Tools = append(result.Tools, newPageRes.Tools...)
483 | 			result.NextCursor = newPageRes.NextCursor
484 | 		}
485 | 	}
486 | 	return result, nil
487 | }
488 | 
489 | func (c *StdioMCPClient) CallTool(
490 | 	ctx context.Context,
491 | 	request mcp.CallToolRequest,
492 | ) (*mcp.CallToolResult, error) {
493 | 	response, err := c.sendRequest(ctx, "tools/call", request.Params)
494 | 	if err != nil {
495 | 		return nil, err
496 | 	}
497 | 
498 | 	return mcp.ParseCallToolResult(response)
499 | }
500 | 
501 | func (c *StdioMCPClient) SetLevel(
502 | 	ctx context.Context,
503 | 	request mcp.SetLevelRequest,
504 | ) error {
505 | 	_, err := c.sendRequest(ctx, "logging/setLevel", request.Params)
506 | 	return err
507 | }
508 | 
509 | func (c *StdioMCPClient) Complete(
510 | 	ctx context.Context,
511 | 	request mcp.CompleteRequest,
512 | ) (*mcp.CompleteResult, error) {
513 | 	response, err := c.sendRequest(ctx, "completion/complete", request.Params)
514 | 	if err != nil {
515 | 		return nil, err
516 | 	}
517 | 
518 | 	var result mcp.CompleteResult
519 | 	if err := json.Unmarshal(*response, &result); err != nil {
520 | 		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
521 | 	}
522 | 
523 | 	return &result, nil
524 | }
525 | 


--------------------------------------------------------------------------------
/client/stdio_test.go:
--------------------------------------------------------------------------------
  1 | package client
  2 | 
  3 | import (
  4 | 	"context"
  5 | 	"encoding/json"
  6 | 	"fmt"
  7 | 	"log/slog"
  8 | 	"os"
  9 | 	"os/exec"
 10 | 	"path/filepath"
 11 | 	"sync"
 12 | 	"testing"
 13 | 	"time"
 14 | 
 15 | 	"github.com/mark3labs/mcp-go/mcp"
 16 | )
 17 | 
 18 | func compileTestServer(outputPath string) error {
 19 | 	cmd := exec.Command(
 20 | 		"go",
 21 | 		"build",
 22 | 		"-o",
 23 | 		outputPath,
 24 | 		"../testdata/mockstdio_server.go",
 25 | 	)
 26 | 	if output, err := cmd.CombinedOutput(); err != nil {
 27 | 		return fmt.Errorf("compilation failed: %v\nOutput: %s", err, output)
 28 | 	}
 29 | 	return nil
 30 | }
 31 | 
 32 | func TestStdioMCPClient(t *testing.T) {
 33 | 	// Compile mock server
 34 | 	mockServerPath := filepath.Join(os.TempDir(), "mockstdio_server")
 35 | 	if err := compileTestServer(mockServerPath); err != nil {
 36 | 		t.Fatalf("Failed to compile mock server: %v", err)
 37 | 	}
 38 | 	defer os.Remove(mockServerPath)
 39 | 
 40 | 	client, err := NewStdioMCPClient(mockServerPath, []string{})
 41 | 	if err != nil {
 42 | 		t.Fatalf("Failed to create client: %v", err)
 43 | 	}
 44 | 	var logRecords []map[string]any
 45 | 	var logRecordsMu sync.RWMutex
 46 | 	var wg sync.WaitGroup
 47 | 	wg.Add(1)
 48 | 	go func() {
 49 | 		defer wg.Done()
 50 | 		dec := json.NewDecoder(client.Stderr())
 51 | 		for {
 52 | 			var record map[string]any
 53 | 			if err := dec.Decode(&record); err != nil {
 54 | 				return
 55 | 			}
 56 | 			logRecordsMu.Lock()
 57 | 			logRecords = append(logRecords, record)
 58 | 			logRecordsMu.Unlock()
 59 | 		}
 60 | 	}()
 61 | 
 62 | 	t.Run("Initialize", func(t *testing.T) {
 63 | 		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
 64 | 		defer cancel()
 65 | 
 66 | 		request := mcp.InitializeRequest{}
 67 | 		request.Params.ProtocolVersion = "1.0"
 68 | 		request.Params.ClientInfo = mcp.Implementation{
 69 | 			Name:    "test-client",
 70 | 			Version: "1.0.0",
 71 | 		}
 72 | 		request.Params.Capabilities = mcp.ClientCapabilities{
 73 | 			Roots: &struct {
 74 | 				ListChanged bool `json:"listChanged,omitempty"`
 75 | 			}{
 76 | 				ListChanged: true,
 77 | 			},
 78 | 		}
 79 | 
 80 | 		result, err := client.Initialize(ctx, request)
 81 | 		if err != nil {
 82 | 			t.Fatalf("Initialize failed: %v", err)
 83 | 		}
 84 | 
 85 | 		if result.ServerInfo.Name != "mock-server" {
 86 | 			t.Errorf(
 87 | 				"Expected server name 'mock-server', got '%s'",
 88 | 				result.ServerInfo.Name,
 89 | 			)
 90 | 		}
 91 | 	})
 92 | 
 93 | 	t.Run("Ping", func(t *testing.T) {
 94 | 		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
 95 | 		defer cancel()
 96 | 
 97 | 		err := client.Ping(ctx)
 98 | 		if err != nil {
 99 | 			t.Errorf("Ping failed: %v", err)
100 | 		}
101 | 	})
102 | 
103 | 	t.Run("ListResources", func(t *testing.T) {
104 | 		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
105 | 		defer cancel()
106 | 
107 | 		request := mcp.ListResourcesRequest{}
108 | 		result, err := client.ListResources(ctx, request)
109 | 		if err != nil {
110 | 			t.Errorf("ListResources failed: %v", err)
111 | 		}
112 | 
113 | 		if len(result.Resources) != 1 {
114 | 			t.Errorf("Expected 1 resource, got %d", len(result.Resources))
115 | 		}
116 | 	})
117 | 
118 | 	t.Run("ReadResource", func(t *testing.T) {
119 | 		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
120 | 		defer cancel()
121 | 
122 | 		request := mcp.ReadResourceRequest{}
123 | 		request.Params.URI = "test://resource"
124 | 
125 | 		result, err := client.ReadResource(ctx, request)
126 | 		if err != nil {
127 | 			t.Errorf("ReadResource failed: %v", err)
128 | 		}
129 | 
130 | 		if len(result.Contents) != 1 {
131 | 			t.Errorf("Expected 1 content item, got %d", len(result.Contents))
132 | 		}
133 | 	})
134 | 
135 | 	t.Run("Subscribe and Unsubscribe", func(t *testing.T) {
136 | 		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
137 | 		defer cancel()
138 | 
139 | 		// Test Subscribe
140 | 		subRequest := mcp.SubscribeRequest{}
141 | 		subRequest.Params.URI = "test://resource"
142 | 		err := client.Subscribe(ctx, subRequest)
143 | 		if err != nil {
144 | 			t.Errorf("Subscribe failed: %v", err)
145 | 		}
146 | 
147 | 		// Test Unsubscribe
148 | 		unsubRequest := mcp.UnsubscribeRequest{}
149 | 		unsubRequest.Params.URI = "test://resource"
150 | 		err = client.Unsubscribe(ctx, unsubRequest)
151 | 		if err != nil {
152 | 			t.Errorf("Unsubscribe failed: %v", err)
153 | 		}
154 | 	})
155 | 
156 | 	t.Run("ListPrompts", func(t *testing.T) {
157 | 		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
158 | 		defer cancel()
159 | 
160 | 		request := mcp.ListPromptsRequest{}
161 | 		result, err := client.ListPrompts(ctx, request)
162 | 		if err != nil {
163 | 			t.Errorf("ListPrompts failed: %v", err)
164 | 		}
165 | 
166 | 		if len(result.Prompts) != 1 {
167 | 			t.Errorf("Expected 1 prompt, got %d", len(result.Prompts))
168 | 		}
169 | 	})
170 | 
171 | 	t.Run("GetPrompt", func(t *testing.T) {
172 | 		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
173 | 		defer cancel()
174 | 
175 | 		request := mcp.GetPromptRequest{}
176 | 		request.Params.Name = "test-prompt"
177 | 
178 | 		result, err := client.GetPrompt(ctx, request)
179 | 		if err != nil {
180 | 			t.Errorf("GetPrompt failed: %v", err)
181 | 		}
182 | 
183 | 		if len(result.Messages) != 1 {
184 | 			t.Errorf("Expected 1 message, got %d", len(result.Messages))
185 | 		}
186 | 	})
187 | 
188 | 	t.Run("ListTools", func(t *testing.T) {
189 | 		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
190 | 		defer cancel()
191 | 
192 | 		request := mcp.ListToolsRequest{}
193 | 		result, err := client.ListTools(ctx, request)
194 | 		if err != nil {
195 | 			t.Errorf("ListTools failed: %v", err)
196 | 		}
197 | 
198 | 		if len(result.Tools) != 1 {
199 | 			t.Errorf("Expected 1 tool, got %d", len(result.Tools))
200 | 		}
201 | 	})
202 | 
203 | 	t.Run("CallTool", func(t *testing.T) {
204 | 		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
205 | 		defer cancel()
206 | 
207 | 		request := mcp.CallToolRequest{}
208 | 		request.Params.Name = "test-tool"
209 | 		request.Params.Arguments = map[string]interface{}{
210 | 			"param1": "value1",
211 | 		}
212 | 
213 | 		result, err := client.CallTool(ctx, request)
214 | 		if err != nil {
215 | 			t.Errorf("CallTool failed: %v", err)
216 | 		}
217 | 
218 | 		if len(result.Content) != 1 {
219 | 			t.Errorf("Expected 1 content item, got %d", len(result.Content))
220 | 		}
221 | 	})
222 | 
223 | 	t.Run("SetLevel", func(t *testing.T) {
224 | 		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
225 | 		defer cancel()
226 | 
227 | 		request := mcp.SetLevelRequest{}
228 | 		request.Params.Level = mcp.LoggingLevelInfo
229 | 
230 | 		err := client.SetLevel(ctx, request)
231 | 		if err != nil {
232 | 			t.Errorf("SetLevel failed: %v", err)
233 | 		}
234 | 	})
235 | 
236 | 	t.Run("Complete", func(t *testing.T) {
237 | 		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
238 | 		defer cancel()
239 | 
240 | 		request := mcp.CompleteRequest{}
241 | 		request.Params.Ref = mcp.PromptReference{
242 | 			Type: "ref/prompt",
243 | 			Name: "test-prompt",
244 | 		}
245 | 		request.Params.Argument.Name = "test-arg"
246 | 		request.Params.Argument.Value = "test-value"
247 | 
248 | 		result, err := client.Complete(ctx, request)
249 | 		if err != nil {
250 | 			t.Errorf("Complete failed: %v", err)
251 | 		}
252 | 
253 | 		if len(result.Completion.Values) != 1 {
254 | 			t.Errorf(
255 | 				"Expected 1 completion value, got %d",
256 | 				len(result.Completion.Values),
257 | 			)
258 | 		}
259 | 	})
260 | 
261 | 	client.Close()
262 | 	wg.Wait()
263 | 
264 | 	t.Run("CheckLogs", func(t *testing.T) {
265 | 		logRecordsMu.RLock()
266 | 		defer logRecordsMu.RUnlock()
267 | 
268 | 		if len(logRecords) != 1 {
269 | 			t.Errorf("Expected 1 log record, got %d", len(logRecords))
270 | 			return
271 | 		}
272 | 
273 | 		msg, ok := logRecords[0][slog.MessageKey].(string)
274 | 		if !ok {
275 | 			t.Errorf("Expected log record to have message key")
276 | 		}
277 | 		if msg != "launch successful" {
278 | 			t.Errorf("Expected log message 'launch successful', got '%s'", msg)
279 | 		}
280 | 	})
281 | }
282 | 


--------------------------------------------------------------------------------
/client/types.go:
--------------------------------------------------------------------------------
1 | package client
2 | 
3 | import "encoding/json"
4 | 
5 | type RPCResponse struct {
6 | 	Error    *string
7 | 	Response *json.RawMessage
8 | }
9 | 


--------------------------------------------------------------------------------