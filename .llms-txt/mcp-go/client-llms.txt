└── client
    ├── client.go
    ├── sse.go
    ├── sse_test.go
    ├── stdio.go
    ├── stdio_test.go
    └── types.go


/client/client.go:
--------------------------------------------------------------------------------
 1 | // Package client provides MCP (Model Control Protocol) client implementations.
 2 | package client
 3 | 
 4 | import (
 5 | 	"context"
 6 | 
 7 | 	"github.com/mark3labs/mcp-go/mcp"
 8 | )
 9 | 
10 | // MCPClient represents an MCP client interface
11 | type MCPClient interface {
12 | 	// Initialize sends the initial connection request to the server
13 | 	Initialize(
14 | 		ctx context.Context,
15 | 		request mcp.InitializeRequest,
16 | 	) (*mcp.InitializeResult, error)
17 | 
18 | 	// Ping checks if the server is alive
19 | 	Ping(ctx context.Context) error
20 | 
21 | 	// ListResources requests a list of available resources from the server
22 | 	ListResources(
23 | 		ctx context.Context,
24 | 		request mcp.ListResourcesRequest,
25 | 	) (*mcp.ListResourcesResult, error)
26 | 
27 | 	// ListResourceTemplates requests a list of available resource templates from the server
28 | 	ListResourceTemplates(
29 | 		ctx context.Context,
30 | 		request mcp.ListResourceTemplatesRequest,
31 | 	) (*mcp.ListResourceTemplatesResult,
32 | 		error)
33 | 
34 | 	// ReadResource reads a specific resource from the server
35 | 	ReadResource(
36 | 		ctx context.Context,
37 | 		request mcp.ReadResourceRequest,
38 | 	) (*mcp.ReadResourceResult, error)
39 | 
40 | 	// Subscribe requests notifications for changes to a specific resource
41 | 	Subscribe(ctx context.Context, request mcp.SubscribeRequest) error
42 | 
43 | 	// Unsubscribe cancels notifications for a specific resource
44 | 	Unsubscribe(ctx context.Context, request mcp.UnsubscribeRequest) error
45 | 
46 | 	// ListPrompts requests a list of available prompts from the server
47 | 	ListPrompts(
48 | 		ctx context.Context,
49 | 		request mcp.ListPromptsRequest,
50 | 	) (*mcp.ListPromptsResult, error)
51 | 
52 | 	// GetPrompt retrieves a specific prompt from the server
53 | 	GetPrompt(
54 | 		ctx context.Context,
55 | 		request mcp.GetPromptRequest,
56 | 	) (*mcp.GetPromptResult, error)
57 | 
58 | 	// ListTools requests a list of available tools from the server
59 | 	ListTools(
60 | 		ctx context.Context,
61 | 		request mcp.ListToolsRequest,
62 | 	) (*mcp.ListToolsResult, error)
63 | 
64 | 	// CallTool invokes a specific tool on the server
65 | 	CallTool(
66 | 		ctx context.Context,
67 | 		request mcp.CallToolRequest,
68 | 	) (*mcp.CallToolResult, error)
69 | 
70 | 	// SetLevel sets the logging level for the server
71 | 	SetLevel(ctx context.Context, request mcp.SetLevelRequest) error
72 | 
73 | 	// Complete requests completion options for a given argument
74 | 	Complete(
75 | 		ctx context.Context,
76 | 		request mcp.CompleteRequest,
77 | 	) (*mcp.CompleteResult, error)
78 | 
79 | 	// Close client connection and cleanup resources
80 | 	Close() error
81 | 
82 | 	// OnNotification registers a handler for notifications
83 | 	OnNotification(handler func(notification mcp.JSONRPCNotification))
84 | }
85 | 


--------------------------------------------------------------------------------
/client/sse.go:
--------------------------------------------------------------------------------
  1 | package client
  2 | 
  3 | import (
  4 | 	"bufio"
  5 | 	"bytes"
  6 | 	"context"
  7 | 	"encoding/json"
  8 | 	"errors"
  9 | 	"fmt"
 10 | 	"io"
 11 | 	"net/http"
 12 | 	"net/url"
 13 | 	"strings"
 14 | 	"sync"
 15 | 	"sync/atomic"
 16 | 	"time"
 17 | 
 18 | 	"github.com/mark3labs/mcp-go/mcp"
 19 | )
 20 | 
 21 | // SSEMCPClient implements the MCPClient interface using Server-Sent Events (SSE).
 22 | // It maintains a persistent HTTP connection to receive server-pushed events
 23 | // while sending requests over regular HTTP POST calls. The client handles
 24 | // automatic reconnection and message routing between requests and responses.
 25 | type SSEMCPClient struct {
 26 | 	baseURL        *url.URL
 27 | 	endpoint       *url.URL
 28 | 	httpClient     *http.Client
 29 | 	requestID      atomic.Int64
 30 | 	responses      map[int64]chan RPCResponse
 31 | 	mu             sync.RWMutex
 32 | 	done           chan struct{}
 33 | 	initialized    bool
 34 | 	notifications  []func(mcp.JSONRPCNotification)
 35 | 	notifyMu       sync.RWMutex
 36 | 	endpointChan   chan struct{}
 37 | 	capabilities   mcp.ServerCapabilities
 38 | 	headers        map[string]string
 39 | 	sseReadTimeout time.Duration
 40 | }
 41 | 
 42 | type ClientOption func(*SSEMCPClient)
 43 | 
 44 | func WithHeaders(headers map[string]string) ClientOption {
 45 | 	return func(sc *SSEMCPClient) {
 46 | 		sc.headers = headers
 47 | 	}
 48 | }
 49 | 
 50 | func WithSSEReadTimeout(timeout time.Duration) ClientOption {
 51 | 	return func(sc *SSEMCPClient) {
 52 | 		sc.sseReadTimeout = timeout
 53 | 	}
 54 | }
 55 | 
 56 | // NewSSEMCPClient creates a new SSE-based MCP client with the given base URL.
 57 | // Returns an error if the URL is invalid.
 58 | func NewSSEMCPClient(baseURL string, options ...ClientOption) (*SSEMCPClient, error) {
 59 | 	parsedURL, err := url.Parse(baseURL)
 60 | 	if err != nil {
 61 | 		return nil, fmt.Errorf("invalid URL: %w", err)
 62 | 	}
 63 | 
 64 | 	smc := &SSEMCPClient{
 65 | 		baseURL:        parsedURL,
 66 | 		httpClient:     &http.Client{},
 67 | 		responses:      make(map[int64]chan RPCResponse),
 68 | 		done:           make(chan struct{}),
 69 | 		endpointChan:   make(chan struct{}),
 70 | 		sseReadTimeout: 30 * time.Second,
 71 | 		headers:        make(map[string]string),
 72 | 	}
 73 | 
 74 | 	for _, opt := range options {
 75 | 		opt(smc)
 76 | 	}
 77 | 
 78 | 	return smc, nil
 79 | }
 80 | 
 81 | // Start initiates the SSE connection to the server and waits for the endpoint information.
 82 | // Returns an error if the connection fails or times out waiting for the endpoint.
 83 | func (c *SSEMCPClient) Start(ctx context.Context) error {
 84 | 
 85 | 	req, err := http.NewRequestWithContext(ctx, "GET", c.baseURL.String(), nil)
 86 | 
 87 | 	if err != nil {
 88 | 
 89 | 		return fmt.Errorf("failed to create request: %w", err)
 90 | 
 91 | 	}
 92 | 
 93 | 	req.Header.Set("Accept", "text/event-stream")
 94 | 	req.Header.Set("Cache-Control", "no-cache")
 95 | 	req.Header.Set("Connection", "keep-alive")
 96 | 
 97 | 	resp, err := c.httpClient.Do(req)
 98 | 	if err != nil {
 99 | 		return fmt.Errorf("failed to connect to SSE stream: %w", err)
100 | 	}
101 | 
102 | 	if resp.StatusCode != http.StatusOK {
103 | 		resp.Body.Close()
104 | 		return fmt.Errorf("unexpected status code: %d", resp.StatusCode)
105 | 	}
106 | 
107 | 	go c.readSSE(resp.Body)
108 | 
109 | 	// Wait for the endpoint to be received
110 | 
111 | 	select {
112 | 	case <-c.endpointChan:
113 | 		// Endpoint received, proceed
114 | 	case <-ctx.Done():
115 | 		return fmt.Errorf("context cancelled while waiting for endpoint")
116 | 	case <-time.After(30 * time.Second): // Add a timeout
117 | 		return fmt.Errorf("timeout waiting for endpoint")
118 | 	}
119 | 
120 | 	return nil
121 | }
122 | 
123 | // readSSE continuously reads the SSE stream and processes events.
124 | // It runs until the connection is closed or an error occurs.
125 | func (c *SSEMCPClient) readSSE(reader io.ReadCloser) {
126 | 	defer reader.Close()
127 | 
128 | 	br := bufio.NewReader(reader)
129 | 	var event, data string
130 | 
131 | 	ctx, cancel := context.WithTimeout(context.Background(), c.sseReadTimeout)
132 | 	defer cancel()
133 | 
134 | 	for {
135 | 		select {
136 | 		case <-ctx.Done():
137 | 			return
138 | 		default:
139 | 			line, err := br.ReadString('\n')
140 | 			if err != nil {
141 | 				if err == io.EOF {
142 | 					// Process any pending event before exit
143 | 					if event != "" && data != "" {
144 | 						c.handleSSEEvent(event, data)
145 | 					}
146 | 					break
147 | 				}
148 | 				select {
149 | 				case <-c.done:
150 | 					return
151 | 				default:
152 | 					fmt.Printf("SSE stream error: %v\n", err)
153 | 					return
154 | 				}
155 | 			}
156 | 
157 | 			// Remove only newline markers
158 | 			line = strings.TrimRight(line, "\r\n")
159 | 			if line == "" {
160 | 				// Empty line means end of event
161 | 				if event != "" && data != "" {
162 | 					c.handleSSEEvent(event, data)
163 | 					event = ""
164 | 					data = ""
165 | 				}
166 | 				continue
167 | 			}
168 | 
169 | 			if strings.HasPrefix(line, "event:") {
170 | 				event = strings.TrimSpace(strings.TrimPrefix(line, "event:"))
171 | 			} else if strings.HasPrefix(line, "data:") {
172 | 				data = strings.TrimSpace(strings.TrimPrefix(line, "data:"))
173 | 			}
174 | 		}
175 | 	}
176 | }
177 | 
178 | // handleSSEEvent processes SSE events based on their type.
179 | // Handles 'endpoint' events for connection setup and 'message' events for JSON-RPC communication.
180 | func (c *SSEMCPClient) handleSSEEvent(event, data string) {
181 | 	switch event {
182 | 	case "endpoint":
183 | 		endpoint, err := c.baseURL.Parse(data)
184 | 		if err != nil {
185 | 			fmt.Printf("Error parsing endpoint URL: %v\n", err)
186 | 			return
187 | 		}
188 | 		if endpoint.Host != c.baseURL.Host {
189 | 			fmt.Printf("Endpoint origin does not match connection origin\n")
190 | 			return
191 | 		}
192 | 		c.endpoint = endpoint
193 | 		close(c.endpointChan)
194 | 
195 | 	case "message":
196 | 		var baseMessage struct {
197 | 			JSONRPC string          `json:"jsonrpc"`
198 | 			ID      *int64          `json:"id,omitempty"`
199 | 			Method  string          `json:"method,omitempty"`
200 | 			Result  json.RawMessage `json:"result,omitempty"`
201 | 			Error   *struct {
202 | 				Code    int    `json:"code"`
203 | 				Message string `json:"message"`
204 | 			} `json:"error,omitempty"`
205 | 		}
206 | 
207 | 		if err := json.Unmarshal([]byte(data), &baseMessage); err != nil {
208 | 			fmt.Printf("Error unmarshaling message: %v\n", err)
209 | 			return
210 | 		}
211 | 
212 | 		// Handle notification
213 | 		if baseMessage.ID == nil {
214 | 			var notification mcp.JSONRPCNotification
215 | 			if err := json.Unmarshal([]byte(data), &notification); err != nil {
216 | 				return
217 | 			}
218 | 			c.notifyMu.RLock()
219 | 			for _, handler := range c.notifications {
220 | 				handler(notification)
221 | 			}
222 | 			c.notifyMu.RUnlock()
223 | 			return
224 | 		}
225 | 
226 | 		c.mu.RLock()
227 | 		ch, ok := c.responses[*baseMessage.ID]
228 | 		c.mu.RUnlock()
229 | 
230 | 		if ok {
231 | 			if baseMessage.Error != nil {
232 | 				ch <- RPCResponse{
233 | 					Error: &baseMessage.Error.Message,
234 | 				}
235 | 			} else {
236 | 				ch <- RPCResponse{
237 | 					Response: &baseMessage.Result,
238 | 				}
239 | 			}
240 | 			c.mu.Lock()
241 | 			delete(c.responses, *baseMessage.ID)
242 | 			c.mu.Unlock()
243 | 		}
244 | 	}
245 | }
246 | 
247 | // OnNotification registers a handler function to be called when notifications are received.
248 | // Multiple handlers can be registered and will be called in the order they were added.
249 | func (c *SSEMCPClient) OnNotification(
250 | 	handler func(notification mcp.JSONRPCNotification),
251 | ) {
252 | 	c.notifyMu.Lock()
253 | 	defer c.notifyMu.Unlock()
254 | 	c.notifications = append(c.notifications, handler)
255 | }
256 | 
257 | // sendRequest sends a JSON-RPC request to the server and waits for a response.
258 | // Returns the raw JSON response message or an error if the request fails.
259 | func (c *SSEMCPClient) sendRequest(
260 | 	ctx context.Context,
261 | 	method string,
262 | 	params interface{},
263 | ) (*json.RawMessage, error) {
264 | 	if !c.initialized && method != "initialize" {
265 | 		return nil, fmt.Errorf("client not initialized")
266 | 	}
267 | 
268 | 	if c.endpoint == nil {
269 | 		return nil, fmt.Errorf("endpoint not received")
270 | 	}
271 | 
272 | 	id := c.requestID.Add(1)
273 | 
274 | 	request := mcp.JSONRPCRequest{
275 | 		JSONRPC: mcp.JSONRPC_VERSION,
276 | 		ID:      id,
277 | 		Request: mcp.Request{
278 | 			Method: method,
279 | 		},
280 | 		Params: params,
281 | 	}
282 | 
283 | 	requestBytes, err := json.Marshal(request)
284 | 	if err != nil {
285 | 		return nil, fmt.Errorf("failed to marshal request: %w", err)
286 | 	}
287 | 
288 | 	responseChan := make(chan RPCResponse, 1)
289 | 	c.mu.Lock()
290 | 	c.responses[id] = responseChan
291 | 	c.mu.Unlock()
292 | 
293 | 	req, err := http.NewRequestWithContext(
294 | 		ctx,
295 | 		"POST",
296 | 		c.endpoint.String(),
297 | 		bytes.NewReader(requestBytes),
298 | 	)
299 | 	if err != nil {
300 | 		return nil, fmt.Errorf("failed to create request: %w", err)
301 | 	}
302 | 
303 | 	req.Header.Set("Content-Type", "application/json")
304 | 	// set custom http headers
305 | 	for k, v := range c.headers {
306 | 		req.Header.Set(k, v)
307 | 	}
308 | 
309 | 	resp, err := c.httpClient.Do(req)
310 | 	if err != nil {
311 | 		return nil, fmt.Errorf("failed to send request: %w", err)
312 | 	}
313 | 	defer resp.Body.Close()
314 | 
315 | 	if resp.StatusCode != http.StatusOK &&
316 | 		resp.StatusCode != http.StatusAccepted {
317 | 		body, _ := io.ReadAll(resp.Body)
318 | 		return nil, fmt.Errorf(
319 | 			"request failed with status %d: %s",
320 | 			resp.StatusCode,
321 | 			body,
322 | 		)
323 | 	}
324 | 
325 | 	select {
326 | 	case <-ctx.Done():
327 | 		c.mu.Lock()
328 | 		delete(c.responses, id)
329 | 		c.mu.Unlock()
330 | 		return nil, ctx.Err()
331 | 	case response := <-responseChan:
332 | 		if response.Error != nil {
333 | 			return nil, errors.New(*response.Error)
334 | 		}
335 | 		return response.Response, nil
336 | 	}
337 | }
338 | 
339 | func (c *SSEMCPClient) Initialize(
340 | 	ctx context.Context,
341 | 	request mcp.InitializeRequest,
342 | ) (*mcp.InitializeResult, error) {
343 | 	// Ensure we send a params object with all required fields
344 | 	params := struct {
345 | 		ProtocolVersion string                 `json:"protocolVersion"`
346 | 		ClientInfo      mcp.Implementation     `json:"clientInfo"`
347 | 		Capabilities    mcp.ClientCapabilities `json:"capabilities"`
348 | 	}{
349 | 		ProtocolVersion: request.Params.ProtocolVersion,
350 | 		ClientInfo:      request.Params.ClientInfo,
351 | 		Capabilities:    request.Params.Capabilities, // Will be empty struct if not set
352 | 	}
353 | 
354 | 	response, err := c.sendRequest(ctx, "initialize", params)
355 | 	if err != nil {
356 | 		return nil, err
357 | 	}
358 | 
359 | 	var result mcp.InitializeResult
360 | 	if err := json.Unmarshal(*response, &result); err != nil {
361 | 		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
362 | 	}
363 | 
364 | 	// Store capabilities
365 | 	c.capabilities = result.Capabilities
366 | 
367 | 	// Send initialized notification
368 | 	notification := mcp.JSONRPCNotification{
369 | 		JSONRPC: mcp.JSONRPC_VERSION,
370 | 		Notification: mcp.Notification{
371 | 			Method: "notifications/initialized",
372 | 		},
373 | 	}
374 | 
375 | 	notificationBytes, err := json.Marshal(notification)
376 | 	if err != nil {
377 | 		return nil, fmt.Errorf(
378 | 			"failed to marshal initialized notification: %w",
379 | 			err,
380 | 		)
381 | 	}
382 | 
383 | 	req, err := http.NewRequestWithContext(
384 | 		ctx,
385 | 		"POST",
386 | 		c.endpoint.String(),
387 | 		bytes.NewReader(notificationBytes),
388 | 	)
389 | 	if err != nil {
390 | 		return nil, fmt.Errorf("failed to create notification request: %w", err)
391 | 	}
392 | 
393 | 	req.Header.Set("Content-Type", "application/json")
394 | 
395 | 	resp, err := c.httpClient.Do(req)
396 | 	if err != nil {
397 | 		return nil, fmt.Errorf(
398 | 			"failed to send initialized notification: %w",
399 | 			err,
400 | 		)
401 | 	}
402 | 	resp.Body.Close()
403 | 
404 | 	c.initialized = true
405 | 	return &result, nil
406 | }
407 | 
408 | func (c *SSEMCPClient) Ping(ctx context.Context) error {
409 | 	_, err := c.sendRequest(ctx, "ping", nil)
410 | 	return err
411 | }
412 | 
413 | func (c *SSEMCPClient) ListResources(
414 | 	ctx context.Context,
415 | 	request mcp.ListResourcesRequest,
416 | ) (*mcp.ListResourcesResult, error) {
417 | 	response, err := c.sendRequest(ctx, "resources/list", request.Params)
418 | 	if err != nil {
419 | 		return nil, err
420 | 	}
421 | 
422 | 	var result mcp.ListResourcesResult
423 | 	if err := json.Unmarshal(*response, &result); err != nil {
424 | 		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
425 | 	}
426 | 
427 | 	return &result, nil
428 | }
429 | 
430 | func (c *SSEMCPClient) ListResourceTemplates(
431 | 	ctx context.Context,
432 | 	request mcp.ListResourceTemplatesRequest,
433 | ) (*mcp.ListResourceTemplatesResult, error) {
434 | 	response, err := c.sendRequest(
435 | 		ctx,
436 | 		"resources/templates/list",
437 | 		request.Params,
438 | 	)
439 | 	if err != nil {
440 | 		return nil, err
441 | 	}
442 | 
443 | 	var result mcp.ListResourceTemplatesResult
444 | 	if err := json.Unmarshal(*response, &result); err != nil {
445 | 		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
446 | 	}
447 | 
448 | 	return &result, nil
449 | }
450 | 
451 | func (c *SSEMCPClient) ReadResource(
452 | 	ctx context.Context,
453 | 	request mcp.ReadResourceRequest,
454 | ) (*mcp.ReadResourceResult, error) {
455 | 	response, err := c.sendRequest(ctx, "resources/read", request.Params)
456 | 	if err != nil {
457 | 		return nil, err
458 | 	}
459 | 
460 | 	return mcp.ParseReadResourceResult(response)
461 | }
462 | 
463 | func (c *SSEMCPClient) Subscribe(
464 | 	ctx context.Context,
465 | 	request mcp.SubscribeRequest,
466 | ) error {
467 | 	_, err := c.sendRequest(ctx, "resources/subscribe", request.Params)
468 | 	return err
469 | }
470 | 
471 | func (c *SSEMCPClient) Unsubscribe(
472 | 	ctx context.Context,
473 | 	request mcp.UnsubscribeRequest,
474 | ) error {
475 | 	_, err := c.sendRequest(ctx, "resources/unsubscribe", request.Params)
476 | 	return err
477 | }
478 | 
479 | func (c *SSEMCPClient) ListPrompts(
480 | 	ctx context.Context,
481 | 	request mcp.ListPromptsRequest,
482 | ) (*mcp.ListPromptsResult, error) {
483 | 	response, err := c.sendRequest(ctx, "prompts/list", request.Params)
484 | 	if err != nil {
485 | 		return nil, err
486 | 	}
487 | 
488 | 	var result mcp.ListPromptsResult
489 | 	if err := json.Unmarshal(*response, &result); err != nil {
490 | 		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
491 | 	}
492 | 
493 | 	return &result, nil
494 | }
495 | 
496 | func (c *SSEMCPClient) GetPrompt(
497 | 	ctx context.Context,
498 | 	request mcp.GetPromptRequest,
499 | ) (*mcp.GetPromptResult, error) {
500 | 	response, err := c.sendRequest(ctx, "prompts/get", request.Params)
501 | 	if err != nil {
502 | 		return nil, err
503 | 	}
504 | 
505 | 	return mcp.ParseGetPromptResult(response)
506 | }
507 | 
508 | func (c *SSEMCPClient) ListTools(
509 | 	ctx context.Context,
510 | 	request mcp.ListToolsRequest,
511 | ) (*mcp.ListToolsResult, error) {
512 | 	response, err := c.sendRequest(ctx, "tools/list", request.Params)
513 | 	if err != nil {
514 | 		return nil, err
515 | 	}
516 | 
517 | 	var result mcp.ListToolsResult
518 | 	if err := json.Unmarshal(*response, &result); err != nil {
519 | 		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
520 | 	}
521 | 
522 | 	return &result, nil
523 | }
524 | 
525 | func (c *SSEMCPClient) CallTool(
526 | 	ctx context.Context,
527 | 	request mcp.CallToolRequest,
528 | ) (*mcp.CallToolResult, error) {
529 | 	response, err := c.sendRequest(ctx, "tools/call", request.Params)
530 | 	if err != nil {
531 | 		return nil, err
532 | 	}
533 | 
534 | 	return mcp.ParseCallToolResult(response)
535 | }
536 | 
537 | func (c *SSEMCPClient) SetLevel(
538 | 	ctx context.Context,
539 | 	request mcp.SetLevelRequest,
540 | ) error {
541 | 	_, err := c.sendRequest(ctx, "logging/setLevel", request.Params)
542 | 	return err
543 | }
544 | 
545 | func (c *SSEMCPClient) Complete(
546 | 	ctx context.Context,
547 | 	request mcp.CompleteRequest,
548 | ) (*mcp.CompleteResult, error) {
549 | 	response, err := c.sendRequest(ctx, "completion/complete", request.Params)
550 | 	if err != nil {
551 | 		return nil, err
552 | 	}
553 | 
554 | 	var result mcp.CompleteResult
555 | 	if err := json.Unmarshal(*response, &result); err != nil {
556 | 		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
557 | 	}
558 | 
559 | 	return &result, nil
560 | }
561 | 
562 | // Helper methods
563 | 
564 | // GetEndpoint returns the current endpoint URL for the SSE connection.
565 | func (c *SSEMCPClient) GetEndpoint() *url.URL {
566 | 	return c.endpoint
567 | }
568 | 
569 | // Close shuts down the SSE client connection and cleans up any pending responses.
570 | // Returns an error if the shutdown process fails.
571 | func (c *SSEMCPClient) Close() error {
572 | 	select {
573 | 	case <-c.done:
574 | 		return nil // Already closed
575 | 	default:
576 | 		close(c.done)
577 | 	}
578 | 
579 | 	// Clean up any pending responses
580 | 	c.mu.Lock()
581 | 	for _, ch := range c.responses {
582 | 		close(ch)
583 | 	}
584 | 	c.responses = make(map[int64]chan RPCResponse)
585 | 	c.mu.Unlock()
586 | 
587 | 	return nil
588 | }
589 | 


--------------------------------------------------------------------------------
/client/sse_test.go:
--------------------------------------------------------------------------------
  1 | package client
  2 | 
  3 | import (
  4 | 	"context"
  5 | 	"testing"
  6 | 	"time"
  7 | 
  8 | 	"github.com/mark3labs/mcp-go/mcp"
  9 | 	"github.com/mark3labs/mcp-go/server"
 10 | )
 11 | 
 12 | func TestSSEMCPClient(t *testing.T) {
 13 | 	// Create MCP server with capabilities
 14 | 	mcpServer := server.NewMCPServer(
 15 | 		"test-server",
 16 | 		"1.0.0",
 17 | 		server.WithResourceCapabilities(true, true),
 18 | 		server.WithPromptCapabilities(true),
 19 | 		server.WithToolCapabilities(true),
 20 | 	)
 21 | 
 22 | 	// Add a test tool
 23 | 	mcpServer.AddTool(mcp.NewTool(
 24 | 		"test-tool",
 25 | 		mcp.WithDescription("Test tool"),
 26 | 		mcp.WithString("parameter-1", mcp.Description("A string tool parameter")),
 27 | 	), func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
 28 | 		return &mcp.CallToolResult{
 29 | 			Content: []mcp.Content{
 30 | 				mcp.TextContent{
 31 | 					Type: "text",
 32 | 					Text: "Input parameter: " + request.Params.Arguments["parameter-1"].(string),
 33 | 				},
 34 | 			},
 35 | 		}, nil
 36 | 	})
 37 | 
 38 | 	// Initialize
 39 | 	testServer := server.NewTestServer(mcpServer)
 40 | 	defer testServer.Close()
 41 | 
 42 | 	t.Run("Can create client", func(t *testing.T) {
 43 | 		client, err := NewSSEMCPClient(testServer.URL + "/sse")
 44 | 		if err != nil {
 45 | 			t.Fatalf("Failed to create client: %v", err)
 46 | 		}
 47 | 		defer client.Close()
 48 | 
 49 | 		if client.baseURL == nil {
 50 | 			t.Error("Base URL should not be nil")
 51 | 		}
 52 | 	})
 53 | 
 54 | 	t.Run("Can initialize and make requests", func(t *testing.T) {
 55 | 		client, err := NewSSEMCPClient(testServer.URL + "/sse")
 56 | 		if err != nil {
 57 | 			t.Fatalf("Failed to create client: %v", err)
 58 | 		}
 59 | 		defer client.Close()
 60 | 
 61 | 		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
 62 | 		defer cancel()
 63 | 
 64 | 		// Start the client
 65 | 		if err := client.Start(ctx); err != nil {
 66 | 			t.Fatalf("Failed to start client: %v", err)
 67 | 		}
 68 | 
 69 | 		// Initialize
 70 | 		initRequest := mcp.InitializeRequest{}
 71 | 		initRequest.Params.ProtocolVersion = mcp.LATEST_PROTOCOL_VERSION
 72 | 		initRequest.Params.ClientInfo = mcp.Implementation{
 73 | 			Name:    "test-client",
 74 | 			Version: "1.0.0",
 75 | 		}
 76 | 
 77 | 		result, err := client.Initialize(ctx, initRequest)
 78 | 		if err != nil {
 79 | 			t.Fatalf("Failed to initialize: %v", err)
 80 | 		}
 81 | 
 82 | 		if result.ServerInfo.Name != "test-server" {
 83 | 			t.Errorf(
 84 | 				"Expected server name 'test-server', got '%s'",
 85 | 				result.ServerInfo.Name,
 86 | 			)
 87 | 		}
 88 | 
 89 | 		// Test Ping
 90 | 		if err := client.Ping(ctx); err != nil {
 91 | 			t.Errorf("Ping failed: %v", err)
 92 | 		}
 93 | 
 94 | 		// Test ListTools
 95 | 		toolsRequest := mcp.ListToolsRequest{}
 96 | 		_, err = client.ListTools(ctx, toolsRequest)
 97 | 		if err != nil {
 98 | 			t.Errorf("ListTools failed: %v", err)
 99 | 		}
100 | 	})
101 | 
102 | 	// t.Run("Can handle notifications", func(t *testing.T) {
103 | 	// 	client, err := NewSSEMCPClient(testServer.URL + "/sse")
104 | 	// 	if err != nil {
105 | 	// 		t.Fatalf("Failed to create client: %v", err)
106 | 	// 	}
107 | 	// 	defer client.Close()
108 | 
109 | 	// 	notificationReceived := make(chan mcp.JSONRPCNotification, 1)
110 | 	// 	client.OnNotification(func(notification mcp.JSONRPCNotification) {
111 | 	// 		notificationReceived <- notification
112 | 	// 	})
113 | 
114 | 	// 	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
115 | 	// 	defer cancel()
116 | 
117 | 	// 	if err := client.Start(ctx); err != nil {
118 | 	// 		t.Fatalf("Failed to start client: %v", err)
119 | 	// 	}
120 | 
121 | 	// 	// Initialize first
122 | 	// 	initRequest := mcp.InitializeRequest{}
123 | 	// 	initRequest.Params.ProtocolVersion = mcp.LATEST_PROTOCOL_VERSION
124 | 	// 	initRequest.Params.ClientInfo = mcp.Implementation{
125 | 	// 		Name:    "test-client",
126 | 	// 		Version: "1.0.0",
127 | 	// 	}
128 | 
129 | 	// 	_, err = client.Initialize(ctx, initRequest)
130 | 	// 	if err != nil {
131 | 	// 		t.Fatalf("Failed to initialize: %v", err)
132 | 	// 	}
133 | 
134 | 	// 	// Subscribe to a resource to test notifications
135 | 	// 	subRequest := mcp.SubscribeRequest{}
136 | 	// 	subRequest.Params.URI = "test://resource"
137 | 	// 	if err := client.Subscribe(ctx, subRequest); err != nil {
138 | 	// 		t.Fatalf("Failed to subscribe: %v", err)
139 | 	// 	}
140 | 
141 | 	// 	select {
142 | 	// 	case <-notificationReceived:
143 | 	// 		// Success
144 | 	// 	case <-time.After(time.Second):
145 | 	// 		t.Error("Timeout waiting for notification")
146 | 	// 	}
147 | 	// })
148 | 
149 | 	t.Run("Handles errors properly", func(t *testing.T) {
150 | 		client, err := NewSSEMCPClient(testServer.URL + "/sse")
151 | 		if err != nil {
152 | 			t.Fatalf("Failed to create client: %v", err)
153 | 		}
154 | 		defer client.Close()
155 | 
156 | 		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
157 | 		defer cancel()
158 | 
159 | 		if err := client.Start(ctx); err != nil {
160 | 			t.Fatalf("Failed to start client: %v", err)
161 | 		}
162 | 
163 | 		// Try to make a request without initializing
164 | 		toolsRequest := mcp.ListToolsRequest{}
165 | 		_, err = client.ListTools(ctx, toolsRequest)
166 | 		if err == nil {
167 | 			t.Error("Expected error when making request before initialization")
168 | 		}
169 | 	})
170 | 
171 | 	// t.Run("Handles context cancellation", func(t *testing.T) {
172 | 	// 	client, err := NewSSEMCPClient(testServer.URL + "/sse")
173 | 	// 	if err != nil {
174 | 	// 		t.Fatalf("Failed to create client: %v", err)
175 | 	// 	}
176 | 	// 	defer client.Close()
177 | 
178 | 	// 	if err := client.Start(context.Background()); err != nil {
179 | 	// 		t.Fatalf("Failed to start client: %v", err)
180 | 	// 	}
181 | 
182 | 	// 	ctx, cancel := context.WithCancel(context.Background())
183 | 	// 	cancel() // Cancel immediately
184 | 
185 | 	// 	toolsRequest := mcp.ListToolsRequest{}
186 | 	// 	_, err = client.ListTools(ctx, toolsRequest)
187 | 	// 	if err == nil {
188 | 	// 		t.Error("Expected error when context is cancelled")
189 | 	// 	}
190 | 	// })
191 | 
192 | 	t.Run("CallTool", func(t *testing.T) {
193 | 		client, err := NewSSEMCPClient(testServer.URL + "/sse")
194 | 		if err != nil {
195 | 			t.Fatalf("Failed to create client: %v", err)
196 | 		}
197 | 		defer client.Close()
198 | 
199 | 		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
200 | 		defer cancel()
201 | 
202 | 		if err := client.Start(ctx); err != nil {
203 | 			t.Fatalf("Failed to start client: %v", err)
204 | 		}
205 | 
206 | 		// Initialize
207 | 		initRequest := mcp.InitializeRequest{}
208 | 		initRequest.Params.ProtocolVersion = mcp.LATEST_PROTOCOL_VERSION
209 | 		initRequest.Params.ClientInfo = mcp.Implementation{
210 | 			Name:    "test-client",
211 | 			Version: "1.0.0",
212 | 		}
213 | 
214 | 		_, err = client.Initialize(ctx, initRequest)
215 | 		if err != nil {
216 | 			t.Fatalf("Failed to initialize: %v", err)
217 | 		}
218 | 
219 | 		request := mcp.CallToolRequest{}
220 | 		request.Params.Name = "test-tool"
221 | 		request.Params.Arguments = map[string]interface{}{
222 | 			"parameter-1": "value1",
223 | 		}
224 | 
225 | 		result, err := client.CallTool(ctx, request)
226 | 		if err != nil {
227 | 			t.Fatalf("CallTool failed: %v", err)
228 | 		}
229 | 
230 | 		if len(result.Content) != 1 {
231 | 			t.Errorf("Expected 1 content item, got %d", len(result.Content))
232 | 		}
233 | 	})
234 | }
235 | 


--------------------------------------------------------------------------------
/client/stdio.go:
--------------------------------------------------------------------------------
  1 | package client
  2 | 
  3 | import (
  4 | 	"bufio"
  5 | 	"context"
  6 | 	"encoding/json"
  7 | 	"errors"
  8 | 	"fmt"
  9 | 	"io"
 10 | 	"os"
 11 | 	"os/exec"
 12 | 	"sync"
 13 | 	"sync/atomic"
 14 | 
 15 | 	"github.com/mark3labs/mcp-go/mcp"
 16 | )
 17 | 
 18 | // StdioMCPClient implements the MCPClient interface using stdio communication.
 19 | // It launches a subprocess and communicates with it via standard input/output streams
 20 | // using JSON-RPC messages. The client handles message routing between requests and
 21 | // responses, and supports asynchronous notifications.
 22 | type StdioMCPClient struct {
 23 | 	cmd           *exec.Cmd
 24 | 	stdin         io.WriteCloser
 25 | 	stdout        *bufio.Reader
 26 | 	stderr        io.ReadCloser
 27 | 	requestID     atomic.Int64
 28 | 	responses     map[int64]chan RPCResponse
 29 | 	mu            sync.RWMutex
 30 | 	done          chan struct{}
 31 | 	initialized   bool
 32 | 	notifications []func(mcp.JSONRPCNotification)
 33 | 	notifyMu      sync.RWMutex
 34 | 	capabilities  mcp.ServerCapabilities
 35 | }
 36 | 
 37 | // NewStdioMCPClient creates a new stdio-based MCP client that communicates with a subprocess.
 38 | // It launches the specified command with given arguments and sets up stdin/stdout pipes for communication.
 39 | // Returns an error if the subprocess cannot be started or the pipes cannot be created.
 40 | func NewStdioMCPClient(
 41 | 	command string,
 42 | 	env []string,
 43 | 	args ...string,
 44 | ) (*StdioMCPClient, error) {
 45 | 	cmd := exec.Command(command, args...)
 46 | 
 47 | 	mergedEnv := os.Environ()
 48 | 	mergedEnv = append(mergedEnv, env...)
 49 | 
 50 | 	cmd.Env = mergedEnv
 51 | 
 52 | 	stdin, err := cmd.StdinPipe()
 53 | 	if err != nil {
 54 | 		return nil, fmt.Errorf("failed to create stdin pipe: %w", err)
 55 | 	}
 56 | 
 57 | 	stdout, err := cmd.StdoutPipe()
 58 | 	if err != nil {
 59 | 		return nil, fmt.Errorf("failed to create stdout pipe: %w", err)
 60 | 	}
 61 | 
 62 | 	stderr, err := cmd.StderrPipe()
 63 | 	if err != nil {
 64 | 		return nil, fmt.Errorf("failed to create stderr pipe: %w", err)
 65 | 	}
 66 | 
 67 | 	client := &StdioMCPClient{
 68 | 		cmd:       cmd,
 69 | 		stdin:     stdin,
 70 | 		stderr:    stderr,
 71 | 		stdout:    bufio.NewReader(stdout),
 72 | 		responses: make(map[int64]chan RPCResponse),
 73 | 		done:      make(chan struct{}),
 74 | 	}
 75 | 
 76 | 	if err := cmd.Start(); err != nil {
 77 | 		return nil, fmt.Errorf("failed to start command: %w", err)
 78 | 	}
 79 | 
 80 | 	// Start reading responses in a goroutine and wait for it to be ready
 81 | 	ready := make(chan struct{})
 82 | 	go func() {
 83 | 		close(ready)
 84 | 		client.readResponses()
 85 | 	}()
 86 | 	<-ready
 87 | 
 88 | 	return client, nil
 89 | }
 90 | 
 91 | // Close shuts down the stdio client, closing the stdin pipe and waiting for the subprocess to exit.
 92 | // Returns an error if there are issues closing stdin or waiting for the subprocess to terminate.
 93 | func (c *StdioMCPClient) Close() error {
 94 | 	close(c.done)
 95 | 	if err := c.stdin.Close(); err != nil {
 96 | 		return fmt.Errorf("failed to close stdin: %w", err)
 97 | 	}
 98 | 	if err := c.stderr.Close(); err != nil {
 99 | 		return fmt.Errorf("failed to close stderr: %w", err)
100 | 	}
101 | 	return c.cmd.Wait()
102 | }
103 | 
104 | // Stderr returns a reader for the stderr output of the subprocess.
105 | // This can be used to capture error messages or logs from the subprocess.
106 | func (c *StdioMCPClient) Stderr() io.Reader {
107 | 	return c.stderr
108 | }
109 | 
110 | // OnNotification registers a handler function to be called when notifications are received.
111 | // Multiple handlers can be registered and will be called in the order they were added.
112 | func (c *StdioMCPClient) OnNotification(
113 | 	handler func(notification mcp.JSONRPCNotification),
114 | ) {
115 | 	c.notifyMu.Lock()
116 | 	defer c.notifyMu.Unlock()
117 | 	c.notifications = append(c.notifications, handler)
118 | }
119 | 
120 | // readResponses continuously reads and processes responses from the server's stdout.
121 | // It handles both responses to requests and notifications, routing them appropriately.
122 | // Runs until the done channel is closed or an error occurs reading from stdout.
123 | func (c *StdioMCPClient) readResponses() {
124 | 	for {
125 | 		select {
126 | 		case <-c.done:
127 | 			return
128 | 		default:
129 | 			line, err := c.stdout.ReadString('\n')
130 | 			if err != nil {
131 | 				if err != io.EOF {
132 | 					fmt.Printf("Error reading response: %v\n", err)
133 | 				}
134 | 				return
135 | 			}
136 | 
137 | 			var baseMessage struct {
138 | 				JSONRPC string          `json:"jsonrpc"`
139 | 				ID      *int64          `json:"id,omitempty"`
140 | 				Method  string          `json:"method,omitempty"`
141 | 				Result  json.RawMessage `json:"result,omitempty"`
142 | 				Error   *struct {
143 | 					Code    int    `json:"code"`
144 | 					Message string `json:"message"`
145 | 				} `json:"error,omitempty"`
146 | 			}
147 | 
148 | 			if err := json.Unmarshal([]byte(line), &baseMessage); err != nil {
149 | 				continue
150 | 			}
151 | 
152 | 			// Handle notification
153 | 			if baseMessage.ID == nil {
154 | 				var notification mcp.JSONRPCNotification
155 | 				if err := json.Unmarshal([]byte(line), &notification); err != nil {
156 | 					continue
157 | 				}
158 | 				c.notifyMu.RLock()
159 | 				for _, handler := range c.notifications {
160 | 					handler(notification)
161 | 				}
162 | 				c.notifyMu.RUnlock()
163 | 				continue
164 | 			}
165 | 
166 | 			c.mu.RLock()
167 | 			ch, ok := c.responses[*baseMessage.ID]
168 | 			c.mu.RUnlock()
169 | 
170 | 			if ok {
171 | 				if baseMessage.Error != nil {
172 | 					ch <- RPCResponse{
173 | 						Error: &baseMessage.Error.Message,
174 | 					}
175 | 				} else {
176 | 					ch <- RPCResponse{
177 | 						Response: &baseMessage.Result,
178 | 					}
179 | 				}
180 | 				c.mu.Lock()
181 | 				delete(c.responses, *baseMessage.ID)
182 | 				c.mu.Unlock()
183 | 			}
184 | 		}
185 | 	}
186 | }
187 | 
188 | // sendRequest sends a JSON-RPC request to the server and waits for a response.
189 | // It creates a unique request ID, sends the request over stdin, and waits for
190 | // the corresponding response or context cancellation.
191 | // Returns the raw JSON response message or an error if the request fails.
192 | func (c *StdioMCPClient) sendRequest(
193 | 	ctx context.Context,
194 | 	method string,
195 | 	params interface{},
196 | ) (*json.RawMessage, error) {
197 | 	if !c.initialized && method != "initialize" {
198 | 		return nil, fmt.Errorf("client not initialized")
199 | 	}
200 | 
201 | 	id := c.requestID.Add(1)
202 | 
203 | 	// Create the complete request structure
204 | 	request := mcp.JSONRPCRequest{
205 | 		JSONRPC: mcp.JSONRPC_VERSION,
206 | 		ID:      id,
207 | 		Request: mcp.Request{
208 | 			Method: method,
209 | 		},
210 | 		Params: params,
211 | 	}
212 | 
213 | 	responseChan := make(chan RPCResponse, 1)
214 | 	c.mu.Lock()
215 | 	c.responses[id] = responseChan
216 | 	c.mu.Unlock()
217 | 
218 | 	requestBytes, err := json.Marshal(request)
219 | 	if err != nil {
220 | 		return nil, fmt.Errorf("failed to marshal request: %w", err)
221 | 	}
222 | 	requestBytes = append(requestBytes, '\n')
223 | 
224 | 	if _, err := c.stdin.Write(requestBytes); err != nil {
225 | 		return nil, fmt.Errorf("failed to write request: %w", err)
226 | 	}
227 | 
228 | 	select {
229 | 	case <-ctx.Done():
230 | 		c.mu.Lock()
231 | 		delete(c.responses, id)
232 | 		c.mu.Unlock()
233 | 		return nil, ctx.Err()
234 | 	case response := <-responseChan:
235 | 		if response.Error != nil {
236 | 			return nil, errors.New(*response.Error)
237 | 		}
238 | 		return response.Response, nil
239 | 	}
240 | }
241 | 
242 | func (c *StdioMCPClient) Ping(ctx context.Context) error {
243 | 	_, err := c.sendRequest(ctx, "ping", nil)
244 | 	return err
245 | }
246 | 
247 | func (c *StdioMCPClient) Initialize(
248 | 	ctx context.Context,
249 | 	request mcp.InitializeRequest,
250 | ) (*mcp.InitializeResult, error) {
251 | 	// This structure ensures Capabilities is always included in JSON
252 | 	params := struct {
253 | 		ProtocolVersion string                 `json:"protocolVersion"`
254 | 		ClientInfo      mcp.Implementation     `json:"clientInfo"`
255 | 		Capabilities    mcp.ClientCapabilities `json:"capabilities"`
256 | 	}{
257 | 		ProtocolVersion: request.Params.ProtocolVersion,
258 | 		ClientInfo:      request.Params.ClientInfo,
259 | 		Capabilities:    request.Params.Capabilities, // Will be empty struct if not set
260 | 	}
261 | 
262 | 	response, err := c.sendRequest(ctx, "initialize", params)
263 | 	if err != nil {
264 | 		return nil, err
265 | 	}
266 | 
267 | 	var result mcp.InitializeResult
268 | 	if err := json.Unmarshal(*response, &result); err != nil {
269 | 		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
270 | 	}
271 | 
272 | 	// Store capabilities
273 | 	c.capabilities = result.Capabilities
274 | 
275 | 	// Send initialized notification
276 | 	notification := mcp.JSONRPCNotification{
277 | 		JSONRPC: mcp.JSONRPC_VERSION,
278 | 		Notification: mcp.Notification{
279 | 			Method: "notifications/initialized",
280 | 		},
281 | 	}
282 | 
283 | 	notificationBytes, err := json.Marshal(notification)
284 | 	if err != nil {
285 | 		return nil, fmt.Errorf(
286 | 			"failed to marshal initialized notification: %w",
287 | 			err,
288 | 		)
289 | 	}
290 | 	notificationBytes = append(notificationBytes, '\n')
291 | 
292 | 	if _, err := c.stdin.Write(notificationBytes); err != nil {
293 | 		return nil, fmt.Errorf(
294 | 			"failed to send initialized notification: %w",
295 | 			err,
296 | 		)
297 | 	}
298 | 
299 | 	c.initialized = true
300 | 	return &result, nil
301 | }
302 | 
303 | func (c *StdioMCPClient) ListResources(
304 | 	ctx context.Context,
305 | 	request mcp.ListResourcesRequest,
306 | ) (*mcp.
307 | 	ListResourcesResult, error) {
308 | 	response, err := c.sendRequest(
309 | 		ctx,
310 | 		"resources/list",
311 | 		request.Params,
312 | 	)
313 | 	if err != nil {
314 | 		return nil, err
315 | 	}
316 | 
317 | 	var result mcp.ListResourcesResult
318 | 	if err := json.Unmarshal(*response, &result); err != nil {
319 | 		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
320 | 	}
321 | 
322 | 	return &result, nil
323 | }
324 | 
325 | func (c *StdioMCPClient) ListResourceTemplates(
326 | 	ctx context.Context,
327 | 	request mcp.ListResourceTemplatesRequest,
328 | ) (*mcp.
329 | 	ListResourceTemplatesResult, error) {
330 | 	response, err := c.sendRequest(
331 | 		ctx,
332 | 		"resources/templates/list",
333 | 		request.Params,
334 | 	)
335 | 	if err != nil {
336 | 		return nil, err
337 | 	}
338 | 
339 | 	var result mcp.ListResourceTemplatesResult
340 | 	if err := json.Unmarshal(*response, &result); err != nil {
341 | 		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
342 | 	}
343 | 
344 | 	return &result, nil
345 | }
346 | 
347 | func (c *StdioMCPClient) ReadResource(
348 | 	ctx context.Context,
349 | 	request mcp.ReadResourceRequest,
350 | ) (*mcp.ReadResourceResult,
351 | 	error) {
352 | 	response, err := c.sendRequest(ctx, "resources/read", request.Params)
353 | 	if err != nil {
354 | 		return nil, err
355 | 	}
356 | 
357 | 	return mcp.ParseReadResourceResult(response)
358 | }
359 | 
360 | func (c *StdioMCPClient) Subscribe(
361 | 	ctx context.Context,
362 | 	request mcp.SubscribeRequest,
363 | ) error {
364 | 	_, err := c.sendRequest(ctx, "resources/subscribe", request.Params)
365 | 	return err
366 | }
367 | 
368 | func (c *StdioMCPClient) Unsubscribe(
369 | 	ctx context.Context,
370 | 	request mcp.UnsubscribeRequest,
371 | ) error {
372 | 	_, err := c.sendRequest(ctx, "resources/unsubscribe", request.Params)
373 | 	return err
374 | }
375 | 
376 | func (c *StdioMCPClient) ListPrompts(
377 | 	ctx context.Context,
378 | 	request mcp.ListPromptsRequest,
379 | ) (*mcp.ListPromptsResult, error) {
380 | 	response, err := c.sendRequest(ctx, "prompts/list", request.Params)
381 | 	if err != nil {
382 | 		return nil, err
383 | 	}
384 | 
385 | 	var result mcp.ListPromptsResult
386 | 	if err := json.Unmarshal(*response, &result); err != nil {
387 | 		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
388 | 	}
389 | 
390 | 	return &result, nil
391 | }
392 | 
393 | func (c *StdioMCPClient) GetPrompt(
394 | 	ctx context.Context,
395 | 	request mcp.GetPromptRequest,
396 | ) (*mcp.GetPromptResult, error) {
397 | 	response, err := c.sendRequest(ctx, "prompts/get", request.Params)
398 | 	if err != nil {
399 | 		return nil, err
400 | 	}
401 | 
402 | 	return mcp.ParseGetPromptResult(response)
403 | }
404 | 
405 | func (c *StdioMCPClient) ListTools(
406 | 	ctx context.Context,
407 | 	request mcp.ListToolsRequest,
408 | ) (*mcp.ListToolsResult, error) {
409 | 	response, err := c.sendRequest(ctx, "tools/list", request.Params)
410 | 	if err != nil {
411 | 		return nil, err
412 | 	}
413 | 
414 | 	var result mcp.ListToolsResult
415 | 	if err := json.Unmarshal(*response, &result); err != nil {
416 | 		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
417 | 	}
418 | 
419 | 	return &result, nil
420 | }
421 | 
422 | func (c *StdioMCPClient) CallTool(
423 | 	ctx context.Context,
424 | 	request mcp.CallToolRequest,
425 | ) (*mcp.CallToolResult, error) {
426 | 	response, err := c.sendRequest(ctx, "tools/call", request.Params)
427 | 	if err != nil {
428 | 		return nil, err
429 | 	}
430 | 
431 | 	return mcp.ParseCallToolResult(response)
432 | }
433 | 
434 | func (c *StdioMCPClient) SetLevel(
435 | 	ctx context.Context,
436 | 	request mcp.SetLevelRequest,
437 | ) error {
438 | 	_, err := c.sendRequest(ctx, "logging/setLevel", request.Params)
439 | 	return err
440 | }
441 | 
442 | func (c *StdioMCPClient) Complete(
443 | 	ctx context.Context,
444 | 	request mcp.CompleteRequest,
445 | ) (*mcp.CompleteResult, error) {
446 | 	response, err := c.sendRequest(ctx, "completion/complete", request.Params)
447 | 	if err != nil {
448 | 		return nil, err
449 | 	}
450 | 
451 | 	var result mcp.CompleteResult
452 | 	if err := json.Unmarshal(*response, &result); err != nil {
453 | 		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
454 | 	}
455 | 
456 | 	return &result, nil
457 | }
458 | 


--------------------------------------------------------------------------------
/client/stdio_test.go:
--------------------------------------------------------------------------------
  1 | package client
  2 | 
  3 | import (
  4 | 	"context"
  5 | 	"encoding/json"
  6 | 	"fmt"
  7 | 	"log/slog"
  8 | 	"os"
  9 | 	"os/exec"
 10 | 	"path/filepath"
 11 | 	"sync"
 12 | 	"testing"
 13 | 	"time"
 14 | 
 15 | 	"github.com/mark3labs/mcp-go/mcp"
 16 | )
 17 | 
 18 | func compileTestServer(outputPath string) error {
 19 | 	cmd := exec.Command(
 20 | 		"go",
 21 | 		"build",
 22 | 		"-o",
 23 | 		outputPath,
 24 | 		"../testdata/mockstdio_server.go",
 25 | 	)
 26 | 	if output, err := cmd.CombinedOutput(); err != nil {
 27 | 		return fmt.Errorf("compilation failed: %v\nOutput: %s", err, output)
 28 | 	}
 29 | 	return nil
 30 | }
 31 | 
 32 | func TestStdioMCPClient(t *testing.T) {
 33 | 	// Compile mock server
 34 | 	mockServerPath := filepath.Join(os.TempDir(), "mockstdio_server")
 35 | 	if err := compileTestServer(mockServerPath); err != nil {
 36 | 		t.Fatalf("Failed to compile mock server: %v", err)
 37 | 	}
 38 | 	defer os.Remove(mockServerPath)
 39 | 
 40 | 	client, err := NewStdioMCPClient(mockServerPath, []string{})
 41 | 	if err != nil {
 42 | 		t.Fatalf("Failed to create client: %v", err)
 43 | 	}
 44 | 	var logRecords []map[string]any
 45 | 	var logRecordsMu sync.RWMutex
 46 | 	var wg sync.WaitGroup
 47 | 	wg.Add(1)
 48 | 	go func() {
 49 | 		defer wg.Done()
 50 | 		dec := json.NewDecoder(client.Stderr())
 51 | 		for {
 52 | 			var record map[string]any
 53 | 			if err := dec.Decode(&record); err != nil {
 54 | 				return
 55 | 			}
 56 | 			logRecordsMu.Lock()
 57 | 			logRecords = append(logRecords, record)
 58 | 			logRecordsMu.Unlock()
 59 | 		}
 60 | 	}()
 61 | 
 62 | 	t.Run("Initialize", func(t *testing.T) {
 63 | 		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
 64 | 		defer cancel()
 65 | 
 66 | 		request := mcp.InitializeRequest{}
 67 | 		request.Params.ProtocolVersion = "1.0"
 68 | 		request.Params.ClientInfo = mcp.Implementation{
 69 | 			Name:    "test-client",
 70 | 			Version: "1.0.0",
 71 | 		}
 72 | 		request.Params.Capabilities = mcp.ClientCapabilities{
 73 | 			Roots: &struct {
 74 | 				ListChanged bool `json:"listChanged,omitempty"`
 75 | 			}{
 76 | 				ListChanged: true,
 77 | 			},
 78 | 		}
 79 | 
 80 | 		result, err := client.Initialize(ctx, request)
 81 | 		if err != nil {
 82 | 			t.Fatalf("Initialize failed: %v", err)
 83 | 		}
 84 | 
 85 | 		if result.ServerInfo.Name != "mock-server" {
 86 | 			t.Errorf(
 87 | 				"Expected server name 'mock-server', got '%s'",
 88 | 				result.ServerInfo.Name,
 89 | 			)
 90 | 		}
 91 | 	})
 92 | 
 93 | 	t.Run("Ping", func(t *testing.T) {
 94 | 		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
 95 | 		defer cancel()
 96 | 
 97 | 		err := client.Ping(ctx)
 98 | 		if err != nil {
 99 | 			t.Errorf("Ping failed: %v", err)
100 | 		}
101 | 	})
102 | 
103 | 	t.Run("ListResources", func(t *testing.T) {
104 | 		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
105 | 		defer cancel()
106 | 
107 | 		request := mcp.ListResourcesRequest{}
108 | 		result, err := client.ListResources(ctx, request)
109 | 		if err != nil {
110 | 			t.Errorf("ListResources failed: %v", err)
111 | 		}
112 | 
113 | 		if len(result.Resources) != 1 {
114 | 			t.Errorf("Expected 1 resource, got %d", len(result.Resources))
115 | 		}
116 | 	})
117 | 
118 | 	t.Run("ReadResource", func(t *testing.T) {
119 | 		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
120 | 		defer cancel()
121 | 
122 | 		request := mcp.ReadResourceRequest{}
123 | 		request.Params.URI = "test://resource"
124 | 
125 | 		result, err := client.ReadResource(ctx, request)
126 | 		if err != nil {
127 | 			t.Errorf("ReadResource failed: %v", err)
128 | 		}
129 | 
130 | 		if len(result.Contents) != 1 {
131 | 			t.Errorf("Expected 1 content item, got %d", len(result.Contents))
132 | 		}
133 | 	})
134 | 
135 | 	t.Run("Subscribe and Unsubscribe", func(t *testing.T) {
136 | 		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
137 | 		defer cancel()
138 | 
139 | 		// Test Subscribe
140 | 		subRequest := mcp.SubscribeRequest{}
141 | 		subRequest.Params.URI = "test://resource"
142 | 		err := client.Subscribe(ctx, subRequest)
143 | 		if err != nil {
144 | 			t.Errorf("Subscribe failed: %v", err)
145 | 		}
146 | 
147 | 		// Test Unsubscribe
148 | 		unsubRequest := mcp.UnsubscribeRequest{}
149 | 		unsubRequest.Params.URI = "test://resource"
150 | 		err = client.Unsubscribe(ctx, unsubRequest)
151 | 		if err != nil {
152 | 			t.Errorf("Unsubscribe failed: %v", err)
153 | 		}
154 | 	})
155 | 
156 | 	t.Run("ListPrompts", func(t *testing.T) {
157 | 		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
158 | 		defer cancel()
159 | 
160 | 		request := mcp.ListPromptsRequest{}
161 | 		result, err := client.ListPrompts(ctx, request)
162 | 		if err != nil {
163 | 			t.Errorf("ListPrompts failed: %v", err)
164 | 		}
165 | 
166 | 		if len(result.Prompts) != 1 {
167 | 			t.Errorf("Expected 1 prompt, got %d", len(result.Prompts))
168 | 		}
169 | 	})
170 | 
171 | 	t.Run("GetPrompt", func(t *testing.T) {
172 | 		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
173 | 		defer cancel()
174 | 
175 | 		request := mcp.GetPromptRequest{}
176 | 		request.Params.Name = "test-prompt"
177 | 
178 | 		result, err := client.GetPrompt(ctx, request)
179 | 		if err != nil {
180 | 			t.Errorf("GetPrompt failed: %v", err)
181 | 		}
182 | 
183 | 		if len(result.Messages) != 1 {
184 | 			t.Errorf("Expected 1 message, got %d", len(result.Messages))
185 | 		}
186 | 	})
187 | 
188 | 	t.Run("ListTools", func(t *testing.T) {
189 | 		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
190 | 		defer cancel()
191 | 
192 | 		request := mcp.ListToolsRequest{}
193 | 		result, err := client.ListTools(ctx, request)
194 | 		if err != nil {
195 | 			t.Errorf("ListTools failed: %v", err)
196 | 		}
197 | 
198 | 		if len(result.Tools) != 1 {
199 | 			t.Errorf("Expected 1 tool, got %d", len(result.Tools))
200 | 		}
201 | 	})
202 | 
203 | 	t.Run("CallTool", func(t *testing.T) {
204 | 		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
205 | 		defer cancel()
206 | 
207 | 		request := mcp.CallToolRequest{}
208 | 		request.Params.Name = "test-tool"
209 | 		request.Params.Arguments = map[string]interface{}{
210 | 			"param1": "value1",
211 | 		}
212 | 
213 | 		result, err := client.CallTool(ctx, request)
214 | 		if err != nil {
215 | 			t.Errorf("CallTool failed: %v", err)
216 | 		}
217 | 
218 | 		if len(result.Content) != 1 {
219 | 			t.Errorf("Expected 1 content item, got %d", len(result.Content))
220 | 		}
221 | 	})
222 | 
223 | 	t.Run("SetLevel", func(t *testing.T) {
224 | 		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
225 | 		defer cancel()
226 | 
227 | 		request := mcp.SetLevelRequest{}
228 | 		request.Params.Level = mcp.LoggingLevelInfo
229 | 
230 | 		err := client.SetLevel(ctx, request)
231 | 		if err != nil {
232 | 			t.Errorf("SetLevel failed: %v", err)
233 | 		}
234 | 	})
235 | 
236 | 	t.Run("Complete", func(t *testing.T) {
237 | 		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
238 | 		defer cancel()
239 | 
240 | 		request := mcp.CompleteRequest{}
241 | 		request.Params.Ref = mcp.PromptReference{
242 | 			Type: "ref/prompt",
243 | 			Name: "test-prompt",
244 | 		}
245 | 		request.Params.Argument.Name = "test-arg"
246 | 		request.Params.Argument.Value = "test-value"
247 | 
248 | 		result, err := client.Complete(ctx, request)
249 | 		if err != nil {
250 | 			t.Errorf("Complete failed: %v", err)
251 | 		}
252 | 
253 | 		if len(result.Completion.Values) != 1 {
254 | 			t.Errorf(
255 | 				"Expected 1 completion value, got %d",
256 | 				len(result.Completion.Values),
257 | 			)
258 | 		}
259 | 	})
260 | 
261 | 	client.Close()
262 | 	wg.Wait()
263 | 
264 | 	t.Run("CheckLogs", func(t *testing.T) {
265 | 		logRecordsMu.RLock()
266 | 		defer logRecordsMu.RUnlock()
267 | 
268 | 		if len(logRecords) != 1 {
269 | 			t.Errorf("Expected 1 log record, got %d", len(logRecords))
270 | 			return
271 | 		}
272 | 
273 | 		msg, ok := logRecords[0][slog.MessageKey].(string)
274 | 		if !ok {
275 | 			t.Errorf("Expected log record to have message key")
276 | 		}
277 | 		if msg != "launch successful" {
278 | 			t.Errorf("Expected log message 'launch successful', got '%s'", msg)
279 | 		}
280 | 	})
281 | }
282 | 


--------------------------------------------------------------------------------
/client/types.go:
--------------------------------------------------------------------------------
1 | package client
2 | 
3 | import "encoding/json"
4 | 
5 | type RPCResponse struct {
6 | 	Error    *string
7 | 	Response *json.RawMessage
8 | }
9 | 


--------------------------------------------------------------------------------