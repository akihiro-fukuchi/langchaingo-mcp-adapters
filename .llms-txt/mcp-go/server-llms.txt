└── server
    ├── hooks.go
    ├── internal
        └── gen
        │   ├── data.go
        │   └── main.go
    ├── request_handler.go
    ├── server.go
    ├── server_test.go
    ├── sse.go
    ├── sse_test.go
    ├── stdio.go
    └── stdio_test.go


/server/hooks.go:
--------------------------------------------------------------------------------
  1 | // Code generated by `go generate`. DO NOT EDIT.
  2 | // source: server/internal/gen/hooks.go.tmpl
  3 | package server
  4 | 
  5 | import (
  6 | 	"context"
  7 | 
  8 | 	"github.com/mark3labs/mcp-go/mcp"
  9 | )
 10 | 
 11 | // OnRegisterSessionHookFunc is a hook that will be called when a new session is registered.
 12 | type OnRegisterSessionHookFunc func(ctx context.Context, session ClientSession)
 13 | 
 14 | // BeforeAnyHookFunc is a function that is called after the request is
 15 | // parsed but before the method is called.
 16 | type BeforeAnyHookFunc func(ctx context.Context, id any, method mcp.MCPMethod, message any)
 17 | 
 18 | // OnSuccessHookFunc is a hook that will be called after the request
 19 | // successfully generates a result, but before the result is sent to the client.
 20 | type OnSuccessHookFunc func(ctx context.Context, id any, method mcp.MCPMethod, message any, result any)
 21 | 
 22 | // OnErrorHookFunc is a hook that will be called when an error occurs,
 23 | // either during the request parsing or the method execution.
 24 | //
 25 | // Example usage:
 26 | // ```
 27 | //
 28 | //	hooks.AddOnError(func(ctx context.Context, id any, method mcp.MCPMethod, message any, err error) {
 29 | //	  // Check for specific error types using errors.Is
 30 | //	  if errors.Is(err, ErrUnsupported) {
 31 | //	    // Handle capability not supported errors
 32 | //	    log.Printf("Capability not supported: %v", err)
 33 | //	  }
 34 | //
 35 | //	  // Use errors.As to get specific error types
 36 | //	  var parseErr = &UnparseableMessageError{}
 37 | //	  if errors.As(err, &parseErr) {
 38 | //	    // Access specific methods/fields of the error type
 39 | //	    log.Printf("Failed to parse message for method %s: %v",
 40 | //	               parseErr.GetMethod(), parseErr.Unwrap())
 41 | //	    // Access the raw message that failed to parse
 42 | //	    rawMsg := parseErr.GetMessage()
 43 | //	  }
 44 | //
 45 | //	  // Check for specific resource/prompt/tool errors
 46 | //	  switch {
 47 | //	  case errors.Is(err, ErrResourceNotFound):
 48 | //	    log.Printf("Resource not found: %v", err)
 49 | //	  case errors.Is(err, ErrPromptNotFound):
 50 | //	    log.Printf("Prompt not found: %v", err)
 51 | //	  case errors.Is(err, ErrToolNotFound):
 52 | //	    log.Printf("Tool not found: %v", err)
 53 | //	  }
 54 | //	})
 55 | type OnErrorHookFunc func(ctx context.Context, id any, method mcp.MCPMethod, message any, err error)
 56 | 
 57 | type OnBeforeInitializeFunc func(ctx context.Context, id any, message *mcp.InitializeRequest)
 58 | type OnAfterInitializeFunc func(ctx context.Context, id any, message *mcp.InitializeRequest, result *mcp.InitializeResult)
 59 | 
 60 | type OnBeforePingFunc func(ctx context.Context, id any, message *mcp.PingRequest)
 61 | type OnAfterPingFunc func(ctx context.Context, id any, message *mcp.PingRequest, result *mcp.EmptyResult)
 62 | 
 63 | type OnBeforeListResourcesFunc func(ctx context.Context, id any, message *mcp.ListResourcesRequest)
 64 | type OnAfterListResourcesFunc func(ctx context.Context, id any, message *mcp.ListResourcesRequest, result *mcp.ListResourcesResult)
 65 | 
 66 | type OnBeforeListResourceTemplatesFunc func(ctx context.Context, id any, message *mcp.ListResourceTemplatesRequest)
 67 | type OnAfterListResourceTemplatesFunc func(ctx context.Context, id any, message *mcp.ListResourceTemplatesRequest, result *mcp.ListResourceTemplatesResult)
 68 | 
 69 | type OnBeforeReadResourceFunc func(ctx context.Context, id any, message *mcp.ReadResourceRequest)
 70 | type OnAfterReadResourceFunc func(ctx context.Context, id any, message *mcp.ReadResourceRequest, result *mcp.ReadResourceResult)
 71 | 
 72 | type OnBeforeListPromptsFunc func(ctx context.Context, id any, message *mcp.ListPromptsRequest)
 73 | type OnAfterListPromptsFunc func(ctx context.Context, id any, message *mcp.ListPromptsRequest, result *mcp.ListPromptsResult)
 74 | 
 75 | type OnBeforeGetPromptFunc func(ctx context.Context, id any, message *mcp.GetPromptRequest)
 76 | type OnAfterGetPromptFunc func(ctx context.Context, id any, message *mcp.GetPromptRequest, result *mcp.GetPromptResult)
 77 | 
 78 | type OnBeforeListToolsFunc func(ctx context.Context, id any, message *mcp.ListToolsRequest)
 79 | type OnAfterListToolsFunc func(ctx context.Context, id any, message *mcp.ListToolsRequest, result *mcp.ListToolsResult)
 80 | 
 81 | type OnBeforeCallToolFunc func(ctx context.Context, id any, message *mcp.CallToolRequest)
 82 | type OnAfterCallToolFunc func(ctx context.Context, id any, message *mcp.CallToolRequest, result *mcp.CallToolResult)
 83 | 
 84 | type Hooks struct {
 85 | 	OnRegisterSession             []OnRegisterSessionHookFunc
 86 | 	OnBeforeAny                   []BeforeAnyHookFunc
 87 | 	OnSuccess                     []OnSuccessHookFunc
 88 | 	OnError                       []OnErrorHookFunc
 89 | 	OnBeforeInitialize            []OnBeforeInitializeFunc
 90 | 	OnAfterInitialize             []OnAfterInitializeFunc
 91 | 	OnBeforePing                  []OnBeforePingFunc
 92 | 	OnAfterPing                   []OnAfterPingFunc
 93 | 	OnBeforeListResources         []OnBeforeListResourcesFunc
 94 | 	OnAfterListResources          []OnAfterListResourcesFunc
 95 | 	OnBeforeListResourceTemplates []OnBeforeListResourceTemplatesFunc
 96 | 	OnAfterListResourceTemplates  []OnAfterListResourceTemplatesFunc
 97 | 	OnBeforeReadResource          []OnBeforeReadResourceFunc
 98 | 	OnAfterReadResource           []OnAfterReadResourceFunc
 99 | 	OnBeforeListPrompts           []OnBeforeListPromptsFunc
100 | 	OnAfterListPrompts            []OnAfterListPromptsFunc
101 | 	OnBeforeGetPrompt             []OnBeforeGetPromptFunc
102 | 	OnAfterGetPrompt              []OnAfterGetPromptFunc
103 | 	OnBeforeListTools             []OnBeforeListToolsFunc
104 | 	OnAfterListTools              []OnAfterListToolsFunc
105 | 	OnBeforeCallTool              []OnBeforeCallToolFunc
106 | 	OnAfterCallTool               []OnAfterCallToolFunc
107 | }
108 | 
109 | func (c *Hooks) AddBeforeAny(hook BeforeAnyHookFunc) {
110 | 	c.OnBeforeAny = append(c.OnBeforeAny, hook)
111 | }
112 | 
113 | func (c *Hooks) AddOnSuccess(hook OnSuccessHookFunc) {
114 | 	c.OnSuccess = append(c.OnSuccess, hook)
115 | }
116 | 
117 | // AddOnError registers a hook function that will be called when an error occurs.
118 | // The error parameter contains the actual error object, which can be interrogated
119 | // using Go's error handling patterns like errors.Is and errors.As.
120 | //
121 | // Example:
122 | // ```
123 | // // Create a channel to receive errors for testing
124 | // errChan := make(chan error, 1)
125 | //
126 | // // Register hook to capture and inspect errors
127 | // hooks := &Hooks{}
128 | //
129 | //	hooks.AddOnError(func(ctx context.Context, id any, method mcp.MCPMethod, message any, err error) {
130 | //	    // For capability-related errors
131 | //	    if errors.Is(err, ErrUnsupported) {
132 | //	        // Handle capability not supported
133 | //	        errChan <- err
134 | //	        return
135 | //	    }
136 | //
137 | //	    // For parsing errors
138 | //	    var parseErr = &UnparseableMessageError{}
139 | //	    if errors.As(err, &parseErr) {
140 | //	        // Handle unparseable message errors
141 | //	        fmt.Printf("Failed to parse %s request: %v\n",
142 | //	                   parseErr.GetMethod(), parseErr.Unwrap())
143 | //	        errChan <- parseErr
144 | //	        return
145 | //	    }
146 | //
147 | //	    // For resource/prompt/tool not found errors
148 | //	    if errors.Is(err, ErrResourceNotFound) ||
149 | //	       errors.Is(err, ErrPromptNotFound) ||
150 | //	       errors.Is(err, ErrToolNotFound) {
151 | //	        // Handle not found errors
152 | //	        errChan <- err
153 | //	        return
154 | //	    }
155 | //
156 | //	    // For other errors
157 | //	    errChan <- err
158 | //	})
159 | //
160 | // server := NewMCPServer("test-server", "1.0.0", WithHooks(hooks))
161 | // ```
162 | func (c *Hooks) AddOnError(hook OnErrorHookFunc) {
163 | 	c.OnError = append(c.OnError, hook)
164 | }
165 | 
166 | func (c *Hooks) beforeAny(ctx context.Context, id any, method mcp.MCPMethod, message any) {
167 | 	if c == nil {
168 | 		return
169 | 	}
170 | 	for _, hook := range c.OnBeforeAny {
171 | 		hook(ctx, id, method, message)
172 | 	}
173 | }
174 | 
175 | func (c *Hooks) onSuccess(ctx context.Context, id any, method mcp.MCPMethod, message any, result any) {
176 | 	if c == nil {
177 | 		return
178 | 	}
179 | 	for _, hook := range c.OnSuccess {
180 | 		hook(ctx, id, method, message, result)
181 | 	}
182 | }
183 | 
184 | // onError calls all registered error hooks with the error object.
185 | // The err parameter contains the actual error that occurred, which implements
186 | // the standard error interface and may be a wrapped error or custom error type.
187 | //
188 | // This allows consumer code to use Go's error handling patterns:
189 | // - errors.Is(err, ErrUnsupported) to check for specific sentinel errors
190 | // - errors.As(err, &customErr) to extract custom error types
191 | //
192 | // Common error types include:
193 | // - ErrUnsupported: When a capability is not enabled
194 | // - UnparseableMessageError: When request parsing fails
195 | // - ErrResourceNotFound: When a resource is not found
196 | // - ErrPromptNotFound: When a prompt is not found
197 | // - ErrToolNotFound: When a tool is not found
198 | func (c *Hooks) onError(ctx context.Context, id any, method mcp.MCPMethod, message any, err error) {
199 | 	if c == nil {
200 | 		return
201 | 	}
202 | 	for _, hook := range c.OnError {
203 | 		hook(ctx, id, method, message, err)
204 | 	}
205 | }
206 | 
207 | func (c *Hooks) AddOnRegisterSession(hook OnRegisterSessionHookFunc) {
208 | 	c.OnRegisterSession = append(c.OnRegisterSession, hook)
209 | }
210 | 
211 | func (c *Hooks) RegisterSession(ctx context.Context, session ClientSession) {
212 | 	if c == nil {
213 | 		return
214 | 	}
215 | 	for _, hook := range c.OnRegisterSession {
216 | 		hook(ctx, session)
217 | 	}
218 | }
219 | func (c *Hooks) AddBeforeInitialize(hook OnBeforeInitializeFunc) {
220 | 	c.OnBeforeInitialize = append(c.OnBeforeInitialize, hook)
221 | }
222 | 
223 | func (c *Hooks) AddAfterInitialize(hook OnAfterInitializeFunc) {
224 | 	c.OnAfterInitialize = append(c.OnAfterInitialize, hook)
225 | }
226 | 
227 | func (c *Hooks) beforeInitialize(ctx context.Context, id any, message *mcp.InitializeRequest) {
228 | 	c.beforeAny(ctx, id, mcp.MethodInitialize, message)
229 | 	if c == nil {
230 | 		return
231 | 	}
232 | 	for _, hook := range c.OnBeforeInitialize {
233 | 		hook(ctx, id, message)
234 | 	}
235 | }
236 | 
237 | func (c *Hooks) afterInitialize(ctx context.Context, id any, message *mcp.InitializeRequest, result *mcp.InitializeResult) {
238 | 	c.onSuccess(ctx, id, mcp.MethodInitialize, message, result)
239 | 	if c == nil {
240 | 		return
241 | 	}
242 | 	for _, hook := range c.OnAfterInitialize {
243 | 		hook(ctx, id, message, result)
244 | 	}
245 | }
246 | func (c *Hooks) AddBeforePing(hook OnBeforePingFunc) {
247 | 	c.OnBeforePing = append(c.OnBeforePing, hook)
248 | }
249 | 
250 | func (c *Hooks) AddAfterPing(hook OnAfterPingFunc) {
251 | 	c.OnAfterPing = append(c.OnAfterPing, hook)
252 | }
253 | 
254 | func (c *Hooks) beforePing(ctx context.Context, id any, message *mcp.PingRequest) {
255 | 	c.beforeAny(ctx, id, mcp.MethodPing, message)
256 | 	if c == nil {
257 | 		return
258 | 	}
259 | 	for _, hook := range c.OnBeforePing {
260 | 		hook(ctx, id, message)
261 | 	}
262 | }
263 | 
264 | func (c *Hooks) afterPing(ctx context.Context, id any, message *mcp.PingRequest, result *mcp.EmptyResult) {
265 | 	c.onSuccess(ctx, id, mcp.MethodPing, message, result)
266 | 	if c == nil {
267 | 		return
268 | 	}
269 | 	for _, hook := range c.OnAfterPing {
270 | 		hook(ctx, id, message, result)
271 | 	}
272 | }
273 | func (c *Hooks) AddBeforeListResources(hook OnBeforeListResourcesFunc) {
274 | 	c.OnBeforeListResources = append(c.OnBeforeListResources, hook)
275 | }
276 | 
277 | func (c *Hooks) AddAfterListResources(hook OnAfterListResourcesFunc) {
278 | 	c.OnAfterListResources = append(c.OnAfterListResources, hook)
279 | }
280 | 
281 | func (c *Hooks) beforeListResources(ctx context.Context, id any, message *mcp.ListResourcesRequest) {
282 | 	c.beforeAny(ctx, id, mcp.MethodResourcesList, message)
283 | 	if c == nil {
284 | 		return
285 | 	}
286 | 	for _, hook := range c.OnBeforeListResources {
287 | 		hook(ctx, id, message)
288 | 	}
289 | }
290 | 
291 | func (c *Hooks) afterListResources(ctx context.Context, id any, message *mcp.ListResourcesRequest, result *mcp.ListResourcesResult) {
292 | 	c.onSuccess(ctx, id, mcp.MethodResourcesList, message, result)
293 | 	if c == nil {
294 | 		return
295 | 	}
296 | 	for _, hook := range c.OnAfterListResources {
297 | 		hook(ctx, id, message, result)
298 | 	}
299 | }
300 | func (c *Hooks) AddBeforeListResourceTemplates(hook OnBeforeListResourceTemplatesFunc) {
301 | 	c.OnBeforeListResourceTemplates = append(c.OnBeforeListResourceTemplates, hook)
302 | }
303 | 
304 | func (c *Hooks) AddAfterListResourceTemplates(hook OnAfterListResourceTemplatesFunc) {
305 | 	c.OnAfterListResourceTemplates = append(c.OnAfterListResourceTemplates, hook)
306 | }
307 | 
308 | func (c *Hooks) beforeListResourceTemplates(ctx context.Context, id any, message *mcp.ListResourceTemplatesRequest) {
309 | 	c.beforeAny(ctx, id, mcp.MethodResourcesTemplatesList, message)
310 | 	if c == nil {
311 | 		return
312 | 	}
313 | 	for _, hook := range c.OnBeforeListResourceTemplates {
314 | 		hook(ctx, id, message)
315 | 	}
316 | }
317 | 
318 | func (c *Hooks) afterListResourceTemplates(ctx context.Context, id any, message *mcp.ListResourceTemplatesRequest, result *mcp.ListResourceTemplatesResult) {
319 | 	c.onSuccess(ctx, id, mcp.MethodResourcesTemplatesList, message, result)
320 | 	if c == nil {
321 | 		return
322 | 	}
323 | 	for _, hook := range c.OnAfterListResourceTemplates {
324 | 		hook(ctx, id, message, result)
325 | 	}
326 | }
327 | func (c *Hooks) AddBeforeReadResource(hook OnBeforeReadResourceFunc) {
328 | 	c.OnBeforeReadResource = append(c.OnBeforeReadResource, hook)
329 | }
330 | 
331 | func (c *Hooks) AddAfterReadResource(hook OnAfterReadResourceFunc) {
332 | 	c.OnAfterReadResource = append(c.OnAfterReadResource, hook)
333 | }
334 | 
335 | func (c *Hooks) beforeReadResource(ctx context.Context, id any, message *mcp.ReadResourceRequest) {
336 | 	c.beforeAny(ctx, id, mcp.MethodResourcesRead, message)
337 | 	if c == nil {
338 | 		return
339 | 	}
340 | 	for _, hook := range c.OnBeforeReadResource {
341 | 		hook(ctx, id, message)
342 | 	}
343 | }
344 | 
345 | func (c *Hooks) afterReadResource(ctx context.Context, id any, message *mcp.ReadResourceRequest, result *mcp.ReadResourceResult) {
346 | 	c.onSuccess(ctx, id, mcp.MethodResourcesRead, message, result)
347 | 	if c == nil {
348 | 		return
349 | 	}
350 | 	for _, hook := range c.OnAfterReadResource {
351 | 		hook(ctx, id, message, result)
352 | 	}
353 | }
354 | func (c *Hooks) AddBeforeListPrompts(hook OnBeforeListPromptsFunc) {
355 | 	c.OnBeforeListPrompts = append(c.OnBeforeListPrompts, hook)
356 | }
357 | 
358 | func (c *Hooks) AddAfterListPrompts(hook OnAfterListPromptsFunc) {
359 | 	c.OnAfterListPrompts = append(c.OnAfterListPrompts, hook)
360 | }
361 | 
362 | func (c *Hooks) beforeListPrompts(ctx context.Context, id any, message *mcp.ListPromptsRequest) {
363 | 	c.beforeAny(ctx, id, mcp.MethodPromptsList, message)
364 | 	if c == nil {
365 | 		return
366 | 	}
367 | 	for _, hook := range c.OnBeforeListPrompts {
368 | 		hook(ctx, id, message)
369 | 	}
370 | }
371 | 
372 | func (c *Hooks) afterListPrompts(ctx context.Context, id any, message *mcp.ListPromptsRequest, result *mcp.ListPromptsResult) {
373 | 	c.onSuccess(ctx, id, mcp.MethodPromptsList, message, result)
374 | 	if c == nil {
375 | 		return
376 | 	}
377 | 	for _, hook := range c.OnAfterListPrompts {
378 | 		hook(ctx, id, message, result)
379 | 	}
380 | }
381 | func (c *Hooks) AddBeforeGetPrompt(hook OnBeforeGetPromptFunc) {
382 | 	c.OnBeforeGetPrompt = append(c.OnBeforeGetPrompt, hook)
383 | }
384 | 
385 | func (c *Hooks) AddAfterGetPrompt(hook OnAfterGetPromptFunc) {
386 | 	c.OnAfterGetPrompt = append(c.OnAfterGetPrompt, hook)
387 | }
388 | 
389 | func (c *Hooks) beforeGetPrompt(ctx context.Context, id any, message *mcp.GetPromptRequest) {
390 | 	c.beforeAny(ctx, id, mcp.MethodPromptsGet, message)
391 | 	if c == nil {
392 | 		return
393 | 	}
394 | 	for _, hook := range c.OnBeforeGetPrompt {
395 | 		hook(ctx, id, message)
396 | 	}
397 | }
398 | 
399 | func (c *Hooks) afterGetPrompt(ctx context.Context, id any, message *mcp.GetPromptRequest, result *mcp.GetPromptResult) {
400 | 	c.onSuccess(ctx, id, mcp.MethodPromptsGet, message, result)
401 | 	if c == nil {
402 | 		return
403 | 	}
404 | 	for _, hook := range c.OnAfterGetPrompt {
405 | 		hook(ctx, id, message, result)
406 | 	}
407 | }
408 | func (c *Hooks) AddBeforeListTools(hook OnBeforeListToolsFunc) {
409 | 	c.OnBeforeListTools = append(c.OnBeforeListTools, hook)
410 | }
411 | 
412 | func (c *Hooks) AddAfterListTools(hook OnAfterListToolsFunc) {
413 | 	c.OnAfterListTools = append(c.OnAfterListTools, hook)
414 | }
415 | 
416 | func (c *Hooks) beforeListTools(ctx context.Context, id any, message *mcp.ListToolsRequest) {
417 | 	c.beforeAny(ctx, id, mcp.MethodToolsList, message)
418 | 	if c == nil {
419 | 		return
420 | 	}
421 | 	for _, hook := range c.OnBeforeListTools {
422 | 		hook(ctx, id, message)
423 | 	}
424 | }
425 | 
426 | func (c *Hooks) afterListTools(ctx context.Context, id any, message *mcp.ListToolsRequest, result *mcp.ListToolsResult) {
427 | 	c.onSuccess(ctx, id, mcp.MethodToolsList, message, result)
428 | 	if c == nil {
429 | 		return
430 | 	}
431 | 	for _, hook := range c.OnAfterListTools {
432 | 		hook(ctx, id, message, result)
433 | 	}
434 | }
435 | func (c *Hooks) AddBeforeCallTool(hook OnBeforeCallToolFunc) {
436 | 	c.OnBeforeCallTool = append(c.OnBeforeCallTool, hook)
437 | }
438 | 
439 | func (c *Hooks) AddAfterCallTool(hook OnAfterCallToolFunc) {
440 | 	c.OnAfterCallTool = append(c.OnAfterCallTool, hook)
441 | }
442 | 
443 | func (c *Hooks) beforeCallTool(ctx context.Context, id any, message *mcp.CallToolRequest) {
444 | 	c.beforeAny(ctx, id, mcp.MethodToolsCall, message)
445 | 	if c == nil {
446 | 		return
447 | 	}
448 | 	for _, hook := range c.OnBeforeCallTool {
449 | 		hook(ctx, id, message)
450 | 	}
451 | }
452 | 
453 | func (c *Hooks) afterCallTool(ctx context.Context, id any, message *mcp.CallToolRequest, result *mcp.CallToolResult) {
454 | 	c.onSuccess(ctx, id, mcp.MethodToolsCall, message, result)
455 | 	if c == nil {
456 | 		return
457 | 	}
458 | 	for _, hook := range c.OnAfterCallTool {
459 | 		hook(ctx, id, message, result)
460 | 	}
461 | }
462 | 


--------------------------------------------------------------------------------
/server/internal/gen/data.go:
--------------------------------------------------------------------------------
  1 | package main
  2 | 
  3 | type MCPRequestType struct {
  4 | 	MethodName     string
  5 | 	ParamType      string
  6 | 	ResultType     string
  7 | 	HookName       string
  8 | 	Group          string
  9 | 	GroupName      string
 10 | 	GroupHookName  string
 11 | 	UnmarshalError string
 12 | 	HandlerFunc    string
 13 | }
 14 | 
 15 | var MCPRequestTypes = []MCPRequestType{
 16 | 	{
 17 | 		MethodName:     "MethodInitialize",
 18 | 		ParamType:      "InitializeRequest",
 19 | 		ResultType:     "InitializeResult",
 20 | 		HookName:       "Initialize",
 21 | 		UnmarshalError: "invalid initialize request",
 22 | 		HandlerFunc:    "handleInitialize",
 23 | 	}, {
 24 | 		MethodName:     "MethodPing",
 25 | 		ParamType:      "PingRequest",
 26 | 		ResultType:     "EmptyResult",
 27 | 		HookName:       "Ping",
 28 | 		UnmarshalError: "invalid ping request",
 29 | 		HandlerFunc:    "handlePing",
 30 | 	}, {
 31 | 		MethodName:     "MethodResourcesList",
 32 | 		ParamType:      "ListResourcesRequest",
 33 | 		ResultType:     "ListResourcesResult",
 34 | 		Group:          "resources",
 35 | 		GroupName:      "Resources",
 36 | 		GroupHookName:  "Resource",
 37 | 		HookName:       "ListResources",
 38 | 		UnmarshalError: "invalid list resources request",
 39 | 		HandlerFunc:    "handleListResources",
 40 | 	}, {
 41 | 		MethodName:     "MethodResourcesTemplatesList",
 42 | 		ParamType:      "ListResourceTemplatesRequest",
 43 | 		ResultType:     "ListResourceTemplatesResult",
 44 | 		Group:          "resources",
 45 | 		GroupName:      "Resources",
 46 | 		GroupHookName:  "Resource",
 47 | 		HookName:       "ListResourceTemplates",
 48 | 		UnmarshalError: "invalid list resource templates request",
 49 | 		HandlerFunc:    "handleListResourceTemplates",
 50 | 	}, {
 51 | 		MethodName:     "MethodResourcesRead",
 52 | 		ParamType:      "ReadResourceRequest",
 53 | 		ResultType:     "ReadResourceResult",
 54 | 		Group:          "resources",
 55 | 		GroupName:      "Resources",
 56 | 		GroupHookName:  "Resource",
 57 | 		HookName:       "ReadResource",
 58 | 		UnmarshalError: "invalid read resource request",
 59 | 		HandlerFunc:    "handleReadResource",
 60 | 	}, {
 61 | 		MethodName:     "MethodPromptsList",
 62 | 		ParamType:      "ListPromptsRequest",
 63 | 		ResultType:     "ListPromptsResult",
 64 | 		Group:          "prompts",
 65 | 		GroupName:      "Prompts",
 66 | 		GroupHookName:  "Prompt",
 67 | 		HookName:       "ListPrompts",
 68 | 		UnmarshalError: "invalid list prompts request",
 69 | 		HandlerFunc:    "handleListPrompts",
 70 | 	}, {
 71 | 		MethodName:     "MethodPromptsGet",
 72 | 		ParamType:      "GetPromptRequest",
 73 | 		ResultType:     "GetPromptResult",
 74 | 		Group:          "prompts",
 75 | 		GroupName:      "Prompts",
 76 | 		GroupHookName:  "Prompt",
 77 | 		HookName:       "GetPrompt",
 78 | 		UnmarshalError: "invalid get prompt request",
 79 | 		HandlerFunc:    "handleGetPrompt",
 80 | 	}, {
 81 | 		MethodName:     "MethodToolsList",
 82 | 		ParamType:      "ListToolsRequest",
 83 | 		ResultType:     "ListToolsResult",
 84 | 		Group:          "tools",
 85 | 		GroupName:      "Tools",
 86 | 		GroupHookName:  "Tool",
 87 | 		HookName:       "ListTools",
 88 | 		UnmarshalError: "invalid list tools request",
 89 | 		HandlerFunc:    "handleListTools",
 90 | 	}, {
 91 | 		MethodName:     "MethodToolsCall",
 92 | 		ParamType:      "CallToolRequest",
 93 | 		ResultType:     "CallToolResult",
 94 | 		Group:          "tools",
 95 | 		GroupName:      "Tools",
 96 | 		GroupHookName:  "Tool",
 97 | 		HookName:       "CallTool",
 98 | 		UnmarshalError: "invalid call tool request",
 99 | 		HandlerFunc:    "handleToolCall",
100 | 	},
101 | }
102 | 


--------------------------------------------------------------------------------
/server/internal/gen/main.go:
--------------------------------------------------------------------------------
 1 | package main
 2 | 
 3 | import (
 4 | 	_ "embed"
 5 | 	"fmt"
 6 | 	"io"
 7 | 	"log"
 8 | 	"os"
 9 | 	"os/exec"
10 | 	"path/filepath"
11 | 	"strings"
12 | 	"text/template"
13 | )
14 | 
15 | //go:generate go run . ../..
16 | 
17 | //go:embed hooks.go.tmpl
18 | var hooksTemplate string
19 | 
20 | //go:embed request_handler.go.tmpl
21 | var requestHandlerTemplate string
22 | 
23 | func RenderTemplateToFile(templateContent, destPath, fileName string, data any) error {
24 | 	// Create temp file for initial output
25 | 	tempFile, err := os.CreateTemp("", "hooks-*.go")
26 | 	if err != nil {
27 | 		return err
28 | 	}
29 | 	tempFilePath := tempFile.Name()
30 | 	defer os.Remove(tempFilePath) // Clean up temp file when done
31 | 
32 | 	// Parse and execute template to temp file
33 | 	tmpl, err := template.New(fileName).Funcs(template.FuncMap{
34 | 		"toLower": strings.ToLower,
35 | 	}).Parse(templateContent)
36 | 	if err != nil {
37 | 		tempFile.Close()
38 | 		return err
39 | 	}
40 | 
41 | 	if err := tmpl.Execute(tempFile, data); err != nil {
42 | 		tempFile.Close()
43 | 		return err
44 | 	}
45 | 	tempFile.Close()
46 | 
47 | 	// Run goimports on the temp file
48 | 	cmd := exec.Command("go", "run", "golang.org/x/tools/cmd/goimports@latest", "-w", tempFilePath)
49 | 	if output, err := cmd.CombinedOutput(); err != nil {
50 | 		return fmt.Errorf("goimports failed: %v\n%s", err, output)
51 | 	}
52 | 
53 | 	// Read the processed content
54 | 	processedContent, err := os.ReadFile(tempFilePath)
55 | 	if err != nil {
56 | 		return err
57 | 	}
58 | 
59 | 	// Write the processed content to the destination
60 | 	var destWriter io.Writer
61 | 	if destPath == "-" {
62 | 		destWriter = os.Stdout
63 | 	} else {
64 | 		destFile, err := os.Create(filepath.Join(destPath, fileName))
65 | 		if err != nil {
66 | 			return err
67 | 		}
68 | 		defer destFile.Close()
69 | 		destWriter = destFile
70 | 	}
71 | 
72 | 	_, err = destWriter.Write(processedContent)
73 | 	return err
74 | }
75 | 
76 | func main() {
77 | 	if len(os.Args) < 2 {
78 | 		log.Fatal("usage: gen <destination-directory>")
79 | 	}
80 | 	destPath := os.Args[1]
81 | 
82 | 	if err := RenderTemplateToFile(hooksTemplate, destPath, "hooks.go", MCPRequestTypes); err != nil {
83 | 		log.Fatal(err)
84 | 	}
85 | 
86 | 	if err := RenderTemplateToFile(requestHandlerTemplate, destPath, "request_handler.go", MCPRequestTypes); err != nil {
87 | 		log.Fatal(err)
88 | 	}
89 | }
90 | 


--------------------------------------------------------------------------------
/server/request_handler.go:
--------------------------------------------------------------------------------
  1 | // Code generated by `go generate`. DO NOT EDIT.
  2 | // source: server/internal/gen/request_handler.go.tmpl
  3 | package server
  4 | 
  5 | import (
  6 | 	"context"
  7 | 	"encoding/json"
  8 | 	"fmt"
  9 | 
 10 | 	"github.com/mark3labs/mcp-go/mcp"
 11 | )
 12 | 
 13 | // HandleMessage processes an incoming JSON-RPC message and returns an appropriate response
 14 | func (s *MCPServer) HandleMessage(
 15 | 	ctx context.Context,
 16 | 	message json.RawMessage,
 17 | ) mcp.JSONRPCMessage {
 18 | 	// Add server to context
 19 | 	ctx = context.WithValue(ctx, serverKey{}, s)
 20 | 	var err *requestError
 21 | 
 22 | 	var baseMessage struct {
 23 | 		JSONRPC string        `json:"jsonrpc"`
 24 | 		Method  mcp.MCPMethod `json:"method"`
 25 | 		ID      any           `json:"id,omitempty"`
 26 | 	}
 27 | 
 28 | 	if err := json.Unmarshal(message, &baseMessage); err != nil {
 29 | 		return createErrorResponse(
 30 | 			nil,
 31 | 			mcp.PARSE_ERROR,
 32 | 			"Failed to parse message",
 33 | 		)
 34 | 	}
 35 | 
 36 | 	// Check for valid JSONRPC version
 37 | 	if baseMessage.JSONRPC != mcp.JSONRPC_VERSION {
 38 | 		return createErrorResponse(
 39 | 			baseMessage.ID,
 40 | 			mcp.INVALID_REQUEST,
 41 | 			"Invalid JSON-RPC version",
 42 | 		)
 43 | 	}
 44 | 
 45 | 	if baseMessage.ID == nil {
 46 | 		var notification mcp.JSONRPCNotification
 47 | 		if err := json.Unmarshal(message, &notification); err != nil {
 48 | 			return createErrorResponse(
 49 | 				nil,
 50 | 				mcp.PARSE_ERROR,
 51 | 				"Failed to parse notification",
 52 | 			)
 53 | 		}
 54 | 		s.handleNotification(ctx, notification)
 55 | 		return nil // Return nil for notifications
 56 | 	}
 57 | 
 58 | 	switch baseMessage.Method {
 59 | 	case mcp.MethodInitialize:
 60 | 		var request mcp.InitializeRequest
 61 | 		var result *mcp.InitializeResult
 62 | 		if unmarshalErr := json.Unmarshal(message, &request); unmarshalErr != nil {
 63 | 			err = &requestError{
 64 | 				id:   baseMessage.ID,
 65 | 				code: mcp.INVALID_REQUEST,
 66 | 				err:  &UnparseableMessageError{message: message, err: unmarshalErr, method: baseMessage.Method},
 67 | 			}
 68 | 		} else {
 69 | 			s.hooks.beforeInitialize(ctx, baseMessage.ID, &request)
 70 | 			result, err = s.handleInitialize(ctx, baseMessage.ID, request)
 71 | 		}
 72 | 		if err != nil {
 73 | 			s.hooks.onError(ctx, baseMessage.ID, baseMessage.Method, &request, err)
 74 | 			return err.ToJSONRPCError()
 75 | 		}
 76 | 		s.hooks.afterInitialize(ctx, baseMessage.ID, &request, result)
 77 | 		return createResponse(baseMessage.ID, *result)
 78 | 	case mcp.MethodPing:
 79 | 		var request mcp.PingRequest
 80 | 		var result *mcp.EmptyResult
 81 | 		if unmarshalErr := json.Unmarshal(message, &request); unmarshalErr != nil {
 82 | 			err = &requestError{
 83 | 				id:   baseMessage.ID,
 84 | 				code: mcp.INVALID_REQUEST,
 85 | 				err:  &UnparseableMessageError{message: message, err: unmarshalErr, method: baseMessage.Method},
 86 | 			}
 87 | 		} else {
 88 | 			s.hooks.beforePing(ctx, baseMessage.ID, &request)
 89 | 			result, err = s.handlePing(ctx, baseMessage.ID, request)
 90 | 		}
 91 | 		if err != nil {
 92 | 			s.hooks.onError(ctx, baseMessage.ID, baseMessage.Method, &request, err)
 93 | 			return err.ToJSONRPCError()
 94 | 		}
 95 | 		s.hooks.afterPing(ctx, baseMessage.ID, &request, result)
 96 | 		return createResponse(baseMessage.ID, *result)
 97 | 	case mcp.MethodResourcesList:
 98 | 		var request mcp.ListResourcesRequest
 99 | 		var result *mcp.ListResourcesResult
100 | 		if s.capabilities.resources == nil {
101 | 			err = &requestError{
102 | 				id:   baseMessage.ID,
103 | 				code: mcp.METHOD_NOT_FOUND,
104 | 				err:  fmt.Errorf("resources %w", ErrUnsupported),
105 | 			}
106 | 		} else if unmarshalErr := json.Unmarshal(message, &request); unmarshalErr != nil {
107 | 			err = &requestError{
108 | 				id:   baseMessage.ID,
109 | 				code: mcp.INVALID_REQUEST,
110 | 				err:  &UnparseableMessageError{message: message, err: unmarshalErr, method: baseMessage.Method},
111 | 			}
112 | 		} else {
113 | 			s.hooks.beforeListResources(ctx, baseMessage.ID, &request)
114 | 			result, err = s.handleListResources(ctx, baseMessage.ID, request)
115 | 		}
116 | 		if err != nil {
117 | 			s.hooks.onError(ctx, baseMessage.ID, baseMessage.Method, &request, err)
118 | 			return err.ToJSONRPCError()
119 | 		}
120 | 		s.hooks.afterListResources(ctx, baseMessage.ID, &request, result)
121 | 		return createResponse(baseMessage.ID, *result)
122 | 	case mcp.MethodResourcesTemplatesList:
123 | 		var request mcp.ListResourceTemplatesRequest
124 | 		var result *mcp.ListResourceTemplatesResult
125 | 		if s.capabilities.resources == nil {
126 | 			err = &requestError{
127 | 				id:   baseMessage.ID,
128 | 				code: mcp.METHOD_NOT_FOUND,
129 | 				err:  fmt.Errorf("resources %w", ErrUnsupported),
130 | 			}
131 | 		} else if unmarshalErr := json.Unmarshal(message, &request); unmarshalErr != nil {
132 | 			err = &requestError{
133 | 				id:   baseMessage.ID,
134 | 				code: mcp.INVALID_REQUEST,
135 | 				err:  &UnparseableMessageError{message: message, err: unmarshalErr, method: baseMessage.Method},
136 | 			}
137 | 		} else {
138 | 			s.hooks.beforeListResourceTemplates(ctx, baseMessage.ID, &request)
139 | 			result, err = s.handleListResourceTemplates(ctx, baseMessage.ID, request)
140 | 		}
141 | 		if err != nil {
142 | 			s.hooks.onError(ctx, baseMessage.ID, baseMessage.Method, &request, err)
143 | 			return err.ToJSONRPCError()
144 | 		}
145 | 		s.hooks.afterListResourceTemplates(ctx, baseMessage.ID, &request, result)
146 | 		return createResponse(baseMessage.ID, *result)
147 | 	case mcp.MethodResourcesRead:
148 | 		var request mcp.ReadResourceRequest
149 | 		var result *mcp.ReadResourceResult
150 | 		if s.capabilities.resources == nil {
151 | 			err = &requestError{
152 | 				id:   baseMessage.ID,
153 | 				code: mcp.METHOD_NOT_FOUND,
154 | 				err:  fmt.Errorf("resources %w", ErrUnsupported),
155 | 			}
156 | 		} else if unmarshalErr := json.Unmarshal(message, &request); unmarshalErr != nil {
157 | 			err = &requestError{
158 | 				id:   baseMessage.ID,
159 | 				code: mcp.INVALID_REQUEST,
160 | 				err:  &UnparseableMessageError{message: message, err: unmarshalErr, method: baseMessage.Method},
161 | 			}
162 | 		} else {
163 | 			s.hooks.beforeReadResource(ctx, baseMessage.ID, &request)
164 | 			result, err = s.handleReadResource(ctx, baseMessage.ID, request)
165 | 		}
166 | 		if err != nil {
167 | 			s.hooks.onError(ctx, baseMessage.ID, baseMessage.Method, &request, err)
168 | 			return err.ToJSONRPCError()
169 | 		}
170 | 		s.hooks.afterReadResource(ctx, baseMessage.ID, &request, result)
171 | 		return createResponse(baseMessage.ID, *result)
172 | 	case mcp.MethodPromptsList:
173 | 		var request mcp.ListPromptsRequest
174 | 		var result *mcp.ListPromptsResult
175 | 		if s.capabilities.prompts == nil {
176 | 			err = &requestError{
177 | 				id:   baseMessage.ID,
178 | 				code: mcp.METHOD_NOT_FOUND,
179 | 				err:  fmt.Errorf("prompts %w", ErrUnsupported),
180 | 			}
181 | 		} else if unmarshalErr := json.Unmarshal(message, &request); unmarshalErr != nil {
182 | 			err = &requestError{
183 | 				id:   baseMessage.ID,
184 | 				code: mcp.INVALID_REQUEST,
185 | 				err:  &UnparseableMessageError{message: message, err: unmarshalErr, method: baseMessage.Method},
186 | 			}
187 | 		} else {
188 | 			s.hooks.beforeListPrompts(ctx, baseMessage.ID, &request)
189 | 			result, err = s.handleListPrompts(ctx, baseMessage.ID, request)
190 | 		}
191 | 		if err != nil {
192 | 			s.hooks.onError(ctx, baseMessage.ID, baseMessage.Method, &request, err)
193 | 			return err.ToJSONRPCError()
194 | 		}
195 | 		s.hooks.afterListPrompts(ctx, baseMessage.ID, &request, result)
196 | 		return createResponse(baseMessage.ID, *result)
197 | 	case mcp.MethodPromptsGet:
198 | 		var request mcp.GetPromptRequest
199 | 		var result *mcp.GetPromptResult
200 | 		if s.capabilities.prompts == nil {
201 | 			err = &requestError{
202 | 				id:   baseMessage.ID,
203 | 				code: mcp.METHOD_NOT_FOUND,
204 | 				err:  fmt.Errorf("prompts %w", ErrUnsupported),
205 | 			}
206 | 		} else if unmarshalErr := json.Unmarshal(message, &request); unmarshalErr != nil {
207 | 			err = &requestError{
208 | 				id:   baseMessage.ID,
209 | 				code: mcp.INVALID_REQUEST,
210 | 				err:  &UnparseableMessageError{message: message, err: unmarshalErr, method: baseMessage.Method},
211 | 			}
212 | 		} else {
213 | 			s.hooks.beforeGetPrompt(ctx, baseMessage.ID, &request)
214 | 			result, err = s.handleGetPrompt(ctx, baseMessage.ID, request)
215 | 		}
216 | 		if err != nil {
217 | 			s.hooks.onError(ctx, baseMessage.ID, baseMessage.Method, &request, err)
218 | 			return err.ToJSONRPCError()
219 | 		}
220 | 		s.hooks.afterGetPrompt(ctx, baseMessage.ID, &request, result)
221 | 		return createResponse(baseMessage.ID, *result)
222 | 	case mcp.MethodToolsList:
223 | 		var request mcp.ListToolsRequest
224 | 		var result *mcp.ListToolsResult
225 | 		if s.capabilities.tools == nil {
226 | 			err = &requestError{
227 | 				id:   baseMessage.ID,
228 | 				code: mcp.METHOD_NOT_FOUND,
229 | 				err:  fmt.Errorf("tools %w", ErrUnsupported),
230 | 			}
231 | 		} else if unmarshalErr := json.Unmarshal(message, &request); unmarshalErr != nil {
232 | 			err = &requestError{
233 | 				id:   baseMessage.ID,
234 | 				code: mcp.INVALID_REQUEST,
235 | 				err:  &UnparseableMessageError{message: message, err: unmarshalErr, method: baseMessage.Method},
236 | 			}
237 | 		} else {
238 | 			s.hooks.beforeListTools(ctx, baseMessage.ID, &request)
239 | 			result, err = s.handleListTools(ctx, baseMessage.ID, request)
240 | 		}
241 | 		if err != nil {
242 | 			s.hooks.onError(ctx, baseMessage.ID, baseMessage.Method, &request, err)
243 | 			return err.ToJSONRPCError()
244 | 		}
245 | 		s.hooks.afterListTools(ctx, baseMessage.ID, &request, result)
246 | 		return createResponse(baseMessage.ID, *result)
247 | 	case mcp.MethodToolsCall:
248 | 		var request mcp.CallToolRequest
249 | 		var result *mcp.CallToolResult
250 | 		if s.capabilities.tools == nil {
251 | 			err = &requestError{
252 | 				id:   baseMessage.ID,
253 | 				code: mcp.METHOD_NOT_FOUND,
254 | 				err:  fmt.Errorf("tools %w", ErrUnsupported),
255 | 			}
256 | 		} else if unmarshalErr := json.Unmarshal(message, &request); unmarshalErr != nil {
257 | 			err = &requestError{
258 | 				id:   baseMessage.ID,
259 | 				code: mcp.INVALID_REQUEST,
260 | 				err:  &UnparseableMessageError{message: message, err: unmarshalErr, method: baseMessage.Method},
261 | 			}
262 | 		} else {
263 | 			s.hooks.beforeCallTool(ctx, baseMessage.ID, &request)
264 | 			result, err = s.handleToolCall(ctx, baseMessage.ID, request)
265 | 		}
266 | 		if err != nil {
267 | 			s.hooks.onError(ctx, baseMessage.ID, baseMessage.Method, &request, err)
268 | 			return err.ToJSONRPCError()
269 | 		}
270 | 		s.hooks.afterCallTool(ctx, baseMessage.ID, &request, result)
271 | 		return createResponse(baseMessage.ID, *result)
272 | 	default:
273 | 		return createErrorResponse(
274 | 			baseMessage.ID,
275 | 			mcp.METHOD_NOT_FOUND,
276 | 			fmt.Sprintf("Method %s not found", baseMessage.Method),
277 | 		)
278 | 	}
279 | }
280 | 


--------------------------------------------------------------------------------
/server/server.go:
--------------------------------------------------------------------------------
  1 | // Package server provides MCP (Model Control Protocol) server implementations.
  2 | package server
  3 | 
  4 | import (
  5 | 	"context"
  6 | 	"encoding/json"
  7 | 	"errors"
  8 | 	"fmt"
  9 | 	"sort"
 10 | 	"sync"
 11 | 
 12 | 	"github.com/mark3labs/mcp-go/mcp"
 13 | )
 14 | 
 15 | // resourceEntry holds both a resource and its handler
 16 | type resourceEntry struct {
 17 | 	resource mcp.Resource
 18 | 	handler  ResourceHandlerFunc
 19 | }
 20 | 
 21 | // resourceTemplateEntry holds both a template and its handler
 22 | type resourceTemplateEntry struct {
 23 | 	template mcp.ResourceTemplate
 24 | 	handler  ResourceTemplateHandlerFunc
 25 | }
 26 | 
 27 | // ServerOption is a function that configures an MCPServer.
 28 | type ServerOption func(*MCPServer)
 29 | 
 30 | // ResourceHandlerFunc is a function that returns resource contents.
 31 | type ResourceHandlerFunc func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error)
 32 | 
 33 | // ResourceTemplateHandlerFunc is a function that returns a resource template.
 34 | type ResourceTemplateHandlerFunc func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error)
 35 | 
 36 | // PromptHandlerFunc handles prompt requests with given arguments.
 37 | type PromptHandlerFunc func(ctx context.Context, request mcp.GetPromptRequest) (*mcp.GetPromptResult, error)
 38 | 
 39 | // ToolHandlerFunc handles tool calls with given arguments.
 40 | type ToolHandlerFunc func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error)
 41 | 
 42 | // ServerTool combines a Tool with its ToolHandlerFunc.
 43 | type ServerTool struct {
 44 | 	Tool    mcp.Tool
 45 | 	Handler ToolHandlerFunc
 46 | }
 47 | 
 48 | // ClientSession represents an active session that can be used by MCPServer to interact with client.
 49 | type ClientSession interface {
 50 | 	// Initialize marks session as fully initialized and ready for notifications
 51 | 	Initialize()
 52 | 	// Initialized returns if session is ready to accept notifications
 53 | 	Initialized() bool
 54 | 	// NotificationChannel provides a channel suitable for sending notifications to client.
 55 | 	NotificationChannel() chan<- mcp.JSONRPCNotification
 56 | 	// SessionID is a unique identifier used to track user session.
 57 | 	SessionID() string
 58 | }
 59 | 
 60 | // clientSessionKey is the context key for storing current client notification channel.
 61 | type clientSessionKey struct{}
 62 | 
 63 | // ClientSessionFromContext retrieves current client notification context from context.
 64 | func ClientSessionFromContext(ctx context.Context) ClientSession {
 65 | 	if session, ok := ctx.Value(clientSessionKey{}).(ClientSession); ok {
 66 | 		return session
 67 | 	}
 68 | 	return nil
 69 | }
 70 | 
 71 | // UnparseableMessageError is attached to the RequestError when json.Unmarshal
 72 | // fails on the request.
 73 | type UnparseableMessageError struct {
 74 | 	message json.RawMessage
 75 | 	method  mcp.MCPMethod
 76 | 	err     error
 77 | }
 78 | 
 79 | func (e *UnparseableMessageError) Error() string {
 80 | 	return fmt.Sprintf("unparseable %s request: %s", e.method, e.err)
 81 | }
 82 | 
 83 | func (e *UnparseableMessageError) Unwrap() error {
 84 | 	return e.err
 85 | }
 86 | 
 87 | func (e *UnparseableMessageError) GetMessage() json.RawMessage {
 88 | 	return e.message
 89 | }
 90 | 
 91 | func (e *UnparseableMessageError) GetMethod() mcp.MCPMethod {
 92 | 	return e.method
 93 | }
 94 | 
 95 | // RequestError is an error that can be converted to a JSON-RPC error.
 96 | // Implements Unwrap() to allow inspecting the error chain.
 97 | type requestError struct {
 98 | 	id   any
 99 | 	code int
100 | 	err  error
101 | }
102 | 
103 | func (e *requestError) Error() string {
104 | 	return fmt.Sprintf("request error: %s", e.err)
105 | }
106 | 
107 | func (e *requestError) ToJSONRPCError() mcp.JSONRPCError {
108 | 	return mcp.JSONRPCError{
109 | 		JSONRPC: mcp.JSONRPC_VERSION,
110 | 		ID:      e.id,
111 | 		Error: struct {
112 | 			Code    int    `json:"code"`
113 | 			Message string `json:"message"`
114 | 			Data    any    `json:"data,omitempty"`
115 | 		}{
116 | 			Code:    e.code,
117 | 			Message: e.err.Error(),
118 | 		},
119 | 	}
120 | }
121 | 
122 | func (e *requestError) Unwrap() error {
123 | 	return e.err
124 | }
125 | 
126 | var (
127 | 	ErrUnsupported      = errors.New("not supported")
128 | 	ErrResourceNotFound = errors.New("resource not found")
129 | 	ErrPromptNotFound   = errors.New("prompt not found")
130 | 	ErrToolNotFound     = errors.New("tool not found")
131 | )
132 | 
133 | // NotificationHandlerFunc handles incoming notifications.
134 | type NotificationHandlerFunc func(ctx context.Context, notification mcp.JSONRPCNotification)
135 | 
136 | // MCPServer implements a Model Control Protocol server that can handle various types of requests
137 | // including resources, prompts, and tools.
138 | type MCPServer struct {
139 | 	mu                   sync.RWMutex // Add mutex for protecting shared resources
140 | 	name                 string
141 | 	version              string
142 | 	instructions         string
143 | 	resources            map[string]resourceEntry
144 | 	resourceTemplates    map[string]resourceTemplateEntry
145 | 	prompts              map[string]mcp.Prompt
146 | 	promptHandlers       map[string]PromptHandlerFunc
147 | 	tools                map[string]ServerTool
148 | 	notificationHandlers map[string]NotificationHandlerFunc
149 | 	capabilities         serverCapabilities
150 | 	sessions             sync.Map
151 | 	hooks                *Hooks
152 | }
153 | 
154 | // serverKey is the context key for storing the server instance
155 | type serverKey struct{}
156 | 
157 | // ServerFromContext retrieves the MCPServer instance from a context
158 | func ServerFromContext(ctx context.Context) *MCPServer {
159 | 	if srv, ok := ctx.Value(serverKey{}).(*MCPServer); ok {
160 | 		return srv
161 | 	}
162 | 	return nil
163 | }
164 | 
165 | // WithContext sets the current client session and returns the provided context
166 | func (s *MCPServer) WithContext(
167 | 	ctx context.Context,
168 | 	session ClientSession,
169 | ) context.Context {
170 | 	return context.WithValue(ctx, clientSessionKey{}, session)
171 | }
172 | 
173 | // RegisterSession saves session that should be notified in case if some server attributes changed.
174 | func (s *MCPServer) RegisterSession(
175 | 	ctx context.Context,
176 | 	session ClientSession,
177 | ) error {
178 | 	sessionID := session.SessionID()
179 | 	if _, exists := s.sessions.LoadOrStore(sessionID, session); exists {
180 | 		return fmt.Errorf("session %s is already registered", sessionID)
181 | 	}
182 | 	s.hooks.RegisterSession(ctx, session)
183 | 	return nil
184 | }
185 | 
186 | // UnregisterSession removes from storage session that is shut down.
187 | func (s *MCPServer) UnregisterSession(
188 | 	sessionID string,
189 | ) {
190 | 	s.sessions.Delete(sessionID)
191 | }
192 | 
193 | // sendNotificationToAllClients sends a notification to all the currently active clients.
194 | func (s *MCPServer) sendNotificationToAllClients(
195 | 	method string,
196 | 	params map[string]any,
197 | ) {
198 | 	notification := mcp.JSONRPCNotification{
199 | 		JSONRPC: mcp.JSONRPC_VERSION,
200 | 		Notification: mcp.Notification{
201 | 			Method: method,
202 | 			Params: mcp.NotificationParams{
203 | 				AdditionalFields: params,
204 | 			},
205 | 		},
206 | 	}
207 | 
208 | 	s.sessions.Range(func(k, v any) bool {
209 | 		if session, ok := v.(ClientSession); ok && session.Initialized() {
210 | 			select {
211 | 			case session.NotificationChannel() <- notification:
212 | 			default:
213 | 				// TODO: log blocked channel in the future versions
214 | 			}
215 | 		}
216 | 		return true
217 | 	})
218 | }
219 | 
220 | // SendNotificationToClient sends a notification to the current client
221 | func (s *MCPServer) SendNotificationToClient(
222 | 	ctx context.Context,
223 | 	method string,
224 | 	params map[string]any,
225 | ) error {
226 | 	session := ClientSessionFromContext(ctx)
227 | 	if session == nil || !session.Initialized() {
228 | 		return fmt.Errorf("notification channel not initialized")
229 | 	}
230 | 
231 | 	notification := mcp.JSONRPCNotification{
232 | 		JSONRPC: mcp.JSONRPC_VERSION,
233 | 		Notification: mcp.Notification{
234 | 			Method: method,
235 | 			Params: mcp.NotificationParams{
236 | 				AdditionalFields: params,
237 | 			},
238 | 		},
239 | 	}
240 | 
241 | 	select {
242 | 	case session.NotificationChannel() <- notification:
243 | 		return nil
244 | 	default:
245 | 		return fmt.Errorf("notification channel full or blocked")
246 | 	}
247 | }
248 | 
249 | // serverCapabilities defines the supported features of the MCP server
250 | type serverCapabilities struct {
251 | 	tools     *toolCapabilities
252 | 	resources *resourceCapabilities
253 | 	prompts   *promptCapabilities
254 | 	logging   bool
255 | }
256 | 
257 | // resourceCapabilities defines the supported resource-related features
258 | type resourceCapabilities struct {
259 | 	subscribe   bool
260 | 	listChanged bool
261 | }
262 | 
263 | // promptCapabilities defines the supported prompt-related features
264 | type promptCapabilities struct {
265 | 	listChanged bool
266 | }
267 | 
268 | // toolCapabilities defines the supported tool-related features
269 | type toolCapabilities struct {
270 | 	listChanged bool
271 | }
272 | 
273 | // WithResourceCapabilities configures resource-related server capabilities
274 | func WithResourceCapabilities(subscribe, listChanged bool) ServerOption {
275 | 	return func(s *MCPServer) {
276 | 		// Always create a non-nil capability object
277 | 		s.capabilities.resources = &resourceCapabilities{
278 | 			subscribe:   subscribe,
279 | 			listChanged: listChanged,
280 | 		}
281 | 	}
282 | }
283 | 
284 | // WithHooks allows adding hooks that will be called before or after
285 | // either [all] requests or before / after specific request methods, or else
286 | // prior to returning an error to the client.
287 | func WithHooks(hooks *Hooks) ServerOption {
288 | 	return func(s *MCPServer) {
289 | 		s.hooks = hooks
290 | 	}
291 | }
292 | 
293 | // WithPromptCapabilities configures prompt-related server capabilities
294 | func WithPromptCapabilities(listChanged bool) ServerOption {
295 | 	return func(s *MCPServer) {
296 | 		// Always create a non-nil capability object
297 | 		s.capabilities.prompts = &promptCapabilities{
298 | 			listChanged: listChanged,
299 | 		}
300 | 	}
301 | }
302 | 
303 | // WithToolCapabilities configures tool-related server capabilities
304 | func WithToolCapabilities(listChanged bool) ServerOption {
305 | 	return func(s *MCPServer) {
306 | 		// Always create a non-nil capability object
307 | 		s.capabilities.tools = &toolCapabilities{
308 | 			listChanged: listChanged,
309 | 		}
310 | 	}
311 | }
312 | 
313 | // WithLogging enables logging capabilities for the server
314 | func WithLogging() ServerOption {
315 | 	return func(s *MCPServer) {
316 | 		s.capabilities.logging = true
317 | 	}
318 | }
319 | 
320 | // WithInstructions sets the server instructions for the client returned in the initialize response
321 | func WithInstructions(instructions string) ServerOption {
322 | 	return func(s *MCPServer) {
323 | 		s.instructions = instructions
324 | 	}
325 | }
326 | 
327 | // NewMCPServer creates a new MCP server instance with the given name, version and options
328 | func NewMCPServer(
329 | 	name, version string,
330 | 	opts ...ServerOption,
331 | ) *MCPServer {
332 | 	s := &MCPServer{
333 | 		resources:            make(map[string]resourceEntry),
334 | 		resourceTemplates:    make(map[string]resourceTemplateEntry),
335 | 		prompts:              make(map[string]mcp.Prompt),
336 | 		promptHandlers:       make(map[string]PromptHandlerFunc),
337 | 		tools:                make(map[string]ServerTool),
338 | 		name:                 name,
339 | 		version:              version,
340 | 		notificationHandlers: make(map[string]NotificationHandlerFunc),
341 | 		capabilities: serverCapabilities{
342 | 			tools:     nil,
343 | 			resources: nil,
344 | 			prompts:   nil,
345 | 			logging:   false,
346 | 		},
347 | 	}
348 | 
349 | 	for _, opt := range opts {
350 | 		opt(s)
351 | 	}
352 | 
353 | 	return s
354 | }
355 | 
356 | // AddResource registers a new resource and its handler
357 | func (s *MCPServer) AddResource(
358 | 	resource mcp.Resource,
359 | 	handler ResourceHandlerFunc,
360 | ) {
361 | 	if s.capabilities.resources == nil {
362 | 		s.capabilities.resources = &resourceCapabilities{}
363 | 	}
364 | 	s.mu.Lock()
365 | 	defer s.mu.Unlock()
366 | 	s.resources[resource.URI] = resourceEntry{
367 | 		resource: resource,
368 | 		handler:  handler,
369 | 	}
370 | }
371 | 
372 | // AddResourceTemplate registers a new resource template and its handler
373 | func (s *MCPServer) AddResourceTemplate(
374 | 	template mcp.ResourceTemplate,
375 | 	handler ResourceTemplateHandlerFunc,
376 | ) {
377 | 	if s.capabilities.resources == nil {
378 | 		s.capabilities.resources = &resourceCapabilities{}
379 | 	}
380 | 	s.mu.Lock()
381 | 	defer s.mu.Unlock()
382 | 	s.resourceTemplates[template.URITemplate.Raw()] = resourceTemplateEntry{
383 | 		template: template,
384 | 		handler:  handler,
385 | 	}
386 | }
387 | 
388 | // AddPrompt registers a new prompt handler with the given name
389 | func (s *MCPServer) AddPrompt(prompt mcp.Prompt, handler PromptHandlerFunc) {
390 | 	if s.capabilities.prompts == nil {
391 | 		s.capabilities.prompts = &promptCapabilities{}
392 | 	}
393 | 	s.mu.Lock()
394 | 	defer s.mu.Unlock()
395 | 	s.prompts[prompt.Name] = prompt
396 | 	s.promptHandlers[prompt.Name] = handler
397 | }
398 | 
399 | // AddTool registers a new tool and its handler
400 | func (s *MCPServer) AddTool(tool mcp.Tool, handler ToolHandlerFunc) {
401 | 	s.AddTools(ServerTool{Tool: tool, Handler: handler})
402 | }
403 | 
404 | // AddTools registers multiple tools at once
405 | func (s *MCPServer) AddTools(tools ...ServerTool) {
406 | 	if s.capabilities.tools == nil {
407 | 		s.capabilities.tools = &toolCapabilities{}
408 | 	}
409 | 	s.mu.Lock()
410 | 	for _, entry := range tools {
411 | 		s.tools[entry.Tool.Name] = entry
412 | 	}
413 | 	s.mu.Unlock()
414 | 
415 | 	// Send notification to all initialized sessions
416 | 	s.sendNotificationToAllClients("notifications/tools/list_changed", nil)
417 | }
418 | 
419 | // SetTools replaces all existing tools with the provided list
420 | func (s *MCPServer) SetTools(tools ...ServerTool) {
421 | 	s.mu.Lock()
422 | 	s.tools = make(map[string]ServerTool)
423 | 	s.mu.Unlock()
424 | 	s.AddTools(tools...)
425 | }
426 | 
427 | // DeleteTools removes a tool from the server
428 | func (s *MCPServer) DeleteTools(names ...string) {
429 | 	s.mu.Lock()
430 | 	for _, name := range names {
431 | 		delete(s.tools, name)
432 | 	}
433 | 	s.mu.Unlock()
434 | 
435 | 	// Send notification to all initialized sessions
436 | 	s.sendNotificationToAllClients("notifications/tools/list_changed", nil)
437 | }
438 | 
439 | // AddNotificationHandler registers a new handler for incoming notifications
440 | func (s *MCPServer) AddNotificationHandler(
441 | 	method string,
442 | 	handler NotificationHandlerFunc,
443 | ) {
444 | 	s.mu.Lock()
445 | 	defer s.mu.Unlock()
446 | 	s.notificationHandlers[method] = handler
447 | }
448 | 
449 | func (s *MCPServer) handleInitialize(
450 | 	ctx context.Context,
451 | 	id interface{},
452 | 	request mcp.InitializeRequest,
453 | ) (*mcp.InitializeResult, *requestError) {
454 | 	capabilities := mcp.ServerCapabilities{}
455 | 
456 | 	// Only add resource capabilities if they're configured
457 | 	if s.capabilities.resources != nil {
458 | 		capabilities.Resources = &struct {
459 | 			Subscribe   bool `json:"subscribe,omitempty"`
460 | 			ListChanged bool `json:"listChanged,omitempty"`
461 | 		}{
462 | 			Subscribe:   s.capabilities.resources.subscribe,
463 | 			ListChanged: s.capabilities.resources.listChanged,
464 | 		}
465 | 	}
466 | 
467 | 	// Only add prompt capabilities if they're configured
468 | 	if s.capabilities.prompts != nil {
469 | 		capabilities.Prompts = &struct {
470 | 			ListChanged bool `json:"listChanged,omitempty"`
471 | 		}{
472 | 			ListChanged: s.capabilities.prompts.listChanged,
473 | 		}
474 | 	}
475 | 
476 | 	// Only add tool capabilities if they're configured
477 | 	if s.capabilities.tools != nil {
478 | 		capabilities.Tools = &struct {
479 | 			ListChanged bool `json:"listChanged,omitempty"`
480 | 		}{
481 | 			ListChanged: s.capabilities.tools.listChanged,
482 | 		}
483 | 	}
484 | 
485 | 	if s.capabilities.logging {
486 | 		capabilities.Logging = &struct{}{}
487 | 	}
488 | 
489 | 	result := mcp.InitializeResult{
490 | 		ProtocolVersion: mcp.LATEST_PROTOCOL_VERSION,
491 | 		ServerInfo: mcp.Implementation{
492 | 			Name:    s.name,
493 | 			Version: s.version,
494 | 		},
495 | 		Capabilities: capabilities,
496 | 		Instructions: s.instructions,
497 | 	}
498 | 
499 | 	if session := ClientSessionFromContext(ctx); session != nil {
500 | 		session.Initialize()
501 | 	}
502 | 	return &result, nil
503 | }
504 | 
505 | func (s *MCPServer) handlePing(
506 | 	ctx context.Context,
507 | 	id interface{},
508 | 	request mcp.PingRequest,
509 | ) (*mcp.EmptyResult, *requestError) {
510 | 	return &mcp.EmptyResult{}, nil
511 | }
512 | 
513 | func (s *MCPServer) handleListResources(
514 | 	ctx context.Context,
515 | 	id interface{},
516 | 	request mcp.ListResourcesRequest,
517 | ) (*mcp.ListResourcesResult, *requestError) {
518 | 	s.mu.RLock()
519 | 	resources := make([]mcp.Resource, 0, len(s.resources))
520 | 	for _, entry := range s.resources {
521 | 		resources = append(resources, entry.resource)
522 | 	}
523 | 	s.mu.RUnlock()
524 | 
525 | 	result := mcp.ListResourcesResult{
526 | 		Resources: resources,
527 | 	}
528 | 	if request.Params.Cursor != "" {
529 | 		result.NextCursor = "" // Handle pagination if needed
530 | 	}
531 | 	return &result, nil
532 | }
533 | 
534 | func (s *MCPServer) handleListResourceTemplates(
535 | 	ctx context.Context,
536 | 	id interface{},
537 | 	request mcp.ListResourceTemplatesRequest,
538 | ) (*mcp.ListResourceTemplatesResult, *requestError) {
539 | 	s.mu.RLock()
540 | 	templates := make([]mcp.ResourceTemplate, 0, len(s.resourceTemplates))
541 | 	for _, entry := range s.resourceTemplates {
542 | 		templates = append(templates, entry.template)
543 | 	}
544 | 	s.mu.RUnlock()
545 | 
546 | 	result := mcp.ListResourceTemplatesResult{
547 | 		ResourceTemplates: templates,
548 | 	}
549 | 	if request.Params.Cursor != "" {
550 | 		result.NextCursor = "" // Handle pagination if needed
551 | 	}
552 | 	return &result, nil
553 | }
554 | 
555 | func (s *MCPServer) handleReadResource(
556 | 	ctx context.Context,
557 | 	id interface{},
558 | 	request mcp.ReadResourceRequest,
559 | ) (*mcp.ReadResourceResult, *requestError) {
560 | 	s.mu.RLock()
561 | 	// First try direct resource handlers
562 | 	if entry, ok := s.resources[request.Params.URI]; ok {
563 | 		handler := entry.handler
564 | 		s.mu.RUnlock()
565 | 		contents, err := handler(ctx, request)
566 | 		if err != nil {
567 | 			return nil, &requestError{
568 | 				id:   id,
569 | 				code: mcp.INTERNAL_ERROR,
570 | 				err:  err,
571 | 			}
572 | 		}
573 | 		return &mcp.ReadResourceResult{Contents: contents}, nil
574 | 	}
575 | 
576 | 	// If no direct handler found, try matching against templates
577 | 	var matchedHandler ResourceTemplateHandlerFunc
578 | 	var matched bool
579 | 	for _, entry := range s.resourceTemplates {
580 | 		template := entry.template
581 | 		if matchesTemplate(request.Params.URI, template.URITemplate) {
582 | 			matchedHandler = entry.handler
583 | 			matched = true
584 | 			matchedVars := template.URITemplate.Match(request.Params.URI)
585 | 			// Convert matched variables to a map
586 | 			request.Params.Arguments = make(map[string]interface{})
587 | 			for name, value := range matchedVars {
588 | 				request.Params.Arguments[name] = value.V
589 | 			}
590 | 			break
591 | 		}
592 | 	}
593 | 	s.mu.RUnlock()
594 | 
595 | 	if matched {
596 | 		contents, err := matchedHandler(ctx, request)
597 | 		if err != nil {
598 | 			return nil, &requestError{
599 | 				id:   id,
600 | 				code: mcp.INTERNAL_ERROR,
601 | 				err:  err,
602 | 			}
603 | 		}
604 | 		return &mcp.ReadResourceResult{Contents: contents}, nil
605 | 	}
606 | 
607 | 	return nil, &requestError{
608 | 		id:   id,
609 | 		code: mcp.INVALID_PARAMS,
610 | 		err:  fmt.Errorf("handler not found for resource URI '%s': %w", request.Params.URI, ErrResourceNotFound),
611 | 	}
612 | }
613 | 
614 | // matchesTemplate checks if a URI matches a URI template pattern
615 | func matchesTemplate(uri string, template *mcp.URITemplate) bool {
616 | 	return template.Regexp().MatchString(uri)
617 | }
618 | 
619 | func (s *MCPServer) handleListPrompts(
620 | 	ctx context.Context,
621 | 	id interface{},
622 | 	request mcp.ListPromptsRequest,
623 | ) (*mcp.ListPromptsResult, *requestError) {
624 | 	s.mu.RLock()
625 | 	prompts := make([]mcp.Prompt, 0, len(s.prompts))
626 | 	for _, prompt := range s.prompts {
627 | 		prompts = append(prompts, prompt)
628 | 	}
629 | 	s.mu.RUnlock()
630 | 
631 | 	result := mcp.ListPromptsResult{
632 | 		Prompts: prompts,
633 | 	}
634 | 	if request.Params.Cursor != "" {
635 | 		result.NextCursor = "" // Handle pagination if needed
636 | 	}
637 | 	return &result, nil
638 | }
639 | 
640 | func (s *MCPServer) handleGetPrompt(
641 | 	ctx context.Context,
642 | 	id interface{},
643 | 	request mcp.GetPromptRequest,
644 | ) (*mcp.GetPromptResult, *requestError) {
645 | 	s.mu.RLock()
646 | 	handler, ok := s.promptHandlers[request.Params.Name]
647 | 	s.mu.RUnlock()
648 | 
649 | 	if !ok {
650 | 		return nil, &requestError{
651 | 			id:   id,
652 | 			code: mcp.INVALID_PARAMS,
653 | 			err:  fmt.Errorf("prompt '%s' not found: %w", request.Params.Name, ErrPromptNotFound),
654 | 		}
655 | 	}
656 | 
657 | 	result, err := handler(ctx, request)
658 | 	if err != nil {
659 | 		return nil, &requestError{
660 | 			id:   id,
661 | 			code: mcp.INTERNAL_ERROR,
662 | 			err:  err,
663 | 		}
664 | 	}
665 | 
666 | 	return result, nil
667 | }
668 | 
669 | func (s *MCPServer) handleListTools(
670 | 	ctx context.Context,
671 | 	id interface{},
672 | 	request mcp.ListToolsRequest,
673 | ) (*mcp.ListToolsResult, *requestError) {
674 | 	s.mu.RLock()
675 | 	tools := make([]mcp.Tool, 0, len(s.tools))
676 | 
677 | 	// Get all tool names for consistent ordering
678 | 	toolNames := make([]string, 0, len(s.tools))
679 | 	for name := range s.tools {
680 | 		toolNames = append(toolNames, name)
681 | 	}
682 | 
683 | 	// Sort the tool names for consistent ordering
684 | 	sort.Strings(toolNames)
685 | 
686 | 	// Add tools in sorted order
687 | 	for _, name := range toolNames {
688 | 		tools = append(tools, s.tools[name].Tool)
689 | 	}
690 | 	s.mu.RUnlock()
691 | 
692 | 	result := mcp.ListToolsResult{
693 | 		Tools: tools,
694 | 	}
695 | 	if request.Params.Cursor != "" {
696 | 		result.NextCursor = "" // Handle pagination if needed
697 | 	}
698 | 	return &result, nil
699 | }
700 | func (s *MCPServer) handleToolCall(
701 | 	ctx context.Context,
702 | 	id interface{},
703 | 	request mcp.CallToolRequest,
704 | ) (*mcp.CallToolResult, *requestError) {
705 | 	s.mu.RLock()
706 | 	tool, ok := s.tools[request.Params.Name]
707 | 	s.mu.RUnlock()
708 | 
709 | 	if !ok {
710 | 		return nil, &requestError{
711 | 			id:   id,
712 | 			code: mcp.INVALID_PARAMS,
713 | 			err:  fmt.Errorf("tool '%s' not found: %w", request.Params.Name, ErrToolNotFound),
714 | 		}
715 | 	}
716 | 
717 | 	result, err := tool.Handler(ctx, request)
718 | 	if err != nil {
719 | 		return nil, &requestError{
720 | 			id:   id,
721 | 			code: mcp.INTERNAL_ERROR,
722 | 			err:  err,
723 | 		}
724 | 	}
725 | 
726 | 	return result, nil
727 | }
728 | 
729 | func (s *MCPServer) handleNotification(
730 | 	ctx context.Context,
731 | 	notification mcp.JSONRPCNotification,
732 | ) mcp.JSONRPCMessage {
733 | 	s.mu.RLock()
734 | 	handler, ok := s.notificationHandlers[notification.Method]
735 | 	s.mu.RUnlock()
736 | 
737 | 	if ok {
738 | 		handler(ctx, notification)
739 | 	}
740 | 	return nil
741 | }
742 | 
743 | func createResponse(id interface{}, result interface{}) mcp.JSONRPCMessage {
744 | 	return mcp.JSONRPCResponse{
745 | 		JSONRPC: mcp.JSONRPC_VERSION,
746 | 		ID:      id,
747 | 		Result:  result,
748 | 	}
749 | }
750 | 
751 | func createErrorResponse(
752 | 	id interface{},
753 | 	code int,
754 | 	message string,
755 | ) mcp.JSONRPCMessage {
756 | 	return mcp.JSONRPCError{
757 | 		JSONRPC: mcp.JSONRPC_VERSION,
758 | 		ID:      id,
759 | 		Error: struct {
760 | 			Code    int         `json:"code"`
761 | 			Message string      `json:"message"`
762 | 			Data    interface{} `json:"data,omitempty"`
763 | 		}{
764 | 			Code:    code,
765 | 			Message: message,
766 | 		},
767 | 	}
768 | }
769 | 


--------------------------------------------------------------------------------
/server/server_test.go:
--------------------------------------------------------------------------------
   1 | package server
   2 | 
   3 | import (
   4 | 	"context"
   5 | 	"encoding/json"
   6 | 	"errors"
   7 | 	"fmt"
   8 | 	"testing"
   9 | 	"time"
  10 | 
  11 | 	"github.com/mark3labs/mcp-go/mcp"
  12 | 	"github.com/stretchr/testify/assert"
  13 | 	"github.com/stretchr/testify/require"
  14 | )
  15 | 
  16 | func TestMCPServer_NewMCPServer(t *testing.T) {
  17 | 	server := NewMCPServer("test-server", "1.0.0")
  18 | 	assert.NotNil(t, server)
  19 | 	assert.Equal(t, "test-server", server.name)
  20 | 	assert.Equal(t, "1.0.0", server.version)
  21 | }
  22 | 
  23 | func TestMCPServer_Capabilities(t *testing.T) {
  24 | 	tests := []struct {
  25 | 		name     string
  26 | 		options  []ServerOption
  27 | 		validate func(t *testing.T, response mcp.JSONRPCMessage)
  28 | 	}{
  29 | 		{
  30 | 			name:    "No capabilities",
  31 | 			options: []ServerOption{},
  32 | 			validate: func(t *testing.T, response mcp.JSONRPCMessage) {
  33 | 				resp, ok := response.(mcp.JSONRPCResponse)
  34 | 				assert.True(t, ok)
  35 | 
  36 | 				initResult, ok := resp.Result.(mcp.InitializeResult)
  37 | 				assert.True(t, ok)
  38 | 
  39 | 				assert.Equal(
  40 | 					t,
  41 | 					mcp.LATEST_PROTOCOL_VERSION,
  42 | 					initResult.ProtocolVersion,
  43 | 				)
  44 | 				assert.Equal(t, "test-server", initResult.ServerInfo.Name)
  45 | 				assert.Equal(t, "1.0.0", initResult.ServerInfo.Version)
  46 | 				assert.Nil(t, initResult.Capabilities.Resources)
  47 | 				assert.Nil(t, initResult.Capabilities.Prompts)
  48 | 				assert.Nil(t, initResult.Capabilities.Tools)
  49 | 				assert.Nil(t, initResult.Capabilities.Logging)
  50 | 			},
  51 | 		},
  52 | 		{
  53 | 			name: "All capabilities",
  54 | 			options: []ServerOption{
  55 | 				WithResourceCapabilities(true, true),
  56 | 				WithPromptCapabilities(true),
  57 | 				WithToolCapabilities(true),
  58 | 				WithLogging(),
  59 | 			},
  60 | 			validate: func(t *testing.T, response mcp.JSONRPCMessage) {
  61 | 				resp, ok := response.(mcp.JSONRPCResponse)
  62 | 				assert.True(t, ok)
  63 | 
  64 | 				initResult, ok := resp.Result.(mcp.InitializeResult)
  65 | 				assert.True(t, ok)
  66 | 
  67 | 				assert.Equal(
  68 | 					t,
  69 | 					mcp.LATEST_PROTOCOL_VERSION,
  70 | 					initResult.ProtocolVersion,
  71 | 				)
  72 | 				assert.Equal(t, "test-server", initResult.ServerInfo.Name)
  73 | 				assert.Equal(t, "1.0.0", initResult.ServerInfo.Version)
  74 | 
  75 | 				assert.NotNil(t, initResult.Capabilities.Resources)
  76 | 
  77 | 				assert.True(t, initResult.Capabilities.Resources.Subscribe)
  78 | 				assert.True(t, initResult.Capabilities.Resources.ListChanged)
  79 | 
  80 | 				assert.NotNil(t, initResult.Capabilities.Prompts)
  81 | 				assert.True(t, initResult.Capabilities.Prompts.ListChanged)
  82 | 
  83 | 				assert.NotNil(t, initResult.Capabilities.Tools)
  84 | 				assert.True(t, initResult.Capabilities.Tools.ListChanged)
  85 | 
  86 | 				assert.NotNil(t, initResult.Capabilities.Logging)
  87 | 			},
  88 | 		},
  89 | 		{
  90 | 			name: "Specific capabilities",
  91 | 			options: []ServerOption{
  92 | 				WithResourceCapabilities(true, false),
  93 | 				WithPromptCapabilities(true),
  94 | 				WithToolCapabilities(false),
  95 | 				WithLogging(),
  96 | 			},
  97 | 			validate: func(t *testing.T, response mcp.JSONRPCMessage) {
  98 | 				resp, ok := response.(mcp.JSONRPCResponse)
  99 | 				assert.True(t, ok)
 100 | 
 101 | 				initResult, ok := resp.Result.(mcp.InitializeResult)
 102 | 				assert.True(t, ok)
 103 | 
 104 | 				assert.Equal(
 105 | 					t,
 106 | 					mcp.LATEST_PROTOCOL_VERSION,
 107 | 					initResult.ProtocolVersion,
 108 | 				)
 109 | 				assert.Equal(t, "test-server", initResult.ServerInfo.Name)
 110 | 				assert.Equal(t, "1.0.0", initResult.ServerInfo.Version)
 111 | 
 112 | 				assert.NotNil(t, initResult.Capabilities.Resources)
 113 | 
 114 | 				assert.True(t, initResult.Capabilities.Resources.Subscribe)
 115 | 				assert.False(t, initResult.Capabilities.Resources.ListChanged)
 116 | 
 117 | 				assert.NotNil(t, initResult.Capabilities.Prompts)
 118 | 				assert.True(t, initResult.Capabilities.Prompts.ListChanged)
 119 | 
 120 | 				// Tools capability should be non-nil even when WithToolCapabilities(false) is used
 121 | 				assert.NotNil(t, initResult.Capabilities.Tools)
 122 | 				assert.False(t, initResult.Capabilities.Tools.ListChanged)
 123 | 
 124 | 				assert.NotNil(t, initResult.Capabilities.Logging)
 125 | 			},
 126 | 		},
 127 | 	}
 128 | 
 129 | 	for _, tt := range tests {
 130 | 		t.Run(tt.name, func(t *testing.T) {
 131 | 			server := NewMCPServer("test-server", "1.0.0", tt.options...)
 132 | 			message := mcp.JSONRPCRequest{
 133 | 				JSONRPC: "2.0",
 134 | 				ID:      1,
 135 | 				Request: mcp.Request{
 136 | 					Method: "initialize",
 137 | 				},
 138 | 			}
 139 | 			messageBytes, err := json.Marshal(message)
 140 | 			assert.NoError(t, err)
 141 | 
 142 | 			response := server.HandleMessage(context.Background(), messageBytes)
 143 | 			tt.validate(t, response)
 144 | 		})
 145 | 	}
 146 | }
 147 | 
 148 | func TestMCPServer_Tools(t *testing.T) {
 149 | 	tests := []struct {
 150 | 		name                  string
 151 | 		action                func(*testing.T, *MCPServer, chan mcp.JSONRPCNotification)
 152 | 		expectedNotifications int
 153 | 		validate              func(*testing.T, []mcp.JSONRPCNotification, mcp.JSONRPCMessage)
 154 | 	}{
 155 | 		{
 156 | 			name: "SetTools sends no notifications/tools/list_changed without active sessions",
 157 | 			action: func(t *testing.T, server *MCPServer, notificationChannel chan mcp.JSONRPCNotification) {
 158 | 				server.SetTools(ServerTool{
 159 | 					Tool: mcp.NewTool("test-tool-1"),
 160 | 					Handler: func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
 161 | 						return &mcp.CallToolResult{}, nil
 162 | 					},
 163 | 				}, ServerTool{
 164 | 					Tool: mcp.NewTool("test-tool-2"),
 165 | 					Handler: func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
 166 | 						return &mcp.CallToolResult{}, nil
 167 | 					},
 168 | 				})
 169 | 			},
 170 | 			expectedNotifications: 0,
 171 | 			validate: func(t *testing.T, notifications []mcp.JSONRPCNotification, toolsList mcp.JSONRPCMessage) {
 172 | 				tools := toolsList.(mcp.JSONRPCResponse).Result.(mcp.ListToolsResult).Tools
 173 | 				assert.Len(t, tools, 2)
 174 | 				assert.Equal(t, "test-tool-1", tools[0].Name)
 175 | 				assert.Equal(t, "test-tool-2", tools[1].Name)
 176 | 			},
 177 | 		},
 178 | 		{
 179 | 			name: "SetTools sends single notifications/tools/list_changed with one active session",
 180 | 			action: func(t *testing.T, server *MCPServer, notificationChannel chan mcp.JSONRPCNotification) {
 181 | 				err := server.RegisterSession(context.TODO(), &fakeSession{
 182 | 					sessionID:           "test",
 183 | 					notificationChannel: notificationChannel,
 184 | 					initialized:         true,
 185 | 				})
 186 | 				require.NoError(t, err)
 187 | 				server.SetTools(ServerTool{
 188 | 					Tool: mcp.NewTool("test-tool-1"),
 189 | 					Handler: func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
 190 | 						return &mcp.CallToolResult{}, nil
 191 | 					},
 192 | 				}, ServerTool{
 193 | 					Tool: mcp.NewTool("test-tool-2"),
 194 | 					Handler: func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
 195 | 						return &mcp.CallToolResult{}, nil
 196 | 					},
 197 | 				})
 198 | 			},
 199 | 			expectedNotifications: 1,
 200 | 			validate: func(t *testing.T, notifications []mcp.JSONRPCNotification, toolsList mcp.JSONRPCMessage) {
 201 | 				assert.Equal(t, "notifications/tools/list_changed", notifications[0].Method)
 202 | 				tools := toolsList.(mcp.JSONRPCResponse).Result.(mcp.ListToolsResult).Tools
 203 | 				assert.Len(t, tools, 2)
 204 | 				assert.Equal(t, "test-tool-1", tools[0].Name)
 205 | 				assert.Equal(t, "test-tool-2", tools[1].Name)
 206 | 			},
 207 | 		},
 208 | 		{
 209 | 			name: "SetTools sends single notifications/tools/list_changed per each active session",
 210 | 			action: func(t *testing.T, server *MCPServer, notificationChannel chan mcp.JSONRPCNotification) {
 211 | 				for i := range 5 {
 212 | 					err := server.RegisterSession(context.TODO(), &fakeSession{
 213 | 						sessionID:           fmt.Sprintf("test%d", i),
 214 | 						notificationChannel: notificationChannel,
 215 | 						initialized:         true,
 216 | 					})
 217 | 					require.NoError(t, err)
 218 | 				}
 219 | 				// also let's register inactive sessions
 220 | 				for i := range 5 {
 221 | 					err := server.RegisterSession(context.TODO(), &fakeSession{
 222 | 						sessionID:           fmt.Sprintf("test%d", i+5),
 223 | 						notificationChannel: notificationChannel,
 224 | 						initialized:         false,
 225 | 					})
 226 | 					require.NoError(t, err)
 227 | 				}
 228 | 				server.SetTools(ServerTool{
 229 | 					Tool: mcp.NewTool("test-tool-1"),
 230 | 					Handler: func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
 231 | 						return &mcp.CallToolResult{}, nil
 232 | 					},
 233 | 				}, ServerTool{
 234 | 					Tool: mcp.NewTool("test-tool-2"),
 235 | 					Handler: func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
 236 | 						return &mcp.CallToolResult{}, nil
 237 | 					},
 238 | 				})
 239 | 			},
 240 | 			expectedNotifications: 5,
 241 | 			validate: func(t *testing.T, notifications []mcp.JSONRPCNotification, toolsList mcp.JSONRPCMessage) {
 242 | 				for _, notification := range notifications {
 243 | 					assert.Equal(t, "notifications/tools/list_changed", notification.Method)
 244 | 				}
 245 | 				tools := toolsList.(mcp.JSONRPCResponse).Result.(mcp.ListToolsResult).Tools
 246 | 				assert.Len(t, tools, 2)
 247 | 				assert.Equal(t, "test-tool-1", tools[0].Name)
 248 | 				assert.Equal(t, "test-tool-2", tools[1].Name)
 249 | 			},
 250 | 		},
 251 | 		{
 252 | 			name: "AddTool sends multiple notifications/tools/list_changed",
 253 | 			action: func(t *testing.T, server *MCPServer, notificationChannel chan mcp.JSONRPCNotification) {
 254 | 				err := server.RegisterSession(context.TODO(), &fakeSession{
 255 | 					sessionID:           "test",
 256 | 					notificationChannel: notificationChannel,
 257 | 					initialized:         true,
 258 | 				})
 259 | 				require.NoError(t, err)
 260 | 				server.AddTool(mcp.NewTool("test-tool-1"),
 261 | 					func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
 262 | 						return &mcp.CallToolResult{}, nil
 263 | 					})
 264 | 				server.AddTool(mcp.NewTool("test-tool-2"),
 265 | 					func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
 266 | 						return &mcp.CallToolResult{}, nil
 267 | 					})
 268 | 			},
 269 | 			expectedNotifications: 2,
 270 | 			validate: func(t *testing.T, notifications []mcp.JSONRPCNotification, toolsList mcp.JSONRPCMessage) {
 271 | 				assert.Equal(t, "notifications/tools/list_changed", notifications[0].Method)
 272 | 				assert.Equal(t, "notifications/tools/list_changed", notifications[1].Method)
 273 | 				tools := toolsList.(mcp.JSONRPCResponse).Result.(mcp.ListToolsResult).Tools
 274 | 				assert.Len(t, tools, 2)
 275 | 				assert.Equal(t, "test-tool-1", tools[0].Name)
 276 | 				assert.Equal(t, "test-tool-2", tools[1].Name)
 277 | 			},
 278 | 		},
 279 | 		{
 280 | 			name: "DeleteTools sends single notifications/tools/list_changed",
 281 | 			action: func(t *testing.T, server *MCPServer, notificationChannel chan mcp.JSONRPCNotification) {
 282 | 				err := server.RegisterSession(context.TODO(), &fakeSession{
 283 | 					sessionID:           "test",
 284 | 					notificationChannel: notificationChannel,
 285 | 					initialized:         true,
 286 | 				})
 287 | 				require.NoError(t, err)
 288 | 				server.SetTools(
 289 | 					ServerTool{Tool: mcp.NewTool("test-tool-1")},
 290 | 					ServerTool{Tool: mcp.NewTool("test-tool-2")})
 291 | 				server.DeleteTools("test-tool-1", "test-tool-2")
 292 | 			},
 293 | 			expectedNotifications: 2,
 294 | 			validate: func(t *testing.T, notifications []mcp.JSONRPCNotification, toolsList mcp.JSONRPCMessage) {
 295 | 				// One for SetTools
 296 | 				assert.Equal(t, "notifications/tools/list_changed", notifications[0].Method)
 297 | 				// One for DeleteTools
 298 | 				assert.Equal(t, "notifications/tools/list_changed", notifications[1].Method)
 299 | 
 300 | 				// Expect a successful response with an empty list of tools
 301 | 				resp, ok := toolsList.(mcp.JSONRPCResponse)
 302 | 				assert.True(t, ok, "Expected JSONRPCResponse, got %T", toolsList)
 303 | 
 304 | 				result, ok := resp.Result.(mcp.ListToolsResult)
 305 | 				assert.True(t, ok, "Expected ListToolsResult, got %T", resp.Result)
 306 | 
 307 | 				assert.Empty(t, result.Tools, "Expected empty tools list")
 308 | 			},
 309 | 		},
 310 | 	}
 311 | 	for _, tt := range tests {
 312 | 		t.Run(tt.name, func(t *testing.T) {
 313 | 			ctx := context.Background()
 314 | 			server := NewMCPServer("test-server", "1.0.0")
 315 | 			_ = server.HandleMessage(ctx, []byte(`{
 316 | 				"jsonrpc": "2.0",
 317 | 				"id": 1,
 318 | 				"method": "initialize"
 319 | 			}`))
 320 | 			notificationChannel := make(chan mcp.JSONRPCNotification, 100)
 321 | 			notifications := make([]mcp.JSONRPCNotification, 0)
 322 | 			tt.action(t, server, notificationChannel)
 323 | 			for done := false; !done; {
 324 | 				select {
 325 | 				case serverNotification := <-notificationChannel:
 326 | 					notifications = append(notifications, serverNotification)
 327 | 					if len(notifications) == tt.expectedNotifications {
 328 | 						done = true
 329 | 					}
 330 | 				case <-time.After(1 * time.Second):
 331 | 					done = true
 332 | 				}
 333 | 			}
 334 | 			assert.Len(t, notifications, tt.expectedNotifications)
 335 | 			toolsList := server.HandleMessage(ctx, []byte(`{
 336 | 				"jsonrpc": "2.0",
 337 | 				"id": 1,
 338 | 				"method": "tools/list"
 339 | 			}`))
 340 | 			tt.validate(t, notifications, toolsList.(mcp.JSONRPCMessage))
 341 | 		})
 342 | 
 343 | 	}
 344 | }
 345 | 
 346 | func TestMCPServer_HandleValidMessages(t *testing.T) {
 347 | 	server := NewMCPServer("test-server", "1.0.0",
 348 | 		WithResourceCapabilities(true, true),
 349 | 		WithPromptCapabilities(true),
 350 | 	)
 351 | 
 352 | 	tests := []struct {
 353 | 		name     string
 354 | 		message  interface{}
 355 | 		validate func(t *testing.T, response mcp.JSONRPCMessage)
 356 | 	}{
 357 | 		{
 358 | 			name: "Initialize request",
 359 | 			message: mcp.JSONRPCRequest{
 360 | 				JSONRPC: "2.0",
 361 | 				ID:      1,
 362 | 				Request: mcp.Request{
 363 | 					Method: "initialize",
 364 | 				},
 365 | 			},
 366 | 			validate: func(t *testing.T, response mcp.JSONRPCMessage) {
 367 | 				resp, ok := response.(mcp.JSONRPCResponse)
 368 | 				assert.True(t, ok)
 369 | 
 370 | 				initResult, ok := resp.Result.(mcp.InitializeResult)
 371 | 				assert.True(t, ok)
 372 | 
 373 | 				assert.Equal(
 374 | 					t,
 375 | 					mcp.LATEST_PROTOCOL_VERSION,
 376 | 					initResult.ProtocolVersion,
 377 | 				)
 378 | 				assert.Equal(t, "test-server", initResult.ServerInfo.Name)
 379 | 				assert.Equal(t, "1.0.0", initResult.ServerInfo.Version)
 380 | 			},
 381 | 		},
 382 | 		{
 383 | 			name: "Ping request",
 384 | 			message: mcp.JSONRPCRequest{
 385 | 				JSONRPC: "2.0",
 386 | 				ID:      1,
 387 | 				Request: mcp.Request{
 388 | 					Method: "ping",
 389 | 				},
 390 | 			},
 391 | 			validate: func(t *testing.T, response mcp.JSONRPCMessage) {
 392 | 				resp, ok := response.(mcp.JSONRPCResponse)
 393 | 				assert.True(t, ok)
 394 | 
 395 | 				_, ok = resp.Result.(mcp.EmptyResult)
 396 | 				assert.True(t, ok)
 397 | 			},
 398 | 		},
 399 | 		{
 400 | 			name: "List resources",
 401 | 			message: mcp.JSONRPCRequest{
 402 | 				JSONRPC: "2.0",
 403 | 				ID:      1,
 404 | 				Request: mcp.Request{
 405 | 					Method: "resources/list",
 406 | 				},
 407 | 			},
 408 | 			validate: func(t *testing.T, response mcp.JSONRPCMessage) {
 409 | 				resp, ok := response.(mcp.JSONRPCResponse)
 410 | 				assert.True(t, ok)
 411 | 
 412 | 				listResult, ok := resp.Result.(mcp.ListResourcesResult)
 413 | 				assert.True(t, ok)
 414 | 				assert.NotNil(t, listResult.Resources)
 415 | 			},
 416 | 		},
 417 | 	}
 418 | 
 419 | 	for _, tt := range tests {
 420 | 		t.Run(tt.name, func(t *testing.T) {
 421 | 			messageBytes, err := json.Marshal(tt.message)
 422 | 			assert.NoError(t, err)
 423 | 
 424 | 			response := server.HandleMessage(context.Background(), messageBytes)
 425 | 			assert.NotNil(t, response)
 426 | 			tt.validate(t, response)
 427 | 		})
 428 | 	}
 429 | }
 430 | 
 431 | func TestMCPServer_HandlePagination(t *testing.T) {
 432 | 	server := createTestServer()
 433 | 
 434 | 	tests := []struct {
 435 | 		name     string
 436 | 		message  string
 437 | 		validate func(t *testing.T, response mcp.JSONRPCMessage)
 438 | 	}{
 439 | 		{
 440 | 			name: "List resources with cursor",
 441 | 			message: `{
 442 |                     "jsonrpc": "2.0",
 443 |                     "id": 1,
 444 |                     "method": "resources/list",
 445 |                     "params": {
 446 |                         "cursor": "test-cursor"
 447 |                     }
 448 |                 }`,
 449 | 			validate: func(t *testing.T, response mcp.JSONRPCMessage) {
 450 | 				resp, ok := response.(mcp.JSONRPCResponse)
 451 | 				assert.True(t, ok)
 452 | 
 453 | 				listResult, ok := resp.Result.(mcp.ListResourcesResult)
 454 | 				assert.True(t, ok)
 455 | 				assert.NotNil(t, listResult.Resources)
 456 | 				assert.Equal(t, mcp.Cursor(""), listResult.NextCursor)
 457 | 			},
 458 | 		},
 459 | 	}
 460 | 
 461 | 	for _, tt := range tests {
 462 | 		t.Run(tt.name, func(t *testing.T) {
 463 | 			response := server.HandleMessage(
 464 | 				context.Background(),
 465 | 				[]byte(tt.message),
 466 | 			)
 467 | 			tt.validate(t, response)
 468 | 		})
 469 | 	}
 470 | }
 471 | 
 472 | func TestMCPServer_HandleNotifications(t *testing.T) {
 473 | 	server := createTestServer()
 474 | 	notificationReceived := false
 475 | 
 476 | 	server.AddNotificationHandler("notifications/initialized", func(ctx context.Context, notification mcp.JSONRPCNotification) {
 477 | 		notificationReceived = true
 478 | 	})
 479 | 
 480 | 	message := `{
 481 |             "jsonrpc": "2.0",
 482 |             "method": "notifications/initialized"
 483 |         }`
 484 | 
 485 | 	response := server.HandleMessage(context.Background(), []byte(message))
 486 | 	assert.Nil(t, response)
 487 | 	assert.True(t, notificationReceived)
 488 | }
 489 | 
 490 | func TestMCPServer_SendNotificationToClient(t *testing.T) {
 491 | 	tests := []struct {
 492 | 		name           string
 493 | 		contextPrepare func(context.Context, *MCPServer) context.Context
 494 | 		validate       func(*testing.T, context.Context, *MCPServer)
 495 | 	}{
 496 | 		{
 497 | 			name: "no active session",
 498 | 			contextPrepare: func(ctx context.Context, srv *MCPServer) context.Context {
 499 | 				return ctx
 500 | 			},
 501 | 			validate: func(t *testing.T, ctx context.Context, srv *MCPServer) {
 502 | 				require.Error(t, srv.SendNotificationToClient(ctx, "method", nil))
 503 | 			},
 504 | 		},
 505 | 		{
 506 | 			name: "uninit session",
 507 | 			contextPrepare: func(ctx context.Context, srv *MCPServer) context.Context {
 508 | 				return srv.WithContext(ctx, fakeSession{
 509 | 					sessionID:           "test",
 510 | 					notificationChannel: make(chan mcp.JSONRPCNotification, 10),
 511 | 					initialized:         false,
 512 | 				})
 513 | 			},
 514 | 			validate: func(t *testing.T, ctx context.Context, srv *MCPServer) {
 515 | 				require.Error(t, srv.SendNotificationToClient(ctx, "method", nil))
 516 | 				_, ok := ClientSessionFromContext(ctx).(fakeSession)
 517 | 				require.True(t, ok, "session not found or of incorrect type")
 518 | 			},
 519 | 		},
 520 | 		{
 521 | 			name: "active session",
 522 | 			contextPrepare: func(ctx context.Context, srv *MCPServer) context.Context {
 523 | 				return srv.WithContext(ctx, fakeSession{
 524 | 					sessionID:           "test",
 525 | 					notificationChannel: make(chan mcp.JSONRPCNotification, 10),
 526 | 					initialized:         true,
 527 | 				})
 528 | 			},
 529 | 			validate: func(t *testing.T, ctx context.Context, srv *MCPServer) {
 530 | 				for range 10 {
 531 | 					require.NoError(t, srv.SendNotificationToClient(ctx, "method", nil))
 532 | 				}
 533 | 				session, ok := ClientSessionFromContext(ctx).(fakeSession)
 534 | 				require.True(t, ok, "session not found or of incorrect type")
 535 | 				for range 10 {
 536 | 					select {
 537 | 					case record := <-session.notificationChannel:
 538 | 						assert.Equal(t, "method", record.Method)
 539 | 					default:
 540 | 						t.Errorf("notification not sent")
 541 | 					}
 542 | 				}
 543 | 			},
 544 | 		},
 545 | 		{
 546 | 			name: "session with blocked channel",
 547 | 			contextPrepare: func(ctx context.Context, srv *MCPServer) context.Context {
 548 | 				return srv.WithContext(ctx, fakeSession{
 549 | 					sessionID:           "test",
 550 | 					notificationChannel: make(chan mcp.JSONRPCNotification, 1),
 551 | 					initialized:         true,
 552 | 				})
 553 | 			},
 554 | 			validate: func(t *testing.T, ctx context.Context, srv *MCPServer) {
 555 | 				require.NoError(t, srv.SendNotificationToClient(ctx, "method", nil))
 556 | 				require.Error(t, srv.SendNotificationToClient(ctx, "method", nil))
 557 | 			},
 558 | 		},
 559 | 	}
 560 | 	for _, tt := range tests {
 561 | 		t.Run(tt.name, func(t *testing.T) {
 562 | 			server := NewMCPServer("test-server", "1.0.0")
 563 | 			ctx := tt.contextPrepare(context.Background(), server)
 564 | 			_ = server.HandleMessage(ctx, []byte(`{
 565 | 				"jsonrpc": "2.0",
 566 | 				"id": 1,
 567 | 				"method": "initialize"
 568 | 			}`))
 569 | 
 570 | 			tt.validate(t, ctx, server)
 571 | 		})
 572 | 	}
 573 | }
 574 | 
 575 | func TestMCPServer_PromptHandling(t *testing.T) {
 576 | 	server := NewMCPServer("test-server", "1.0.0",
 577 | 		WithPromptCapabilities(true),
 578 | 	)
 579 | 
 580 | 	// Add a test prompt
 581 | 	testPrompt := mcp.Prompt{
 582 | 		Name:        "test-prompt",
 583 | 		Description: "A test prompt",
 584 | 		Arguments: []mcp.PromptArgument{
 585 | 			{
 586 | 				Name:        "arg1",
 587 | 				Description: "First argument",
 588 | 			},
 589 | 		},
 590 | 	}
 591 | 
 592 | 	server.AddPrompt(
 593 | 		testPrompt,
 594 | 		func(ctx context.Context, request mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {
 595 | 			return &mcp.GetPromptResult{
 596 | 				Messages: []mcp.PromptMessage{
 597 | 					{
 598 | 						Role: mcp.RoleAssistant,
 599 | 						Content: mcp.TextContent{
 600 | 							Type: "text",
 601 | 							Text: "Test prompt with arg1: " + request.Params.Arguments["arg1"],
 602 | 						},
 603 | 					},
 604 | 				},
 605 | 			}, nil
 606 | 		},
 607 | 	)
 608 | 
 609 | 	tests := []struct {
 610 | 		name     string
 611 | 		message  string
 612 | 		validate func(t *testing.T, response mcp.JSONRPCMessage)
 613 | 	}{
 614 | 		{
 615 | 			name: "List prompts",
 616 | 			message: `{
 617 |                 "jsonrpc": "2.0",
 618 |                 "id": 1,
 619 |                 "method": "prompts/list"
 620 |             }`,
 621 | 			validate: func(t *testing.T, response mcp.JSONRPCMessage) {
 622 | 				resp, ok := response.(mcp.JSONRPCResponse)
 623 | 				assert.True(t, ok)
 624 | 
 625 | 				result, ok := resp.Result.(mcp.ListPromptsResult)
 626 | 				assert.True(t, ok)
 627 | 				assert.Len(t, result.Prompts, 1)
 628 | 				assert.Equal(t, "test-prompt", result.Prompts[0].Name)
 629 | 				assert.Equal(t, "A test prompt", result.Prompts[0].Description)
 630 | 			},
 631 | 		},
 632 | 		{
 633 | 			name: "Get prompt",
 634 | 			message: `{
 635 |                 "jsonrpc": "2.0",
 636 |                 "id": 1,
 637 |                 "method": "prompts/get",
 638 |                 "params": {
 639 |                     "name": "test-prompt",
 640 |                     "arguments": {
 641 |                         "arg1": "test-value"
 642 |                     }
 643 |                 }
 644 |             }`,
 645 | 			validate: func(t *testing.T, response mcp.JSONRPCMessage) {
 646 | 				resp, ok := response.(mcp.JSONRPCResponse)
 647 | 				assert.True(t, ok)
 648 | 
 649 | 				result, ok := resp.Result.(mcp.GetPromptResult)
 650 | 				assert.True(t, ok)
 651 | 				assert.Len(t, result.Messages, 1)
 652 | 				textContent, ok := result.Messages[0].Content.(mcp.TextContent)
 653 | 				assert.True(t, ok)
 654 | 				assert.Equal(
 655 | 					t,
 656 | 					"Test prompt with arg1: test-value",
 657 | 					textContent.Text,
 658 | 				)
 659 | 			},
 660 | 		},
 661 | 		{
 662 | 			name: "Get prompt with missing argument",
 663 | 			message: `{
 664 |                 "jsonrpc": "2.0",
 665 |                 "id": 1,
 666 |                 "method": "prompts/get",
 667 |                 "params": {
 668 |                     "name": "test-prompt",
 669 |                     "arguments": {}
 670 |                 }
 671 |             }`,
 672 | 			validate: func(t *testing.T, response mcp.JSONRPCMessage) {
 673 | 				resp, ok := response.(mcp.JSONRPCResponse)
 674 | 				assert.True(t, ok)
 675 | 
 676 | 				result, ok := resp.Result.(mcp.GetPromptResult)
 677 | 				assert.True(t, ok)
 678 | 				assert.Len(t, result.Messages, 1)
 679 | 				textContent, ok := result.Messages[0].Content.(mcp.TextContent)
 680 | 				assert.True(t, ok)
 681 | 				assert.Equal(t, "Test prompt with arg1: ", textContent.Text)
 682 | 			},
 683 | 		},
 684 | 	}
 685 | 
 686 | 	for _, tt := range tests {
 687 | 		t.Run(tt.name, func(t *testing.T) {
 688 | 			response := server.HandleMessage(
 689 | 				context.Background(),
 690 | 				[]byte(tt.message),
 691 | 			)
 692 | 			tt.validate(t, response)
 693 | 		})
 694 | 	}
 695 | }
 696 | 
 697 | func TestMCPServer_HandleInvalidMessages(t *testing.T) {
 698 | 	var errs []error
 699 | 	hooks := &Hooks{}
 700 | 	hooks.AddOnError(func(ctx context.Context, id any, method mcp.MCPMethod, message any, err error) {
 701 | 		errs = append(errs, err)
 702 | 	})
 703 | 
 704 | 	server := NewMCPServer("test-server", "1.0.0", WithHooks(hooks))
 705 | 
 706 | 	tests := []struct {
 707 | 		name        string
 708 | 		message     string
 709 | 		expectedErr int
 710 | 		validateErr func(t *testing.T, err error)
 711 | 	}{
 712 | 		{
 713 | 			name:        "Invalid JSON",
 714 | 			message:     `{"jsonrpc": "2.0", "id": 1, "method": "initialize"`,
 715 | 			expectedErr: mcp.PARSE_ERROR,
 716 | 		},
 717 | 		{
 718 | 			name:        "Invalid method",
 719 | 			message:     `{"jsonrpc": "2.0", "id": 1, "method": "nonexistent"}`,
 720 | 			expectedErr: mcp.METHOD_NOT_FOUND,
 721 | 		},
 722 | 		{
 723 | 			name:        "Invalid parameters",
 724 | 			message:     `{"jsonrpc": "2.0", "id": 1, "method": "initialize", "params": "invalid"}`,
 725 | 			expectedErr: mcp.INVALID_REQUEST,
 726 | 			validateErr: func(t *testing.T, err error) {
 727 | 				var unparseableErr = &UnparseableMessageError{}
 728 | 				var ok = errors.As(err, &unparseableErr)
 729 | 				assert.True(t, ok, "Error should be UnparseableMessageError")
 730 | 				assert.Equal(t, mcp.MethodInitialize, unparseableErr.GetMethod())
 731 | 				assert.Equal(t, json.RawMessage(`{"jsonrpc": "2.0", "id": 1, "method": "initialize", "params": "invalid"}`), unparseableErr.GetMessage())
 732 | 			},
 733 | 		},
 734 | 		{
 735 | 			name:        "Missing JSONRPC version",
 736 | 			message:     `{"id": 1, "method": "initialize"}`,
 737 | 			expectedErr: mcp.INVALID_REQUEST,
 738 | 		},
 739 | 	}
 740 | 
 741 | 	for _, tt := range tests {
 742 | 		t.Run(tt.name, func(t *testing.T) {
 743 | 			errs = nil // Reset errors for each test case
 744 | 
 745 | 			response := server.HandleMessage(
 746 | 				context.Background(),
 747 | 				[]byte(tt.message),
 748 | 			)
 749 | 			assert.NotNil(t, response)
 750 | 
 751 | 			errorResponse, ok := response.(mcp.JSONRPCError)
 752 | 			assert.True(t, ok)
 753 | 			assert.Equal(t, tt.expectedErr, errorResponse.Error.Code)
 754 | 
 755 | 			if tt.validateErr != nil {
 756 | 				require.Len(t, errs, 1, "Expected exactly one error")
 757 | 				tt.validateErr(t, errs[0])
 758 | 			}
 759 | 		})
 760 | 	}
 761 | }
 762 | 
 763 | func TestMCPServer_HandleUndefinedHandlers(t *testing.T) {
 764 | 	var errs []error
 765 | 	type beforeResult struct {
 766 | 		method  mcp.MCPMethod
 767 | 		message any
 768 | 	}
 769 | 	type afterResult struct {
 770 | 		method  mcp.MCPMethod
 771 | 		message any
 772 | 		result  any
 773 | 	}
 774 | 	var beforeResults []beforeResult
 775 | 	var afterResults []afterResult
 776 | 	hooks := &Hooks{}
 777 | 	hooks.AddOnError(func(ctx context.Context, id any, method mcp.MCPMethod, message any, err error) {
 778 | 		errs = append(errs, err)
 779 | 	})
 780 | 	hooks.AddBeforeAny(func(ctx context.Context, id any, method mcp.MCPMethod, message any) {
 781 | 		beforeResults = append(beforeResults, beforeResult{method, message})
 782 | 	})
 783 | 	hooks.AddOnSuccess(func(ctx context.Context, id any, method mcp.MCPMethod, message any, result any) {
 784 | 		afterResults = append(afterResults, afterResult{method, message, result})
 785 | 	})
 786 | 
 787 | 	server := NewMCPServer("test-server", "1.0.0",
 788 | 		WithResourceCapabilities(true, true),
 789 | 		WithPromptCapabilities(true),
 790 | 		WithToolCapabilities(true),
 791 | 		WithHooks(hooks),
 792 | 	)
 793 | 
 794 | 	// Add a test tool to enable tool capabilities
 795 | 	server.AddTool(mcp.Tool{
 796 | 		Name:        "test-tool",
 797 | 		Description: "Test tool",
 798 | 		InputSchema: mcp.ToolInputSchema{
 799 | 			Type:       "object",
 800 | 			Properties: map[string]interface{}{},
 801 | 		},
 802 | 	}, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
 803 | 		return &mcp.CallToolResult{}, nil
 804 | 	})
 805 | 
 806 | 	tests := []struct {
 807 | 		name              string
 808 | 		message           string
 809 | 		expectedErr       int
 810 | 		validateCallbacks func(t *testing.T, err error, beforeResults beforeResult)
 811 | 	}{
 812 | 		{
 813 | 			name: "Undefined tool",
 814 | 			message: `{
 815 |                     "jsonrpc": "2.0",
 816 |                     "id": 1,
 817 |                     "method": "tools/call",
 818 |                     "params": {
 819 |                         "name": "undefined-tool",
 820 |                         "arguments": {}
 821 |                     }
 822 |                 }`,
 823 | 			expectedErr: mcp.INVALID_PARAMS,
 824 | 			validateCallbacks: func(t *testing.T, err error, beforeResults beforeResult) {
 825 | 				assert.Equal(t, mcp.MethodToolsCall, beforeResults.method)
 826 | 				assert.True(t, errors.Is(err, ErrToolNotFound))
 827 | 			},
 828 | 		},
 829 | 		{
 830 | 			name: "Undefined prompt",
 831 | 			message: `{
 832 |                     "jsonrpc": "2.0",
 833 |                     "id": 1,
 834 |                     "method": "prompts/get",
 835 |                     "params": {
 836 |                         "name": "undefined-prompt",
 837 |                         "arguments": {}
 838 |                     }
 839 |                 }`,
 840 | 			expectedErr: mcp.INVALID_PARAMS,
 841 | 			validateCallbacks: func(t *testing.T, err error, beforeResults beforeResult) {
 842 | 				assert.Equal(t, mcp.MethodPromptsGet, beforeResults.method)
 843 | 				assert.True(t, errors.Is(err, ErrPromptNotFound))
 844 | 			},
 845 | 		},
 846 | 		{
 847 | 			name: "Undefined resource",
 848 | 			message: `{
 849 |                     "jsonrpc": "2.0",
 850 |                     "id": 1,
 851 |                     "method": "resources/read",
 852 |                     "params": {
 853 |                         "uri": "undefined-resource"
 854 |                     }
 855 |                 }`,
 856 | 			expectedErr: mcp.INVALID_PARAMS,
 857 | 			validateCallbacks: func(t *testing.T, err error, beforeResults beforeResult) {
 858 | 				assert.Equal(t, mcp.MethodResourcesRead, beforeResults.method)
 859 | 				assert.True(t, errors.Is(err, ErrResourceNotFound))
 860 | 			},
 861 | 		},
 862 | 	}
 863 | 
 864 | 	for _, tt := range tests {
 865 | 		t.Run(tt.name, func(t *testing.T) {
 866 | 			errs = nil // Reset errors for each test case
 867 | 			beforeResults = nil
 868 | 			response := server.HandleMessage(
 869 | 				context.Background(),
 870 | 				[]byte(tt.message),
 871 | 			)
 872 | 			assert.NotNil(t, response)
 873 | 
 874 | 			errorResponse, ok := response.(mcp.JSONRPCError)
 875 | 			assert.True(t, ok)
 876 | 			assert.Equal(t, tt.expectedErr, errorResponse.Error.Code)
 877 | 
 878 | 			if tt.validateCallbacks != nil {
 879 | 				require.Len(t, errs, 1, "Expected exactly one error")
 880 | 				require.Len(t, beforeResults, 1, "Expected exactly one before result")
 881 | 				require.Len(t, afterResults, 0, "Expected no after results because these calls generate errors")
 882 | 				tt.validateCallbacks(t, errs[0], beforeResults[0])
 883 | 			}
 884 | 		})
 885 | 	}
 886 | }
 887 | 
 888 | func TestMCPServer_HandleMethodsWithoutCapabilities(t *testing.T) {
 889 | 	var errs []error
 890 | 	hooks := &Hooks{}
 891 | 	hooks.AddOnError(func(ctx context.Context, id any, method mcp.MCPMethod, message any, err error) {
 892 | 		errs = append(errs, err)
 893 | 	})
 894 | 	hooksOption := WithHooks(hooks)
 895 | 
 896 | 	tests := []struct {
 897 | 		name        string
 898 | 		message     string
 899 | 		options     []ServerOption
 900 | 		expectedErr int
 901 | 		errString   string
 902 | 	}{
 903 | 		{
 904 | 			name: "Tools without capabilities",
 905 | 			message: `{
 906 |                     "jsonrpc": "2.0",
 907 |                     "id": 1,
 908 |                     "method": "tools/call",
 909 |                     "params": {
 910 |                         "name": "test-tool"
 911 |                     }
 912 |                 }`,
 913 | 			options:     []ServerOption{hooksOption}, // No capabilities at all
 914 | 			expectedErr: mcp.METHOD_NOT_FOUND,
 915 | 			errString:   "tools",
 916 | 		},
 917 | 		{
 918 | 			name: "Prompts without capabilities",
 919 | 			message: `{
 920 |                     "jsonrpc": "2.0",
 921 |                     "id": 1,
 922 |                     "method": "prompts/get",
 923 |                     "params": {
 924 |                         "name": "test-prompt"
 925 |                     }
 926 |                 }`,
 927 | 			options:     []ServerOption{hooksOption}, // No capabilities at all
 928 | 			expectedErr: mcp.METHOD_NOT_FOUND,
 929 | 			errString:   "prompts",
 930 | 		},
 931 | 		{
 932 | 			name: "Resources without capabilities",
 933 | 			message: `{
 934 |                     "jsonrpc": "2.0",
 935 |                     "id": 1,
 936 |                     "method": "resources/read",
 937 |                     "params": {
 938 |                         "uri": "test-resource"
 939 |                     }
 940 |                 }`,
 941 | 			options:     []ServerOption{hooksOption}, // No capabilities at all
 942 | 			expectedErr: mcp.METHOD_NOT_FOUND,
 943 | 			errString:   "resources",
 944 | 		},
 945 | 	}
 946 | 
 947 | 	for _, tt := range tests {
 948 | 		t.Run(tt.name, func(t *testing.T) {
 949 | 			errs = nil // Reset errors for each test case
 950 | 
 951 | 			server := NewMCPServer("test-server", "1.0.0", tt.options...)
 952 | 			response := server.HandleMessage(
 953 | 				context.Background(),
 954 | 				[]byte(tt.message),
 955 | 			)
 956 | 			assert.NotNil(t, response)
 957 | 
 958 | 			errorResponse, ok := response.(mcp.JSONRPCError)
 959 | 			assert.True(t, ok)
 960 | 			assert.Equal(t, tt.expectedErr, errorResponse.Error.Code)
 961 | 
 962 | 			require.Len(t, errs, 1, "Expected exactly one error")
 963 | 			assert.True(t, errors.Is(errs[0], ErrUnsupported), "Error should be ErrUnsupported but was %v", errs[0])
 964 | 			assert.Contains(t, errs[0].Error(), tt.errString)
 965 | 		})
 966 | 	}
 967 | }
 968 | 
 969 | func TestMCPServer_Instructions(t *testing.T) {
 970 | 	tests := []struct {
 971 | 		name         string
 972 | 		instructions string
 973 | 		validate     func(t *testing.T, response mcp.JSONRPCMessage)
 974 | 	}{
 975 | 		{
 976 | 			name:         "No instructions",
 977 | 			instructions: "",
 978 | 			validate: func(t *testing.T, response mcp.JSONRPCMessage) {
 979 | 				resp, ok := response.(mcp.JSONRPCResponse)
 980 | 				assert.True(t, ok)
 981 | 
 982 | 				initResult, ok := resp.Result.(mcp.InitializeResult)
 983 | 				assert.True(t, ok)
 984 | 				assert.Equal(t, "", initResult.Instructions)
 985 | 			},
 986 | 		},
 987 | 		{
 988 | 			name:         "With instructions",
 989 | 			instructions: "These are test instructions for the client.",
 990 | 			validate: func(t *testing.T, response mcp.JSONRPCMessage) {
 991 | 				resp, ok := response.(mcp.JSONRPCResponse)
 992 | 				assert.True(t, ok)
 993 | 
 994 | 				initResult, ok := resp.Result.(mcp.InitializeResult)
 995 | 				assert.True(t, ok)
 996 | 				assert.Equal(t, "These are test instructions for the client.", initResult.Instructions)
 997 | 			},
 998 | 		},
 999 | 		{
1000 | 			name:         "With multiline instructions",
1001 | 			instructions: "Line 1\nLine 2\nLine 3",
1002 | 			validate: func(t *testing.T, response mcp.JSONRPCMessage) {
1003 | 				resp, ok := response.(mcp.JSONRPCResponse)
1004 | 				assert.True(t, ok)
1005 | 
1006 | 				initResult, ok := resp.Result.(mcp.InitializeResult)
1007 | 				assert.True(t, ok)
1008 | 				assert.Equal(t, "Line 1\nLine 2\nLine 3", initResult.Instructions)
1009 | 			},
1010 | 		},
1011 | 	}
1012 | 
1013 | 	for _, tt := range tests {
1014 | 		t.Run(tt.name, func(t *testing.T) {
1015 | 			var server *MCPServer
1016 | 			if tt.instructions == "" {
1017 | 				server = NewMCPServer("test-server", "1.0.0")
1018 | 			} else {
1019 | 				server = NewMCPServer("test-server", "1.0.0", WithInstructions(tt.instructions))
1020 | 			}
1021 | 
1022 | 			message := mcp.JSONRPCRequest{
1023 | 				JSONRPC: "2.0",
1024 | 				ID:      1,
1025 | 				Request: mcp.Request{
1026 | 					Method: "initialize",
1027 | 				},
1028 | 			}
1029 | 			messageBytes, err := json.Marshal(message)
1030 | 			assert.NoError(t, err)
1031 | 
1032 | 			response := server.HandleMessage(context.Background(), messageBytes)
1033 | 			tt.validate(t, response)
1034 | 		})
1035 | 	}
1036 | }
1037 | 
1038 | func TestMCPServer_ResourceTemplates(t *testing.T) {
1039 | 	server := NewMCPServer("test-server", "1.0.0",
1040 | 		WithResourceCapabilities(true, true),
1041 | 	)
1042 | 
1043 | 	server.AddResourceTemplate(
1044 | 		mcp.NewResourceTemplate(
1045 | 			"test://{a}/test-resource{/b*}",
1046 | 			"My Resource",
1047 | 		),
1048 | 		func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
1049 | 			a := request.Params.Arguments["a"].([]string)
1050 | 			b := request.Params.Arguments["b"].([]string)
1051 | 			// Validate that the template arguments are passed correctly to the handler
1052 | 			assert.Equal(t, []string{"something"}, a)
1053 | 			assert.Equal(t, []string{"a", "b", "c"}, b)
1054 | 			return []mcp.ResourceContents{
1055 | 				mcp.TextResourceContents{
1056 | 					URI:      "test://something/test-resource/a/b/c",
1057 | 					MIMEType: "text/plain",
1058 | 					Text:     "test content: " + a[0],
1059 | 				},
1060 | 			}, nil
1061 | 		},
1062 | 	)
1063 | 
1064 | 	listMessage := `{
1065 | 		"jsonrpc": "2.0",
1066 | 		"id": 1,
1067 | 		"method": "resources/templates/list"
1068 | 	}`
1069 | 
1070 | 	message := `{
1071 | 		"jsonrpc": "2.0",
1072 | 		"id": 2,
1073 | 		"method": "resources/read",
1074 | 		"params": {
1075 | 			"uri": "test://something/test-resource/a/b/c"
1076 | 		}
1077 | 	}`
1078 | 
1079 | 	t.Run("Get resource template", func(t *testing.T) {
1080 | 		response := server.HandleMessage(
1081 | 			context.Background(),
1082 | 			[]byte(listMessage),
1083 | 		)
1084 | 		assert.NotNil(t, response)
1085 | 
1086 | 		resp, ok := response.(mcp.JSONRPCResponse)
1087 | 		assert.True(t, ok)
1088 | 		listResult, ok := resp.Result.(mcp.ListResourceTemplatesResult)
1089 | 		assert.True(t, ok)
1090 | 		assert.Len(t, listResult.ResourceTemplates, 1)
1091 | 		assert.Equal(t, "My Resource", listResult.ResourceTemplates[0].Name)
1092 | 		template, err := json.Marshal(listResult.ResourceTemplates[0])
1093 | 		assert.NoError(t, err)
1094 | 
1095 | 		// Need to serialize the json to map[string]string to validate the URITemplate is correctly marshalled
1096 | 		var resourceTemplate map[string]string
1097 | 		err = json.Unmarshal(template, &resourceTemplate)
1098 | 		assert.NoError(t, err)
1099 | 
1100 | 		assert.Equal(t, "test://{a}/test-resource{/b*}", resourceTemplate["uriTemplate"])
1101 | 
1102 | 		response = server.HandleMessage(
1103 | 			context.Background(),
1104 | 			[]byte(message),
1105 | 		)
1106 | 
1107 | 		assert.NotNil(t, response)
1108 | 
1109 | 		resp, ok = response.(mcp.JSONRPCResponse)
1110 | 		assert.True(t, ok)
1111 | 		// Validate that the resource values are returned correctly
1112 | 		result, ok := resp.Result.(mcp.ReadResourceResult)
1113 | 		assert.True(t, ok)
1114 | 		assert.Len(t, result.Contents, 1)
1115 | 		resultContent, ok := result.Contents[0].(mcp.TextResourceContents)
1116 | 		assert.True(t, ok)
1117 | 		assert.Equal(t, "test://something/test-resource/a/b/c", resultContent.URI)
1118 | 		assert.Equal(t, "text/plain", resultContent.MIMEType)
1119 | 		assert.Equal(t, "test content: something", resultContent.Text)
1120 | 
1121 | 	})
1122 | }
1123 | 
1124 | func createTestServer() *MCPServer {
1125 | 	server := NewMCPServer("test-server", "1.0.0",
1126 | 		WithResourceCapabilities(true, true),
1127 | 		WithPromptCapabilities(true),
1128 | 	)
1129 | 
1130 | 	server.AddResource(
1131 | 		mcp.Resource{
1132 | 			URI:  "resource://testresource",
1133 | 			Name: "My Resource",
1134 | 		},
1135 | 		func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
1136 | 			return []mcp.ResourceContents{
1137 | 				mcp.TextResourceContents{
1138 | 					URI:      "resource://testresource",
1139 | 					MIMEType: "text/plain",
1140 | 					Text:     "test content",
1141 | 				},
1142 | 			}, nil
1143 | 		},
1144 | 	)
1145 | 
1146 | 	server.AddTool(
1147 | 		mcp.Tool{
1148 | 			Name:        "test-tool",
1149 | 			Description: "Test tool",
1150 | 		},
1151 | 		func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
1152 | 			return &mcp.CallToolResult{
1153 | 				Content: []mcp.Content{
1154 | 					mcp.TextContent{
1155 | 						Type: "text",
1156 | 						Text: "test result",
1157 | 					},
1158 | 				},
1159 | 			}, nil
1160 | 		},
1161 | 	)
1162 | 
1163 | 	return server
1164 | }
1165 | 
1166 | type fakeSession struct {
1167 | 	sessionID           string
1168 | 	notificationChannel chan mcp.JSONRPCNotification
1169 | 	initialized         bool
1170 | }
1171 | 
1172 | func (f fakeSession) SessionID() string {
1173 | 	return f.sessionID
1174 | }
1175 | 
1176 | func (f fakeSession) NotificationChannel() chan<- mcp.JSONRPCNotification {
1177 | 	return f.notificationChannel
1178 | }
1179 | 
1180 | func (f fakeSession) Initialize() {
1181 | }
1182 | 
1183 | func (f fakeSession) Initialized() bool {
1184 | 	return f.initialized
1185 | }
1186 | 
1187 | var _ ClientSession = fakeSession{}
1188 | 
1189 | func TestMCPServer_WithHooks(t *testing.T) {
1190 | 	// Create hook counters to verify calls
1191 | 	var (
1192 | 		beforeAnyCount   int
1193 | 		onSuccessCount   int
1194 | 		onErrorCount     int
1195 | 		beforePingCount  int
1196 | 		afterPingCount   int
1197 | 		beforeToolsCount int
1198 | 		afterToolsCount  int
1199 | 	)
1200 | 
1201 | 	// Collectors for message and result types
1202 | 	var beforeAnyMessages []any
1203 | 	var onSuccessData []struct {
1204 | 		msg any
1205 | 		res any
1206 | 	}
1207 | 	var beforePingMessages []*mcp.PingRequest
1208 | 	var afterPingData []struct {
1209 | 		msg *mcp.PingRequest
1210 | 		res *mcp.EmptyResult
1211 | 	}
1212 | 
1213 | 	// Initialize hook handlers
1214 | 	hooks := &Hooks{}
1215 | 
1216 | 	// Register "any" hooks with type verification
1217 | 	hooks.AddBeforeAny(func(ctx context.Context, id any, method mcp.MCPMethod, message any) {
1218 | 		beforeAnyCount++
1219 | 		// Only collect ping messages for our test
1220 | 		if method == mcp.MethodPing {
1221 | 			beforeAnyMessages = append(beforeAnyMessages, message)
1222 | 		}
1223 | 	})
1224 | 
1225 | 	hooks.AddOnSuccess(func(ctx context.Context, id any, method mcp.MCPMethod, message any, result any) {
1226 | 		onSuccessCount++
1227 | 		// Only collect ping responses for our test
1228 | 		if method == mcp.MethodPing {
1229 | 			onSuccessData = append(onSuccessData, struct {
1230 | 				msg any
1231 | 				res any
1232 | 			}{message, result})
1233 | 		}
1234 | 	})
1235 | 
1236 | 	hooks.AddOnError(func(ctx context.Context, id any, method mcp.MCPMethod, message any, err error) {
1237 | 		onErrorCount++
1238 | 	})
1239 | 
1240 | 	// Register method-specific hooks with type verification
1241 | 	hooks.AddBeforePing(func(ctx context.Context, id any, message *mcp.PingRequest) {
1242 | 		beforePingCount++
1243 | 		beforePingMessages = append(beforePingMessages, message)
1244 | 	})
1245 | 
1246 | 	hooks.AddAfterPing(func(ctx context.Context, id any, message *mcp.PingRequest, result *mcp.EmptyResult) {
1247 | 		afterPingCount++
1248 | 		afterPingData = append(afterPingData, struct {
1249 | 			msg *mcp.PingRequest
1250 | 			res *mcp.EmptyResult
1251 | 		}{message, result})
1252 | 	})
1253 | 
1254 | 	hooks.AddBeforeListTools(func(ctx context.Context, id any, message *mcp.ListToolsRequest) {
1255 | 		beforeToolsCount++
1256 | 	})
1257 | 
1258 | 	hooks.AddAfterListTools(func(ctx context.Context, id any, message *mcp.ListToolsRequest, result *mcp.ListToolsResult) {
1259 | 		afterToolsCount++
1260 | 	})
1261 | 
1262 | 	// Create a server with the hooks
1263 | 	server := NewMCPServer(
1264 | 		"test-server",
1265 | 		"1.0.0",
1266 | 		WithHooks(hooks),
1267 | 		WithToolCapabilities(true),
1268 | 	)
1269 | 
1270 | 	// Add a test tool
1271 | 	server.AddTool(
1272 | 		mcp.NewTool("test-tool"),
1273 | 		func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
1274 | 			return &mcp.CallToolResult{}, nil
1275 | 		},
1276 | 	)
1277 | 
1278 | 	// Initialize the server
1279 | 	_ = server.HandleMessage(context.Background(), []byte(`{
1280 | 		"jsonrpc": "2.0",
1281 | 		"id": 1,
1282 | 		"method": "initialize"
1283 | 	}`))
1284 | 
1285 | 	// Test 1: Verify ping method hooks
1286 | 	pingResponse := server.HandleMessage(context.Background(), []byte(`{
1287 | 		"jsonrpc": "2.0",
1288 | 		"id": 2,
1289 | 		"method": "ping"
1290 | 	}`))
1291 | 
1292 | 	// Verify success response
1293 | 	assert.IsType(t, mcp.JSONRPCResponse{}, pingResponse)
1294 | 
1295 | 	// Test 2: Verify tools/list method hooks
1296 | 	toolsListResponse := server.HandleMessage(context.Background(), []byte(`{
1297 | 		"jsonrpc": "2.0",
1298 | 		"id": 3,
1299 | 		"method": "tools/list"
1300 | 	}`))
1301 | 
1302 | 	// Verify success response
1303 | 	assert.IsType(t, mcp.JSONRPCResponse{}, toolsListResponse)
1304 | 
1305 | 	// Test 3: Verify error hooks with invalid tool
1306 | 	errorResponse := server.HandleMessage(context.Background(), []byte(`{
1307 | 		"jsonrpc": "2.0",
1308 | 		"id": 4,
1309 | 		"method": "tools/call",
1310 | 		"params": {
1311 | 			"name": "non-existent-tool"
1312 | 		}
1313 | 	}`))
1314 | 
1315 | 	// Verify error response
1316 | 	assert.IsType(t, mcp.JSONRPCError{}, errorResponse)
1317 | 
1318 | 	// Verify hook counts
1319 | 
1320 | 	// Method-specific hooks should be called exactly once
1321 | 	assert.Equal(t, 1, beforePingCount, "beforePing should be called once")
1322 | 	assert.Equal(t, 1, afterPingCount, "afterPing should be called once")
1323 | 	assert.Equal(t, 1, beforeToolsCount, "beforeListTools should be called once")
1324 | 	assert.Equal(t, 1, afterToolsCount, "afterListTools should be called once")
1325 | 
1326 | 	// General hooks should be called for all methods
1327 | 	// beforeAny is called for all 4 methods (initialize, ping, tools/list, tools/call)
1328 | 	assert.Equal(t, 4, beforeAnyCount, "beforeAny should be called for each method")
1329 | 	// onSuccess is called for all 3 success methods (initialize, ping, tools/list)
1330 | 	assert.Equal(t, 3, onSuccessCount, "onSuccess should be called after all successful invocations")
1331 | 
1332 | 	// Error hook should be called once for the failed tools/call
1333 | 	assert.Equal(t, 1, onErrorCount, "onError should be called once")
1334 | 
1335 | 	// Verify type matching between BeforeAny and BeforePing
1336 | 	require.Len(t, beforePingMessages, 1, "Expected one BeforePing message")
1337 | 	require.Len(t, beforeAnyMessages, 1, "Expected one BeforeAny Ping message")
1338 | 	assert.IsType(t, beforePingMessages[0], beforeAnyMessages[0], "BeforeAny message should be same type as BeforePing message")
1339 | 
1340 | 	// Verify type matching between OnSuccess and AfterPing
1341 | 	require.Len(t, afterPingData, 1, "Expected one AfterPing message/result pair")
1342 | 	require.Len(t, onSuccessData, 1, "Expected one OnSuccess Ping message/result pair")
1343 | 	assert.IsType(t, afterPingData[0].msg, onSuccessData[0].msg, "OnSuccess message should be same type as AfterPing message")
1344 | 	assert.IsType(t, afterPingData[0].res, onSuccessData[0].res, "OnSuccess result should be same type as AfterPing result")
1345 | }
1346 | 


--------------------------------------------------------------------------------
/server/sse.go:
--------------------------------------------------------------------------------
  1 | package server
  2 | 
  3 | import (
  4 | 	"context"
  5 | 	"encoding/json"
  6 | 	"fmt"
  7 | 	"net/http"
  8 | 	"net/http/httptest"
  9 | 	"net/url"
 10 | 	"strings"
 11 | 	"sync"
 12 | 	"sync/atomic"
 13 | 
 14 | 	"github.com/google/uuid"
 15 | 	"github.com/mark3labs/mcp-go/mcp"
 16 | )
 17 | 
 18 | // sseSession represents an active SSE connection.
 19 | type sseSession struct {
 20 | 	writer              http.ResponseWriter
 21 | 	flusher             http.Flusher
 22 | 	done                chan struct{}
 23 | 	eventQueue          chan string // Channel for queuing events
 24 | 	sessionID           string
 25 | 	notificationChannel chan mcp.JSONRPCNotification
 26 | 	initialized         atomic.Bool
 27 | }
 28 | 
 29 | // SSEContextFunc is a function that takes an existing context and the current
 30 | // request and returns a potentially modified context based on the request
 31 | // content. This can be used to inject context values from headers, for example.
 32 | type SSEContextFunc func(ctx context.Context, r *http.Request) context.Context
 33 | 
 34 | func (s *sseSession) SessionID() string {
 35 | 	return s.sessionID
 36 | }
 37 | 
 38 | func (s *sseSession) NotificationChannel() chan<- mcp.JSONRPCNotification {
 39 | 	return s.notificationChannel
 40 | }
 41 | 
 42 | func (s *sseSession) Initialize() {
 43 | 	s.initialized.Store(true)
 44 | }
 45 | 
 46 | func (s *sseSession) Initialized() bool {
 47 | 	return s.initialized.Load()
 48 | }
 49 | 
 50 | var _ ClientSession = (*sseSession)(nil)
 51 | 
 52 | // SSEServer implements a Server-Sent Events (SSE) based MCP server.
 53 | // It provides real-time communication capabilities over HTTP using the SSE protocol.
 54 | type SSEServer struct {
 55 | 	server                       *MCPServer
 56 | 	baseURL                      string
 57 | 	basePath                     string
 58 | 	messageEndpoint              string
 59 | 	useFullURLForMessageEndpoint bool
 60 | 	sseEndpoint                  string
 61 | 	sessions                     sync.Map
 62 | 	srv                          *http.Server
 63 | 	contextFunc                  SSEContextFunc
 64 | }
 65 | 
 66 | // SSEOption defines a function type for configuring SSEServer
 67 | type SSEOption func(*SSEServer)
 68 | 
 69 | // WithBaseURL sets the base URL for the SSE server
 70 | func WithBaseURL(baseURL string) SSEOption {
 71 | 	return func(s *SSEServer) {
 72 | 		if baseURL != "" {
 73 | 			u, err := url.Parse(baseURL)
 74 | 			if err != nil {
 75 | 				return
 76 | 			}
 77 | 			if u.Scheme != "http" && u.Scheme != "https" {
 78 | 				return
 79 | 			}
 80 | 			// Check if the host is empty or only contains a port
 81 | 			if u.Host == "" || strings.HasPrefix(u.Host, ":") {
 82 | 				return
 83 | 			}
 84 | 			if len(u.Query()) > 0 {
 85 | 				return
 86 | 			}
 87 | 		}
 88 | 		s.baseURL = strings.TrimSuffix(baseURL, "/")
 89 | 	}
 90 | }
 91 | 
 92 | // Add a new option for setting base path
 93 | func WithBasePath(basePath string) SSEOption {
 94 | 	return func(s *SSEServer) {
 95 | 		// Ensure the path starts with / and doesn't end with /
 96 | 		if !strings.HasPrefix(basePath, "/") {
 97 | 			basePath = "/" + basePath
 98 | 		}
 99 | 		s.basePath = strings.TrimSuffix(basePath, "/")
100 | 	}
101 | }
102 | 
103 | // WithMessageEndpoint sets the message endpoint path
104 | func WithMessageEndpoint(endpoint string) SSEOption {
105 | 	return func(s *SSEServer) {
106 | 		s.messageEndpoint = endpoint
107 | 	}
108 | }
109 | 
110 | // WithUseFullURLForMessageEndpoint controls whether the SSE server returns a complete URL (including baseURL)
111 | // or just the path portion for the message endpoint. Set to false when clients will concatenate
112 | // the baseURL themselves to avoid malformed URLs like "http://localhost/mcphttp://localhost/mcp/message".
113 | func WithUseFullURLForMessageEndpoint(useFullURLForMessageEndpoint bool) SSEOption {
114 | 	return func(s *SSEServer) {
115 | 		s.useFullURLForMessageEndpoint = useFullURLForMessageEndpoint
116 | 	}
117 | }
118 | 
119 | // WithSSEEndpoint sets the SSE endpoint path
120 | func WithSSEEndpoint(endpoint string) SSEOption {
121 | 	return func(s *SSEServer) {
122 | 		s.sseEndpoint = endpoint
123 | 	}
124 | }
125 | 
126 | // WithHTTPServer sets the HTTP server instance
127 | func WithHTTPServer(srv *http.Server) SSEOption {
128 | 	return func(s *SSEServer) {
129 | 		s.srv = srv
130 | 	}
131 | }
132 | 
133 | // WithContextFunc sets a function that will be called to customise the context
134 | // to the server using the incoming request.
135 | func WithSSEContextFunc(fn SSEContextFunc) SSEOption {
136 | 	return func(s *SSEServer) {
137 | 		s.contextFunc = fn
138 | 	}
139 | }
140 | 
141 | // NewSSEServer creates a new SSE server instance with the given MCP server and options.
142 | func NewSSEServer(server *MCPServer, opts ...SSEOption) *SSEServer {
143 | 	s := &SSEServer{
144 | 		server:                       server,
145 | 		sseEndpoint:                  "/sse",
146 | 		messageEndpoint:              "/message",
147 | 		useFullURLForMessageEndpoint: true,
148 | 	}
149 | 
150 | 	// Apply all options
151 | 	for _, opt := range opts {
152 | 		opt(s)
153 | 	}
154 | 
155 | 	return s
156 | }
157 | 
158 | // NewTestServer creates a test server for testing purposes
159 | func NewTestServer(server *MCPServer, opts ...SSEOption) *httptest.Server {
160 | 	sseServer := NewSSEServer(server)
161 | 	for _, opt := range opts {
162 | 		opt(sseServer)
163 | 	}
164 | 
165 | 	testServer := httptest.NewServer(sseServer)
166 | 	sseServer.baseURL = testServer.URL
167 | 	return testServer
168 | }
169 | 
170 | // Start begins serving SSE connections on the specified address.
171 | // It sets up HTTP handlers for SSE and message endpoints.
172 | func (s *SSEServer) Start(addr string) error {
173 | 	s.srv = &http.Server{
174 | 		Addr:    addr,
175 | 		Handler: s,
176 | 	}
177 | 
178 | 	return s.srv.ListenAndServe()
179 | }
180 | 
181 | // Shutdown gracefully stops the SSE server, closing all active sessions
182 | // and shutting down the HTTP server.
183 | func (s *SSEServer) Shutdown(ctx context.Context) error {
184 | 	if s.srv != nil {
185 | 		s.sessions.Range(func(key, value interface{}) bool {
186 | 			if session, ok := value.(*sseSession); ok {
187 | 				close(session.done)
188 | 			}
189 | 			s.sessions.Delete(key)
190 | 			return true
191 | 		})
192 | 
193 | 		return s.srv.Shutdown(ctx)
194 | 	}
195 | 	return nil
196 | }
197 | 
198 | // handleSSE handles incoming SSE connection requests.
199 | // It sets up appropriate headers and creates a new session for the client.
200 | func (s *SSEServer) handleSSE(w http.ResponseWriter, r *http.Request) {
201 | 	if r.Method != http.MethodGet {
202 | 		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
203 | 		return
204 | 	}
205 | 
206 | 	w.Header().Set("Content-Type", "text/event-stream")
207 | 	w.Header().Set("Cache-Control", "no-cache")
208 | 	w.Header().Set("Connection", "keep-alive")
209 | 	w.Header().Set("Access-Control-Allow-Origin", "*")
210 | 
211 | 	flusher, ok := w.(http.Flusher)
212 | 	if !ok {
213 | 		http.Error(w, "Streaming unsupported", http.StatusInternalServerError)
214 | 		return
215 | 	}
216 | 
217 | 	sessionID := uuid.New().String()
218 | 	session := &sseSession{
219 | 		writer:              w,
220 | 		flusher:             flusher,
221 | 		done:                make(chan struct{}),
222 | 		eventQueue:          make(chan string, 100), // Buffer for events
223 | 		sessionID:           sessionID,
224 | 		notificationChannel: make(chan mcp.JSONRPCNotification, 100),
225 | 	}
226 | 
227 | 	s.sessions.Store(sessionID, session)
228 | 	defer s.sessions.Delete(sessionID)
229 | 
230 | 	if err := s.server.RegisterSession(r.Context(), session); err != nil {
231 | 		http.Error(w, fmt.Sprintf("Session registration failed: %v", err), http.StatusInternalServerError)
232 | 		return
233 | 	}
234 | 	defer s.server.UnregisterSession(sessionID)
235 | 
236 | 	// Start notification handler for this session
237 | 	go func() {
238 | 		for {
239 | 			select {
240 | 			case notification := <-session.notificationChannel:
241 | 				eventData, err := json.Marshal(notification)
242 | 				if err == nil {
243 | 					select {
244 | 					case session.eventQueue <- fmt.Sprintf("event: message\ndata: %s\n\n", eventData):
245 | 						// Event queued successfully
246 | 					case <-session.done:
247 | 						return
248 | 					}
249 | 				}
250 | 			case <-session.done:
251 | 				return
252 | 			case <-r.Context().Done():
253 | 				return
254 | 			}
255 | 		}
256 | 	}()
257 | 
258 | 	// Send the initial endpoint event
259 | 	fmt.Fprintf(w, "event: endpoint\ndata: %s\r\n\r\n", s.GetMessageEndpointForClient(sessionID))
260 | 	flusher.Flush()
261 | 
262 | 	// Main event loop - this runs in the HTTP handler goroutine
263 | 	for {
264 | 		select {
265 | 		case event := <-session.eventQueue:
266 | 			// Write the event to the response
267 | 			fmt.Fprint(w, event)
268 | 			flusher.Flush()
269 | 		case <-r.Context().Done():
270 | 			close(session.done)
271 | 			return
272 | 		}
273 | 	}
274 | }
275 | 
276 | // GetMessageEndpointForClient returns the appropriate message endpoint URL with session ID
277 | // based on the useFullURLForMessageEndpoint configuration.
278 | func (s *SSEServer) GetMessageEndpointForClient(sessionID string) string {
279 | 	messageEndpoint := s.messageEndpoint
280 | 	if s.useFullURLForMessageEndpoint {
281 | 		messageEndpoint = s.CompleteMessageEndpoint()
282 | 	}
283 | 	return fmt.Sprintf("%s?sessionId=%s", messageEndpoint, sessionID)
284 | }
285 | 
286 | // handleMessage processes incoming JSON-RPC messages from clients and sends responses
287 | // back through both the SSE connection and HTTP response.
288 | func (s *SSEServer) handleMessage(w http.ResponseWriter, r *http.Request) {
289 | 	if r.Method != http.MethodPost {
290 | 		s.writeJSONRPCError(w, nil, mcp.INVALID_REQUEST, "Method not allowed")
291 | 		return
292 | 	}
293 | 
294 | 	sessionID := r.URL.Query().Get("sessionId")
295 | 	if sessionID == "" {
296 | 		s.writeJSONRPCError(w, nil, mcp.INVALID_PARAMS, "Missing sessionId")
297 | 		return
298 | 	}
299 | 
300 | 	sessionI, ok := s.sessions.Load(sessionID)
301 | 	if !ok {
302 | 		s.writeJSONRPCError(w, nil, mcp.INVALID_PARAMS, "Invalid session ID")
303 | 		return
304 | 	}
305 | 	session := sessionI.(*sseSession)
306 | 
307 | 	// Set the client context before handling the message
308 | 	ctx := s.server.WithContext(r.Context(), session)
309 | 	if s.contextFunc != nil {
310 | 		ctx = s.contextFunc(ctx, r)
311 | 	}
312 | 
313 | 	// Parse message as raw JSON
314 | 	var rawMessage json.RawMessage
315 | 	if err := json.NewDecoder(r.Body).Decode(&rawMessage); err != nil {
316 | 		s.writeJSONRPCError(w, nil, mcp.PARSE_ERROR, "Parse error")
317 | 		return
318 | 	}
319 | 
320 | 	// Process message through MCPServer
321 | 	response := s.server.HandleMessage(ctx, rawMessage)
322 | 
323 | 	// Only send response if there is one (not for notifications)
324 | 	if response != nil {
325 | 		eventData, _ := json.Marshal(response)
326 | 
327 | 		// Queue the event for sending via SSE
328 | 		select {
329 | 		case session.eventQueue <- fmt.Sprintf("event: message\ndata: %s\n\n", eventData):
330 | 			// Event queued successfully
331 | 		case <-session.done:
332 | 			// Session is closed, don't try to queue
333 | 		default:
334 | 			// Queue is full, could log this
335 | 		}
336 | 
337 | 		// Send HTTP response
338 | 		w.Header().Set("Content-Type", "application/json")
339 | 		w.WriteHeader(http.StatusAccepted)
340 | 		json.NewEncoder(w).Encode(response)
341 | 	} else {
342 | 		// For notifications, just send 202 Accepted with no body
343 | 		w.WriteHeader(http.StatusAccepted)
344 | 	}
345 | }
346 | 
347 | // writeJSONRPCError writes a JSON-RPC error response with the given error details.
348 | func (s *SSEServer) writeJSONRPCError(
349 | 	w http.ResponseWriter,
350 | 	id interface{},
351 | 	code int,
352 | 	message string,
353 | ) {
354 | 	response := createErrorResponse(id, code, message)
355 | 	w.Header().Set("Content-Type", "application/json")
356 | 	w.WriteHeader(http.StatusBadRequest)
357 | 	json.NewEncoder(w).Encode(response)
358 | }
359 | 
360 | // SendEventToSession sends an event to a specific SSE session identified by sessionID.
361 | // Returns an error if the session is not found or closed.
362 | func (s *SSEServer) SendEventToSession(
363 | 	sessionID string,
364 | 	event interface{},
365 | ) error {
366 | 	sessionI, ok := s.sessions.Load(sessionID)
367 | 	if !ok {
368 | 		return fmt.Errorf("session not found: %s", sessionID)
369 | 	}
370 | 	session := sessionI.(*sseSession)
371 | 
372 | 	eventData, err := json.Marshal(event)
373 | 	if err != nil {
374 | 		return err
375 | 	}
376 | 
377 | 	// Queue the event for sending via SSE
378 | 	select {
379 | 	case session.eventQueue <- fmt.Sprintf("event: message\ndata: %s\n\n", eventData):
380 | 		return nil
381 | 	case <-session.done:
382 | 		return fmt.Errorf("session closed")
383 | 	default:
384 | 		return fmt.Errorf("event queue full")
385 | 	}
386 | }
387 | func (s *SSEServer) GetUrlPath(input string) (string, error) {
388 | 	parse, err := url.Parse(input)
389 | 	if err != nil {
390 | 		return "", fmt.Errorf("failed to parse URL %s: %w", input, err)
391 | 	}
392 | 	return parse.Path, nil
393 | }
394 | 
395 | func (s *SSEServer) CompleteSseEndpoint() string {
396 | 	return s.baseURL + s.basePath + s.sseEndpoint
397 | }
398 | func (s *SSEServer) CompleteSsePath() string {
399 | 	path, err := s.GetUrlPath(s.CompleteSseEndpoint())
400 | 	if err != nil {
401 | 		return s.basePath + s.sseEndpoint
402 | 	}
403 | 	return path
404 | }
405 | 
406 | func (s *SSEServer) CompleteMessageEndpoint() string {
407 | 	return s.baseURL + s.basePath + s.messageEndpoint
408 | }
409 | func (s *SSEServer) CompleteMessagePath() string {
410 | 	path, err := s.GetUrlPath(s.CompleteMessageEndpoint())
411 | 	if err != nil {
412 | 		return s.basePath + s.messageEndpoint
413 | 	}
414 | 	return path
415 | }
416 | 
417 | // ServeHTTP implements the http.Handler interface.
418 | func (s *SSEServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
419 | 	path := r.URL.Path
420 | 	// Use exact path matching rather than Contains
421 | 	ssePath := s.CompleteSsePath()
422 | 	if ssePath != "" && path == ssePath {
423 | 		s.handleSSE(w, r)
424 | 		return
425 | 	}
426 | 	messagePath := s.CompleteMessagePath()
427 | 	if messagePath != "" && path == messagePath {
428 | 		s.handleMessage(w, r)
429 | 		return
430 | 	}
431 | 
432 | 	http.NotFound(w, r)
433 | }
434 | 


--------------------------------------------------------------------------------
/server/sse_test.go:
--------------------------------------------------------------------------------
  1 | package server
  2 | 
  3 | import (
  4 | 	"bytes"
  5 | 	"context"
  6 | 	"encoding/json"
  7 | 	"fmt"
  8 | 	"math/rand"
  9 | 	"net/http"
 10 | 	"net/http/httptest"
 11 | 	"strings"
 12 | 	"sync"
 13 | 	"testing"
 14 | 	"time"
 15 | 
 16 | 	"github.com/mark3labs/mcp-go/mcp"
 17 | )
 18 | 
 19 | func TestSSEServer(t *testing.T) {
 20 | 	t.Run("Can instantiate", func(t *testing.T) {
 21 | 		mcpServer := NewMCPServer("test", "1.0.0")
 22 | 		sseServer := NewSSEServer(mcpServer,
 23 | 			WithBaseURL("http://localhost:8080"),
 24 | 			WithBasePath("/mcp"),
 25 | 		)
 26 | 
 27 | 		if sseServer == nil {
 28 | 			t.Error("SSEServer should not be nil")
 29 | 		}
 30 | 		if sseServer.server == nil {
 31 | 			t.Error("MCPServer should not be nil")
 32 | 		}
 33 | 		if sseServer.baseURL != "http://localhost:8080" {
 34 | 			t.Errorf(
 35 | 				"Expected baseURL http://localhost:8080, got %s",
 36 | 				sseServer.baseURL,
 37 | 			)
 38 | 		}
 39 | 		if sseServer.basePath != "/mcp" {
 40 | 			t.Errorf(
 41 | 				"Expected basePath /mcp, got %s",
 42 | 				sseServer.basePath,
 43 | 			)
 44 | 		}
 45 | 	})
 46 | 
 47 | 	t.Run("Can send and receive messages", func(t *testing.T) {
 48 | 		mcpServer := NewMCPServer("test", "1.0.0",
 49 | 			WithResourceCapabilities(true, true),
 50 | 		)
 51 | 		testServer := NewTestServer(mcpServer)
 52 | 		defer testServer.Close()
 53 | 
 54 | 		// Connect to SSE endpoint
 55 | 		sseResp, err := http.Get(fmt.Sprintf("%s/sse", testServer.URL))
 56 | 		if err != nil {
 57 | 			t.Fatalf("Failed to connect to SSE endpoint: %v", err)
 58 | 		}
 59 | 		defer sseResp.Body.Close()
 60 | 
 61 | 		// Read the endpoint event
 62 | 		buf := make([]byte, 1024)
 63 | 		n, err := sseResp.Body.Read(buf)
 64 | 		if err != nil {
 65 | 			t.Fatalf("Failed to read SSE response: %v", err)
 66 | 		}
 67 | 
 68 | 		endpointEvent := string(buf[:n])
 69 | 		if !strings.Contains(endpointEvent, "event: endpoint") {
 70 | 			t.Fatalf("Expected endpoint event, got: %s", endpointEvent)
 71 | 		}
 72 | 
 73 | 		// Extract message endpoint URL
 74 | 		messageURL := strings.TrimSpace(
 75 | 			strings.Split(strings.Split(endpointEvent, "data: ")[1], "\n")[0],
 76 | 		)
 77 | 
 78 | 		// Send initialize request
 79 | 		initRequest := map[string]interface{}{
 80 | 			"jsonrpc": "2.0",
 81 | 			"id":      1,
 82 | 			"method":  "initialize",
 83 | 			"params": map[string]interface{}{
 84 | 				"protocolVersion": "2024-11-05",
 85 | 				"clientInfo": map[string]interface{}{
 86 | 					"name":    "test-client",
 87 | 					"version": "1.0.0",
 88 | 				},
 89 | 			},
 90 | 		}
 91 | 
 92 | 		requestBody, err := json.Marshal(initRequest)
 93 | 		if err != nil {
 94 | 			t.Fatalf("Failed to marshal request: %v", err)
 95 | 		}
 96 | 
 97 | 		resp, err := http.Post(
 98 | 			messageURL,
 99 | 			"application/json",
100 | 			bytes.NewBuffer(requestBody),
101 | 		)
102 | 		if err != nil {
103 | 			t.Fatalf("Failed to send message: %v", err)
104 | 		}
105 | 		defer resp.Body.Close()
106 | 
107 | 		if resp.StatusCode != http.StatusAccepted {
108 | 			t.Errorf("Expected status 202, got %d", resp.StatusCode)
109 | 		}
110 | 
111 | 		// Verify response
112 | 		var response map[string]interface{}
113 | 		if err := json.NewDecoder(resp.Body).Decode(&response); err != nil {
114 | 			t.Fatalf("Failed to decode response: %v", err)
115 | 		}
116 | 
117 | 		if response["jsonrpc"] != "2.0" {
118 | 			t.Errorf("Expected jsonrpc 2.0, got %v", response["jsonrpc"])
119 | 		}
120 | 		if response["id"].(float64) != 1 {
121 | 			t.Errorf("Expected id 1, got %v", response["id"])
122 | 		}
123 | 	})
124 | 
125 | 	t.Run("Can handle multiple sessions", func(t *testing.T) {
126 | 		mcpServer := NewMCPServer("test", "1.0.0",
127 | 			WithResourceCapabilities(true, true),
128 | 		)
129 | 		testServer := NewTestServer(mcpServer)
130 | 		defer testServer.Close()
131 | 
132 | 		numSessions := 3
133 | 		var wg sync.WaitGroup
134 | 		wg.Add(numSessions)
135 | 
136 | 		for i := 0; i < numSessions; i++ {
137 | 			go func(sessionNum int) {
138 | 				defer wg.Done()
139 | 
140 | 				// Connect to SSE endpoint
141 | 				sseResp, err := http.Get(fmt.Sprintf("%s/sse", testServer.URL))
142 | 				if err != nil {
143 | 					t.Errorf(
144 | 						"Session %d: Failed to connect to SSE endpoint: %v",
145 | 						sessionNum,
146 | 						err,
147 | 					)
148 | 					return
149 | 				}
150 | 				defer sseResp.Body.Close()
151 | 
152 | 				// Read the endpoint event
153 | 				buf := make([]byte, 1024)
154 | 				n, err := sseResp.Body.Read(buf)
155 | 				if err != nil {
156 | 					t.Errorf(
157 | 						"Session %d: Failed to read SSE response: %v",
158 | 						sessionNum,
159 | 						err,
160 | 					)
161 | 					return
162 | 				}
163 | 
164 | 				endpointEvent := string(buf[:n])
165 | 				messageURL := strings.TrimSpace(
166 | 					strings.Split(strings.Split(endpointEvent, "data: ")[1], "\n")[0],
167 | 				)
168 | 
169 | 				// Send initialize request
170 | 				initRequest := map[string]interface{}{
171 | 					"jsonrpc": "2.0",
172 | 					"id":      sessionNum,
173 | 					"method":  "initialize",
174 | 					"params": map[string]interface{}{
175 | 						"protocolVersion": "2024-11-05",
176 | 						"clientInfo": map[string]interface{}{
177 | 							"name": fmt.Sprintf(
178 | 								"test-client-%d",
179 | 								sessionNum,
180 | 							),
181 | 							"version": "1.0.0",
182 | 						},
183 | 					},
184 | 				}
185 | 
186 | 				requestBody, err := json.Marshal(initRequest)
187 | 				if err != nil {
188 | 					t.Errorf(
189 | 						"Session %d: Failed to marshal request: %v",
190 | 						sessionNum,
191 | 						err,
192 | 					)
193 | 					return
194 | 				}
195 | 
196 | 				resp, err := http.Post(
197 | 					messageURL,
198 | 					"application/json",
199 | 					bytes.NewBuffer(requestBody),
200 | 				)
201 | 				if err != nil {
202 | 					t.Errorf(
203 | 						"Session %d: Failed to send message: %v",
204 | 						sessionNum,
205 | 						err,
206 | 					)
207 | 					return
208 | 				}
209 | 				defer resp.Body.Close()
210 | 
211 | 				var response map[string]interface{}
212 | 				if err := json.NewDecoder(resp.Body).Decode(&response); err != nil {
213 | 					t.Errorf(
214 | 						"Session %d: Failed to decode response: %v",
215 | 						sessionNum,
216 | 						err,
217 | 					)
218 | 					return
219 | 				}
220 | 
221 | 				if response["id"].(float64) != float64(sessionNum) {
222 | 					t.Errorf(
223 | 						"Session %d: Expected id %d, got %v",
224 | 						sessionNum,
225 | 						sessionNum,
226 | 						response["id"],
227 | 					)
228 | 				}
229 | 			}(i)
230 | 		}
231 | 
232 | 		// Wait with timeout
233 | 		done := make(chan struct{})
234 | 		go func() {
235 | 			wg.Wait()
236 | 			close(done)
237 | 		}()
238 | 
239 | 		select {
240 | 		case <-done:
241 | 			// All sessions completed successfully
242 | 		case <-time.After(5 * time.Second):
243 | 			t.Fatal("Timeout waiting for sessions to complete")
244 | 		}
245 | 	})
246 | 
247 | 	t.Run("Can be used as http.Handler", func(t *testing.T) {
248 | 		mcpServer := NewMCPServer("test", "1.0.0")
249 | 		sseServer := NewSSEServer(mcpServer, WithBaseURL("http://localhost:8080"))
250 | 
251 | 		ts := httptest.NewServer(sseServer)
252 | 		defer ts.Close()
253 | 
254 | 		// Test 404 for unknown path first (simpler case)
255 | 		resp, err := http.Get(fmt.Sprintf("%s/unknown", ts.URL))
256 | 		if err != nil {
257 | 			t.Fatalf("Failed to make request: %v", err)
258 | 		}
259 | 		defer resp.Body.Close()
260 | 		if resp.StatusCode != http.StatusNotFound {
261 | 			t.Errorf("Expected status 404, got %d", resp.StatusCode)
262 | 		}
263 | 
264 | 		// Test SSE endpoint with proper cleanup
265 | 		ctx, cancel := context.WithCancel(context.Background())
266 | 		defer cancel()
267 | 
268 | 		req, err := http.NewRequestWithContext(ctx, "GET", fmt.Sprintf("%s/sse", ts.URL), nil)
269 | 		if err != nil {
270 | 			t.Fatalf("Failed to create request: %v", err)
271 | 		}
272 | 
273 | 		resp, err = http.DefaultClient.Do(req)
274 | 		if err != nil {
275 | 			t.Fatalf("Failed to connect to SSE endpoint: %v", err)
276 | 		}
277 | 		defer resp.Body.Close()
278 | 
279 | 		if resp.StatusCode != http.StatusOK {
280 | 			t.Errorf("Expected status 200, got %d", resp.StatusCode)
281 | 		}
282 | 
283 | 		// Read initial message in goroutine
284 | 		done := make(chan struct{})
285 | 		go func() {
286 | 			defer close(done)
287 | 			buf := make([]byte, 1024)
288 | 			_, err := resp.Body.Read(buf)
289 | 			if err != nil && err.Error() != "context canceled" {
290 | 				t.Errorf("Failed to read from SSE stream: %v", err)
291 | 			}
292 | 		}()
293 | 
294 | 		// Wait briefly for initial response then cancel
295 | 		time.Sleep(100 * time.Millisecond)
296 | 		cancel()
297 | 		<-done
298 | 	})
299 | 
300 | 	t.Run("Works with middleware", func(t *testing.T) {
301 | 		mcpServer := NewMCPServer("test", "1.0.0")
302 | 		sseServer := NewSSEServer(mcpServer, WithBaseURL("http://localhost:8080"))
303 | 
304 | 		middleware := func(next http.Handler) http.Handler {
305 | 			return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
306 | 				w.Header().Set("X-Test", "middleware")
307 | 				next.ServeHTTP(w, r)
308 | 			})
309 | 		}
310 | 
311 | 		ts := httptest.NewServer(middleware(sseServer))
312 | 		defer ts.Close()
313 | 
314 | 		ctx, cancel := context.WithCancel(context.Background())
315 | 		defer cancel()
316 | 
317 | 		req, err := http.NewRequestWithContext(ctx, "GET", fmt.Sprintf("%s/sse", ts.URL), nil)
318 | 		if err != nil {
319 | 			t.Fatalf("Failed to create request: %v", err)
320 | 		}
321 | 
322 | 		resp, err := http.DefaultClient.Do(req)
323 | 		if err != nil {
324 | 			t.Fatalf("Failed to connect to SSE endpoint: %v", err)
325 | 		}
326 | 		defer resp.Body.Close()
327 | 
328 | 		if resp.Header.Get("X-Test") != "middleware" {
329 | 			t.Error("Middleware header not found")
330 | 		}
331 | 
332 | 		// Read initial message in goroutine
333 | 		done := make(chan struct{})
334 | 		go func() {
335 | 			defer close(done)
336 | 			buf := make([]byte, 1024)
337 | 			_, err := resp.Body.Read(buf)
338 | 			if err != nil && err.Error() != "context canceled" {
339 | 				t.Errorf("Failed to read from SSE stream: %v", err)
340 | 			}
341 | 		}()
342 | 
343 | 		// Wait briefly then cancel
344 | 		time.Sleep(100 * time.Millisecond)
345 | 		cancel()
346 | 		<-done
347 | 	})
348 | 
349 | 	t.Run("Works with custom mux", func(t *testing.T) {
350 | 		mcpServer := NewMCPServer("test", "1.0.0")
351 | 		sseServer := NewSSEServer(mcpServer)
352 | 
353 | 		mux := http.NewServeMux()
354 | 		mux.Handle("/mcp/", sseServer)
355 | 
356 | 		ts := httptest.NewServer(mux)
357 | 		defer ts.Close()
358 | 
359 | 		sseServer.baseURL = ts.URL + "/mcp"
360 | 
361 | 		ctx, cancel := context.WithCancel(context.Background())
362 | 		defer cancel()
363 | 
364 | 		req, err := http.NewRequestWithContext(ctx, "GET", fmt.Sprintf("%s/mcp/sse", ts.URL), nil)
365 | 		if err != nil {
366 | 			t.Fatalf("Failed to create request: %v", err)
367 | 		}
368 | 
369 | 		resp, err := http.DefaultClient.Do(req)
370 | 		if err != nil {
371 | 			t.Fatalf("Failed to connect to SSE endpoint: %v", err)
372 | 		}
373 | 		defer resp.Body.Close()
374 | 
375 | 		if resp.StatusCode != http.StatusOK {
376 | 			t.Errorf("Expected status 200, got %d", resp.StatusCode)
377 | 		}
378 | 
379 | 		// Read the endpoint event
380 | 		buf := make([]byte, 1024)
381 | 		n, err := resp.Body.Read(buf)
382 | 		if err != nil {
383 | 			t.Fatalf("Failed to read SSE response: %v", err)
384 | 		}
385 | 
386 | 		endpointEvent := string(buf[:n])
387 | 		messageURL := strings.TrimSpace(
388 | 			strings.Split(strings.Split(endpointEvent, "data: ")[1], "\n")[0],
389 | 		)
390 | 
391 | 		// The messageURL should already be correct since we set the baseURL correctly
392 | 		// Test message endpoint
393 | 		initRequest := map[string]interface{}{
394 | 			"jsonrpc": "2.0",
395 | 			"id":      1,
396 | 			"method":  "initialize",
397 | 			"params": map[string]interface{}{
398 | 				"protocolVersion": "2024-11-05",
399 | 				"clientInfo": map[string]interface{}{
400 | 					"name":    "test-client",
401 | 					"version": "1.0.0",
402 | 				},
403 | 			},
404 | 		}
405 | 		requestBody, _ := json.Marshal(initRequest)
406 | 
407 | 		resp, err = http.Post(messageURL, "application/json", bytes.NewBuffer(requestBody))
408 | 		if err != nil {
409 | 			t.Fatalf("Failed to send message: %v", err)
410 | 		}
411 | 		defer resp.Body.Close()
412 | 
413 | 		if resp.StatusCode != http.StatusAccepted {
414 | 			t.Errorf("Expected status 202, got %d", resp.StatusCode)
415 | 		}
416 | 
417 | 		// Clean up SSE connection
418 | 		cancel()
419 | 	})
420 | 
421 | 	t.Run("test useFullURLForMessageEndpoint", func(t *testing.T) {
422 | 		mcpServer := NewMCPServer("test", "1.0.0")
423 | 		sseServer := NewSSEServer(mcpServer)
424 | 
425 | 		mux := http.NewServeMux()
426 | 		mux.Handle("/mcp/", sseServer)
427 | 
428 | 		ts := httptest.NewServer(mux)
429 | 		defer ts.Close()
430 | 
431 | 		sseServer.baseURL = ts.URL + "/mcp"
432 | 		sseServer.useFullURLForMessageEndpoint = false
433 | 		ctx, cancel := context.WithCancel(context.Background())
434 | 		defer cancel()
435 | 
436 | 		req, err := http.NewRequestWithContext(ctx, "GET", fmt.Sprintf("%s/sse", sseServer.baseURL), nil)
437 | 		if err != nil {
438 | 			t.Fatalf("Failed to create request: %v", err)
439 | 		}
440 | 
441 | 		resp, err := http.DefaultClient.Do(req)
442 | 		if err != nil {
443 | 			t.Fatalf("Failed to connect to SSE endpoint: %v", err)
444 | 		}
445 | 		defer resp.Body.Close()
446 | 
447 | 		if resp.StatusCode != http.StatusOK {
448 | 			t.Errorf("Expected status 200, got %d", resp.StatusCode)
449 | 		}
450 | 
451 | 		// Read the endpoint event
452 | 		buf := make([]byte, 1024)
453 | 		n, err := resp.Body.Read(buf)
454 | 		if err != nil {
455 | 			t.Fatalf("Failed to read SSE response: %v", err)
456 | 		}
457 | 
458 | 		endpointEvent := string(buf[:n])
459 | 		messageURL := strings.TrimSpace(
460 | 			strings.Split(strings.Split(endpointEvent, "data: ")[1], "\n")[0],
461 | 		)
462 | 		if !strings.HasPrefix(messageURL, sseServer.messageEndpoint) {
463 | 			t.Errorf("Expected messageURL to be %s, got %s", sseServer.messageEndpoint, messageURL)
464 | 		}
465 | 
466 | 		// The messageURL should already be correct since we set the baseURL correctly
467 | 		// Test message endpoint
468 | 		initRequest := map[string]interface{}{
469 | 			"jsonrpc": "2.0",
470 | 			"id":      1,
471 | 			"method":  "initialize",
472 | 			"params": map[string]interface{}{
473 | 				"protocolVersion": "2024-11-05",
474 | 				"clientInfo": map[string]interface{}{
475 | 					"name":    "test-client",
476 | 					"version": "1.0.0",
477 | 				},
478 | 			},
479 | 		}
480 | 		requestBody, _ := json.Marshal(initRequest)
481 | 
482 | 		resp, err = http.Post(sseServer.baseURL+messageURL, "application/json", bytes.NewBuffer(requestBody))
483 | 		if err != nil {
484 | 			t.Fatalf("Failed to send message: %v", err)
485 | 		}
486 | 		defer resp.Body.Close()
487 | 
488 | 		if resp.StatusCode != http.StatusAccepted {
489 | 			t.Errorf("Expected status 202, got %d", resp.StatusCode)
490 | 		}
491 | 
492 | 		// Clean up SSE connection
493 | 		cancel()
494 | 	})
495 | 
496 | 	t.Run("works as http.Handler with custom basePath", func(t *testing.T) {
497 | 		mcpServer := NewMCPServer("test", "1.0.0")
498 | 		sseServer := NewSSEServer(mcpServer, WithBasePath("/mcp"))
499 | 
500 | 		ts := httptest.NewServer(sseServer)
501 | 		defer ts.Close()
502 | 
503 | 		// Test 404 for unknown path first (simpler case)
504 | 		resp, err := http.Get(fmt.Sprintf("%s/sse", ts.URL))
505 | 		if err != nil {
506 | 			t.Fatalf("Failed to make request: %v", err)
507 | 		}
508 | 		defer resp.Body.Close()
509 | 		if resp.StatusCode != http.StatusNotFound {
510 | 			t.Errorf("Expected status 404, got %d", resp.StatusCode)
511 | 		}
512 | 
513 | 		// Test SSE endpoint with proper cleanup
514 | 		ctx, cancel := context.WithCancel(context.Background())
515 | 		defer cancel()
516 | 
517 | 		sseURL := fmt.Sprintf("%s/sse", ts.URL+sseServer.basePath)
518 | 		req, err := http.NewRequestWithContext(ctx, "GET", sseURL, nil)
519 | 		if err != nil {
520 | 			t.Fatalf("Failed to create request: %v", err)
521 | 		}
522 | 
523 | 		resp, err = http.DefaultClient.Do(req)
524 | 		if err != nil {
525 | 			t.Fatalf("Failed to connect to SSE endpoint: %v", err)
526 | 		}
527 | 		defer resp.Body.Close()
528 | 
529 | 		if resp.StatusCode != http.StatusOK {
530 | 			t.Errorf("Expected status 200, got %d", resp.StatusCode)
531 | 		}
532 | 
533 | 		// Read initial message in goroutine
534 | 		done := make(chan struct{})
535 | 		go func() {
536 | 			defer close(done)
537 | 			buf := make([]byte, 1024)
538 | 			_, err := resp.Body.Read(buf)
539 | 			if err != nil && err.Error() != "context canceled" {
540 | 				t.Errorf("Failed to read from SSE stream: %v", err)
541 | 			}
542 | 		}()
543 | 
544 | 		// Wait briefly for initial response then cancel
545 | 		time.Sleep(100 * time.Millisecond)
546 | 		cancel()
547 | 		<-done
548 | 	})
549 | 
550 | 	t.Run("Can use a custom context function", func(t *testing.T) {
551 | 		// Use a custom context key to store a test value.
552 | 		type testContextKey struct{}
553 | 		testValFromContext := func(ctx context.Context) string {
554 | 			val := ctx.Value(testContextKey{})
555 | 			if val == nil {
556 | 				return ""
557 | 			}
558 | 			return val.(string)
559 | 		}
560 | 		// Create a context function that sets a test value from the request.
561 | 		// In real life this could be used to send configuration using headers
562 | 		// or query parameters.
563 | 		const testHeader = "X-Test-Header"
564 | 		setTestValFromRequest := func(ctx context.Context, r *http.Request) context.Context {
565 | 			return context.WithValue(ctx, testContextKey{}, r.Header.Get(testHeader))
566 | 		}
567 | 
568 | 		mcpServer := NewMCPServer("test", "1.0.0",
569 | 			WithResourceCapabilities(true, true),
570 | 		)
571 | 		// Add a tool which uses the context function.
572 | 		mcpServer.AddTool(mcp.NewTool("test_tool"), func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
573 | 			// Note this is agnostic to the transport type i.e. doesn't know about request headers.
574 | 			testVal := testValFromContext(ctx)
575 | 			return mcp.NewToolResultText(testVal), nil
576 | 		})
577 | 
578 | 		testServer := NewTestServer(mcpServer, WithSSEContextFunc(setTestValFromRequest))
579 | 		defer testServer.Close()
580 | 
581 | 		// Connect to SSE endpoint
582 | 		sseResp, err := http.Get(fmt.Sprintf("%s/sse", testServer.URL))
583 | 		if err != nil {
584 | 			t.Fatalf("Failed to connect to SSE endpoint: %v", err)
585 | 		}
586 | 		defer sseResp.Body.Close()
587 | 
588 | 		// Read the endpoint event
589 | 		buf := make([]byte, 1024)
590 | 		n, err := sseResp.Body.Read(buf)
591 | 		if err != nil {
592 | 			t.Fatalf("Failed to read SSE response: %v", err)
593 | 		}
594 | 
595 | 		endpointEvent := string(buf[:n])
596 | 		messageURL := strings.TrimSpace(
597 | 			strings.Split(strings.Split(endpointEvent, "data: ")[1], "\n")[0],
598 | 		)
599 | 
600 | 		// Send initialize request
601 | 		initRequest := map[string]interface{}{
602 | 			"jsonrpc": "2.0",
603 | 			"id":      1,
604 | 			"method":  "initialize",
605 | 			"params": map[string]interface{}{
606 | 				"protocolVersion": "2024-11-05",
607 | 				"clientInfo": map[string]interface{}{
608 | 					"name":    "test-client",
609 | 					"version": "1.0.0",
610 | 				},
611 | 			},
612 | 		}
613 | 
614 | 		requestBody, err := json.Marshal(initRequest)
615 | 		if err != nil {
616 | 			t.Fatalf("Failed to marshal request: %v", err)
617 | 		}
618 | 
619 | 		resp, err := http.Post(
620 | 			messageURL,
621 | 			"application/json",
622 | 			bytes.NewBuffer(requestBody),
623 | 		)
624 | 
625 | 		if err != nil {
626 | 			t.Fatalf("Failed to send message: %v", err)
627 | 		}
628 | 		defer resp.Body.Close()
629 | 
630 | 		if resp.StatusCode != http.StatusAccepted {
631 | 			t.Errorf("Expected status 202, got %d", resp.StatusCode)
632 | 		}
633 | 
634 | 		// Verify response
635 | 		var response map[string]interface{}
636 | 		if err := json.NewDecoder(resp.Body).Decode(&response); err != nil {
637 | 			t.Fatalf("Failed to decode response: %v", err)
638 | 		}
639 | 
640 | 		if response["jsonrpc"] != "2.0" {
641 | 			t.Errorf("Expected jsonrpc 2.0, got %v", response["jsonrpc"])
642 | 		}
643 | 		if response["id"].(float64) != 1 {
644 | 			t.Errorf("Expected id 1, got %v", response["id"])
645 | 		}
646 | 
647 | 		// Call the tool.
648 | 		toolRequest := map[string]interface{}{
649 | 			"jsonrpc": "2.0",
650 | 			"id":      2,
651 | 			"method":  "tools/call",
652 | 			"params": map[string]interface{}{
653 | 				"name": "test_tool",
654 | 			},
655 | 		}
656 | 		requestBody, err = json.Marshal(toolRequest)
657 | 		if err != nil {
658 | 			t.Fatalf("Failed to marshal tool request: %v", err)
659 | 		}
660 | 
661 | 		req, err := http.NewRequest(http.MethodPost, messageURL, bytes.NewBuffer(requestBody))
662 | 		if err != nil {
663 | 			t.Fatalf("Failed to create tool request: %v", err)
664 | 		}
665 | 		// Set the test header to a custom value.
666 | 		req.Header.Set(testHeader, "test_value")
667 | 
668 | 		resp, err = http.DefaultClient.Do(req)
669 | 		if err != nil {
670 | 			t.Fatalf("Failed to call tool: %v", err)
671 | 		}
672 | 		defer resp.Body.Close()
673 | 
674 | 		response = make(map[string]interface{})
675 | 		if err := json.NewDecoder(resp.Body).Decode(&response); err != nil {
676 | 			t.Fatalf("Failed to decode response: %v", err)
677 | 		}
678 | 
679 | 		if response["jsonrpc"] != "2.0" {
680 | 			t.Errorf("Expected jsonrpc 2.0, got %v", response["jsonrpc"])
681 | 		}
682 | 		if response["id"].(float64) != 2 {
683 | 			t.Errorf("Expected id 2, got %v", response["id"])
684 | 		}
685 | 		if response["result"].(map[string]interface{})["content"].([]interface{})[0].(map[string]interface{})["text"] != "test_value" {
686 | 			t.Errorf("Expected result 'test_value', got %v", response["result"])
687 | 		}
688 | 		if response["error"] != nil {
689 | 			t.Errorf("Expected no error, got %v", response["error"])
690 | 		}
691 | 	})
692 | 
693 | 	t.Run("SSEOption should not have negative effects when used repeatedly but should always remain consistent.", func(t *testing.T) {
694 | 		mcpServer := NewMCPServer("test", "1.0.0")
695 | 		basePath := "/mcp-test"
696 | 		baseURL := "http://localhost:8080/test"
697 | 		messageEndpoint := "/message-test"
698 | 		sseEndpoint := "/sse-test"
699 | 		useFullURLForMessageEndpoint := false
700 | 		srv := &http.Server{}
701 | 		rands := []SSEOption{
702 | 			WithBasePath(basePath),
703 | 			WithBaseURL(baseURL),
704 | 			WithMessageEndpoint(messageEndpoint),
705 | 			WithUseFullURLForMessageEndpoint(useFullURLForMessageEndpoint),
706 | 			WithSSEEndpoint(sseEndpoint),
707 | 			WithHTTPServer(srv),
708 | 		}
709 | 		for i := 0; i < 100; i++ {
710 | 
711 | 			var options []SSEOption
712 | 			for i2 := 0; i2 < 100; i2++ {
713 | 				index := rand.Intn(len(rands))
714 | 				options = append(options, rands[index])
715 | 			}
716 | 			sseServer := NewSSEServer(mcpServer, options...)
717 | 
718 | 			if sseServer.basePath != basePath {
719 | 				t.Fatalf("basePath %v, got: %v", basePath, sseServer.basePath)
720 | 			}
721 | 			if sseServer.useFullURLForMessageEndpoint != useFullURLForMessageEndpoint {
722 | 				t.Fatalf("useFullURLForMessageEndpoint %v, got: %v", useFullURLForMessageEndpoint, sseServer.useFullURLForMessageEndpoint)
723 | 			}
724 | 
725 | 			if sseServer.baseURL != baseURL {
726 | 				t.Fatalf("baseURL %v, got: %v", baseURL, sseServer.baseURL)
727 | 			}
728 | 
729 | 			if sseServer.sseEndpoint != sseEndpoint {
730 | 				t.Fatalf("sseEndpoint %v, got: %v", sseEndpoint, sseServer.sseEndpoint)
731 | 			}
732 | 
733 | 			if sseServer.messageEndpoint != messageEndpoint {
734 | 				t.Fatalf("messageEndpoint  %v, got: %v", messageEndpoint, sseServer.messageEndpoint)
735 | 			}
736 | 
737 | 			if sseServer.srv != srv {
738 | 				t.Fatalf("srv  %v, got: %v", srv, sseServer.srv)
739 | 			}
740 | 		}
741 | 	})
742 | }
743 | 


--------------------------------------------------------------------------------
/server/stdio.go:
--------------------------------------------------------------------------------
  1 | package server
  2 | 
  3 | import (
  4 | 	"bufio"
  5 | 	"context"
  6 | 	"encoding/json"
  7 | 	"fmt"
  8 | 	"io"
  9 | 	"log"
 10 | 	"os"
 11 | 	"os/signal"
 12 | 	"sync/atomic"
 13 | 	"syscall"
 14 | 
 15 | 	"github.com/mark3labs/mcp-go/mcp"
 16 | )
 17 | 
 18 | // StdioContextFunc is a function that takes an existing context and returns
 19 | // a potentially modified context.
 20 | // This can be used to inject context values from environment variables,
 21 | // for example.
 22 | type StdioContextFunc func(ctx context.Context) context.Context
 23 | 
 24 | // StdioServer wraps a MCPServer and handles stdio communication.
 25 | // It provides a simple way to create command-line MCP servers that
 26 | // communicate via standard input/output streams using JSON-RPC messages.
 27 | type StdioServer struct {
 28 | 	server      *MCPServer
 29 | 	errLogger   *log.Logger
 30 | 	contextFunc StdioContextFunc
 31 | }
 32 | 
 33 | // StdioOption defines a function type for configuring StdioServer
 34 | type StdioOption func(*StdioServer)
 35 | 
 36 | // WithErrorLogger sets the error logger for the server
 37 | func WithErrorLogger(logger *log.Logger) StdioOption {
 38 | 	return func(s *StdioServer) {
 39 | 		s.errLogger = logger
 40 | 	}
 41 | }
 42 | 
 43 | // WithContextFunc sets a function that will be called to customise the context
 44 | // to the server. Note that the stdio server uses the same context for all requests,
 45 | // so this function will only be called once per server instance.
 46 | func WithStdioContextFunc(fn StdioContextFunc) StdioOption {
 47 | 	return func(s *StdioServer) {
 48 | 		s.contextFunc = fn
 49 | 	}
 50 | }
 51 | 
 52 | // stdioSession is a static client session, since stdio has only one client.
 53 | type stdioSession struct {
 54 | 	notifications chan mcp.JSONRPCNotification
 55 | 	initialized   atomic.Bool
 56 | }
 57 | 
 58 | func (s *stdioSession) SessionID() string {
 59 | 	return "stdio"
 60 | }
 61 | 
 62 | func (s *stdioSession) NotificationChannel() chan<- mcp.JSONRPCNotification {
 63 | 	return s.notifications
 64 | }
 65 | 
 66 | func (s *stdioSession) Initialize() {
 67 | 	s.initialized.Store(true)
 68 | }
 69 | 
 70 | func (s *stdioSession) Initialized() bool {
 71 | 	return s.initialized.Load()
 72 | }
 73 | 
 74 | var _ ClientSession = (*stdioSession)(nil)
 75 | 
 76 | var stdioSessionInstance = stdioSession{
 77 | 	notifications: make(chan mcp.JSONRPCNotification, 100),
 78 | }
 79 | 
 80 | // NewStdioServer creates a new stdio server wrapper around an MCPServer.
 81 | // It initializes the server with a default error logger that discards all output.
 82 | func NewStdioServer(server *MCPServer) *StdioServer {
 83 | 	return &StdioServer{
 84 | 		server: server,
 85 | 		errLogger: log.New(
 86 | 			os.Stderr,
 87 | 			"",
 88 | 			log.LstdFlags,
 89 | 		), // Default to discarding logs
 90 | 	}
 91 | }
 92 | 
 93 | // SetErrorLogger configures where error messages from the StdioServer are logged.
 94 | // The provided logger will receive all error messages generated during server operation.
 95 | func (s *StdioServer) SetErrorLogger(logger *log.Logger) {
 96 | 	s.errLogger = logger
 97 | }
 98 | 
 99 | // SetContextFunc sets a function that will be called to customise the context
100 | // to the server. Note that the stdio server uses the same context for all requests,
101 | // so this function will only be called once per server instance.
102 | func (s *StdioServer) SetContextFunc(fn StdioContextFunc) {
103 | 	s.contextFunc = fn
104 | }
105 | 
106 | // handleNotifications continuously processes notifications from the session's notification channel
107 | // and writes them to the provided output. It runs until the context is cancelled.
108 | // Any errors encountered while writing notifications are logged but do not stop the handler.
109 | func (s *StdioServer) handleNotifications(ctx context.Context, stdout io.Writer) {
110 | 	for {
111 | 		select {
112 | 		case notification := <-stdioSessionInstance.notifications:
113 | 			if err := s.writeResponse(notification, stdout); err != nil {
114 | 				s.errLogger.Printf("Error writing notification: %v", err)
115 | 			}
116 | 		case <-ctx.Done():
117 | 			return
118 | 		}
119 | 	}
120 | }
121 | 
122 | // processInputStream continuously reads and processes messages from the input stream.
123 | // It handles EOF gracefully as a normal termination condition.
124 | // The function returns when either:
125 | // - The context is cancelled (returns context.Err())
126 | // - EOF is encountered (returns nil)
127 | // - An error occurs while reading or processing messages (returns the error)
128 | func (s *StdioServer) processInputStream(ctx context.Context, reader *bufio.Reader, stdout io.Writer) error {
129 | 	for {
130 | 		if err := ctx.Err(); err != nil {
131 | 			return err
132 | 		}
133 | 
134 | 		line, err := s.readNextLine(ctx, reader)
135 | 		if err != nil {
136 | 			if err == io.EOF {
137 | 				return nil
138 | 			}
139 | 			s.errLogger.Printf("Error reading input: %v", err)
140 | 			return err
141 | 		}
142 | 
143 | 		if err := s.processMessage(ctx, line, stdout); err != nil {
144 | 			if err == io.EOF {
145 | 				return nil
146 | 			}
147 | 			s.errLogger.Printf("Error handling message: %v", err)
148 | 			return err
149 | 		}
150 | 	}
151 | }
152 | 
153 | // readNextLine reads a single line from the input reader in a context-aware manner.
154 | // It uses channels to make the read operation cancellable via context.
155 | // Returns the read line and any error encountered. If the context is cancelled,
156 | // returns an empty string and the context's error. EOF is returned when the input
157 | // stream is closed.
158 | func (s *StdioServer) readNextLine(ctx context.Context, reader *bufio.Reader) (string, error) {
159 | 	readChan := make(chan string, 1)
160 | 	errChan := make(chan error, 1)
161 | 	defer func() {
162 | 		close(readChan)
163 | 		close(errChan)
164 | 	}()
165 | 
166 | 	go func() {
167 | 		line, err := reader.ReadString('\n')
168 | 		if err != nil {
169 | 			errChan <- err
170 | 			return
171 | 		}
172 | 		readChan <- line
173 | 	}()
174 | 
175 | 	select {
176 | 	case <-ctx.Done():
177 | 		return "", ctx.Err()
178 | 	case err := <-errChan:
179 | 		return "", err
180 | 	case line := <-readChan:
181 | 		return line, nil
182 | 	}
183 | }
184 | 
185 | // Listen starts listening for JSON-RPC messages on the provided input and writes responses to the provided output.
186 | // It runs until the context is cancelled or an error occurs.
187 | // Returns an error if there are issues with reading input or writing output.
188 | func (s *StdioServer) Listen(
189 | 	ctx context.Context,
190 | 	stdin io.Reader,
191 | 	stdout io.Writer,
192 | ) error {
193 | 	// Set a static client context since stdio only has one client
194 | 	if err := s.server.RegisterSession(ctx, &stdioSessionInstance); err != nil {
195 | 		return fmt.Errorf("register session: %w", err)
196 | 	}
197 | 	defer s.server.UnregisterSession(stdioSessionInstance.SessionID())
198 | 	ctx = s.server.WithContext(ctx, &stdioSessionInstance)
199 | 
200 | 	// Add in any custom context.
201 | 	if s.contextFunc != nil {
202 | 		ctx = s.contextFunc(ctx)
203 | 	}
204 | 
205 | 	reader := bufio.NewReader(stdin)
206 | 
207 | 	// Start notification handler
208 | 	go s.handleNotifications(ctx, stdout)
209 | 	return s.processInputStream(ctx, reader, stdout)
210 | }
211 | 
212 | // processMessage handles a single JSON-RPC message and writes the response.
213 | // It parses the message, processes it through the wrapped MCPServer, and writes any response.
214 | // Returns an error if there are issues with message processing or response writing.
215 | func (s *StdioServer) processMessage(
216 | 	ctx context.Context,
217 | 	line string,
218 | 	writer io.Writer,
219 | ) error {
220 | 	// Parse the message as raw JSON
221 | 	var rawMessage json.RawMessage
222 | 	if err := json.Unmarshal([]byte(line), &rawMessage); err != nil {
223 | 		response := createErrorResponse(nil, mcp.PARSE_ERROR, "Parse error")
224 | 		return s.writeResponse(response, writer)
225 | 	}
226 | 
227 | 	// Handle the message using the wrapped server
228 | 	response := s.server.HandleMessage(ctx, rawMessage)
229 | 
230 | 	// Only write response if there is one (not for notifications)
231 | 	if response != nil {
232 | 		if err := s.writeResponse(response, writer); err != nil {
233 | 			return fmt.Errorf("failed to write response: %w", err)
234 | 		}
235 | 	}
236 | 
237 | 	return nil
238 | }
239 | 
240 | // writeResponse marshals and writes a JSON-RPC response message followed by a newline.
241 | // Returns an error if marshaling or writing fails.
242 | func (s *StdioServer) writeResponse(
243 | 	response mcp.JSONRPCMessage,
244 | 	writer io.Writer,
245 | ) error {
246 | 	responseBytes, err := json.Marshal(response)
247 | 	if err != nil {
248 | 		return err
249 | 	}
250 | 
251 | 	// Write response followed by newline
252 | 	if _, err := fmt.Fprintf(writer, "%s\n", responseBytes); err != nil {
253 | 		return err
254 | 	}
255 | 
256 | 	return nil
257 | }
258 | 
259 | // ServeStdio is a convenience function that creates and starts a StdioServer with os.Stdin and os.Stdout.
260 | // It sets up signal handling for graceful shutdown on SIGTERM and SIGINT.
261 | // Returns an error if the server encounters any issues during operation.
262 | func ServeStdio(server *MCPServer, opts ...StdioOption) error {
263 | 	s := NewStdioServer(server)
264 | 	s.SetErrorLogger(log.New(os.Stderr, "", log.LstdFlags))
265 | 
266 | 	for _, opt := range opts {
267 | 		opt(s)
268 | 	}
269 | 
270 | 	ctx, cancel := context.WithCancel(context.Background())
271 | 	defer cancel()
272 | 
273 | 	// Set up signal handling
274 | 	sigChan := make(chan os.Signal, 1)
275 | 	signal.Notify(sigChan, syscall.SIGTERM, syscall.SIGINT)
276 | 
277 | 	go func() {
278 | 		<-sigChan
279 | 		cancel()
280 | 	}()
281 | 
282 | 	return s.Listen(ctx, os.Stdin, os.Stdout)
283 | }
284 | 


--------------------------------------------------------------------------------
/server/stdio_test.go:
--------------------------------------------------------------------------------
  1 | package server
  2 | 
  3 | import (
  4 | 	"bufio"
  5 | 	"context"
  6 | 	"encoding/json"
  7 | 	"io"
  8 | 	"log"
  9 | 	"os"
 10 | 	"testing"
 11 | 
 12 | 	"github.com/mark3labs/mcp-go/mcp"
 13 | )
 14 | 
 15 | func TestStdioServer(t *testing.T) {
 16 | 	t.Run("Can instantiate", func(t *testing.T) {
 17 | 		mcpServer := NewMCPServer("test", "1.0.0")
 18 | 		stdioServer := NewStdioServer(mcpServer)
 19 | 
 20 | 		if stdioServer.server == nil {
 21 | 			t.Error("MCPServer should not be nil")
 22 | 		}
 23 | 		if stdioServer.errLogger == nil {
 24 | 			t.Error("errLogger should not be nil")
 25 | 		}
 26 | 	})
 27 | 
 28 | 	t.Run("Can send and receive messages", func(t *testing.T) {
 29 | 		// Create pipes for stdin and stdout
 30 | 		stdinReader, stdinWriter := io.Pipe()
 31 | 		stdoutReader, stdoutWriter := io.Pipe()
 32 | 
 33 | 		// Create server
 34 | 		mcpServer := NewMCPServer("test", "1.0.0",
 35 | 			WithResourceCapabilities(true, true),
 36 | 		)
 37 | 		stdioServer := NewStdioServer(mcpServer)
 38 | 		stdioServer.SetErrorLogger(log.New(io.Discard, "", 0))
 39 | 
 40 | 		// Create context with cancel
 41 | 		ctx, cancel := context.WithCancel(context.Background())
 42 | 		defer cancel()
 43 | 
 44 | 		// Create error channel to catch server errors
 45 | 		serverErrCh := make(chan error, 1)
 46 | 
 47 | 		// Start server in goroutine
 48 | 		go func() {
 49 | 			err := stdioServer.Listen(ctx, stdinReader, stdoutWriter)
 50 | 			if err != nil && err != io.EOF && err != context.Canceled {
 51 | 				serverErrCh <- err
 52 | 			}
 53 | 			close(serverErrCh)
 54 | 		}()
 55 | 
 56 | 		// Create test message
 57 | 		initRequest := map[string]interface{}{
 58 | 			"jsonrpc": "2.0",
 59 | 			"id":      1,
 60 | 			"method":  "initialize",
 61 | 			"params": map[string]interface{}{
 62 | 				"protocolVersion": "2024-11-05",
 63 | 				"clientInfo": map[string]interface{}{
 64 | 					"name":    "test-client",
 65 | 					"version": "1.0.0",
 66 | 				},
 67 | 			},
 68 | 		}
 69 | 
 70 | 		// Send request
 71 | 		requestBytes, err := json.Marshal(initRequest)
 72 | 		if err != nil {
 73 | 			t.Fatal(err)
 74 | 		}
 75 | 		_, err = stdinWriter.Write(append(requestBytes, '\n'))
 76 | 		if err != nil {
 77 | 			t.Fatal(err)
 78 | 		}
 79 | 
 80 | 		// Read response
 81 | 		scanner := bufio.NewScanner(stdoutReader)
 82 | 		if !scanner.Scan() {
 83 | 			t.Fatal("failed to read response")
 84 | 		}
 85 | 		responseBytes := scanner.Bytes()
 86 | 
 87 | 		var response map[string]interface{}
 88 | 		if err := json.Unmarshal(responseBytes, &response); err != nil {
 89 | 			t.Fatalf("failed to unmarshal response: %v", err)
 90 | 		}
 91 | 
 92 | 		// Verify response structure
 93 | 		if response["jsonrpc"] != "2.0" {
 94 | 			t.Errorf("expected jsonrpc version 2.0, got %v", response["jsonrpc"])
 95 | 		}
 96 | 		if response["id"].(float64) != 1 {
 97 | 			t.Errorf("expected id 1, got %v", response["id"])
 98 | 		}
 99 | 		if response["error"] != nil {
100 | 			t.Errorf("unexpected error in response: %v", response["error"])
101 | 		}
102 | 		if response["result"] == nil {
103 | 			t.Error("expected result in response")
104 | 		}
105 | 
106 | 		// Clean up
107 | 		cancel()
108 | 		stdinWriter.Close()
109 | 		stdoutWriter.Close()
110 | 
111 | 		// Check for server errors
112 | 		if err := <-serverErrCh; err != nil {
113 | 			t.Errorf("unexpected server error: %v", err)
114 | 		}
115 | 	})
116 | 
117 | 	t.Run("Can use a custom context function", func(t *testing.T) {
118 | 		// Use a custom context key to store a test value.
119 | 		type testContextKey struct{}
120 | 		testValFromContext := func(ctx context.Context) string {
121 | 			val := ctx.Value(testContextKey{})
122 | 			if val == nil {
123 | 				return ""
124 | 			}
125 | 			return val.(string)
126 | 		}
127 | 		// Create a context function that sets a test value from the environment.
128 | 		// In real life this could be used to send configuration in a similar way,
129 | 		// or from a config file.
130 | 		const testEnvVar = "TEST_ENV_VAR"
131 | 		setTestValFromEnv := func(ctx context.Context) context.Context {
132 | 			return context.WithValue(ctx, testContextKey{}, os.Getenv(testEnvVar))
133 | 		}
134 | 		t.Setenv(testEnvVar, "test_value")
135 | 
136 | 		// Create pipes for stdin and stdout
137 | 		stdinReader, stdinWriter := io.Pipe()
138 | 		stdoutReader, stdoutWriter := io.Pipe()
139 | 
140 | 		// Create server
141 | 		mcpServer := NewMCPServer("test", "1.0.0")
142 | 		// Add a tool which uses the context function.
143 | 		mcpServer.AddTool(mcp.NewTool("test_tool"), func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
144 | 			// Note this is agnostic to the transport type i.e. doesn't know about request headers.
145 | 			testVal := testValFromContext(ctx)
146 | 			return mcp.NewToolResultText(testVal), nil
147 | 		})
148 | 		stdioServer := NewStdioServer(mcpServer)
149 | 		stdioServer.SetErrorLogger(log.New(io.Discard, "", 0))
150 | 		stdioServer.SetContextFunc(setTestValFromEnv)
151 | 
152 | 		// Create context with cancel
153 | 		ctx, cancel := context.WithCancel(context.Background())
154 | 		defer cancel()
155 | 
156 | 		// Create error channel to catch server errors
157 | 		serverErrCh := make(chan error, 1)
158 | 
159 | 		// Start server in goroutine
160 | 		go func() {
161 | 			err := stdioServer.Listen(ctx, stdinReader, stdoutWriter)
162 | 			if err != nil && err != io.EOF && err != context.Canceled {
163 | 				serverErrCh <- err
164 | 			}
165 | 			close(serverErrCh)
166 | 		}()
167 | 
168 | 		// Create test message
169 | 		initRequest := map[string]interface{}{
170 | 			"jsonrpc": "2.0",
171 | 			"id":      1,
172 | 			"method":  "initialize",
173 | 			"params": map[string]interface{}{
174 | 				"protocolVersion": "2024-11-05",
175 | 				"clientInfo": map[string]interface{}{
176 | 					"name":    "test-client",
177 | 					"version": "1.0.0",
178 | 				},
179 | 			},
180 | 		}
181 | 
182 | 		// Send request
183 | 		requestBytes, err := json.Marshal(initRequest)
184 | 		if err != nil {
185 | 			t.Fatal(err)
186 | 		}
187 | 		_, err = stdinWriter.Write(append(requestBytes, '\n'))
188 | 		if err != nil {
189 | 			t.Fatal(err)
190 | 		}
191 | 
192 | 		// Read response
193 | 		scanner := bufio.NewScanner(stdoutReader)
194 | 		if !scanner.Scan() {
195 | 			t.Fatal("failed to read response")
196 | 		}
197 | 		responseBytes := scanner.Bytes()
198 | 
199 | 		var response map[string]interface{}
200 | 		if err := json.Unmarshal(responseBytes, &response); err != nil {
201 | 			t.Fatalf("failed to unmarshal response: %v", err)
202 | 		}
203 | 
204 | 		// Verify response structure
205 | 		if response["jsonrpc"] != "2.0" {
206 | 			t.Errorf("expected jsonrpc version 2.0, got %v", response["jsonrpc"])
207 | 		}
208 | 		if response["id"].(float64) != 1 {
209 | 			t.Errorf("expected id 1, got %v", response["id"])
210 | 		}
211 | 		if response["error"] != nil {
212 | 			t.Errorf("unexpected error in response: %v", response["error"])
213 | 		}
214 | 		if response["result"] == nil {
215 | 			t.Error("expected result in response")
216 | 		}
217 | 
218 | 		// Call the tool.
219 | 		toolRequest := map[string]interface{}{
220 | 			"jsonrpc": "2.0",
221 | 			"id":      2,
222 | 			"method":  "tools/call",
223 | 			"params": map[string]interface{}{
224 | 				"name": "test_tool",
225 | 			},
226 | 		}
227 | 		requestBytes, err = json.Marshal(toolRequest)
228 | 		if err != nil {
229 | 			t.Fatalf("Failed to marshal tool request: %v", err)
230 | 		}
231 | 
232 | 		_, err = stdinWriter.Write(append(requestBytes, '\n'))
233 | 		if err != nil {
234 | 			t.Fatal(err)
235 | 		}
236 | 
237 | 		if !scanner.Scan() {
238 | 			t.Fatal("failed to read response")
239 | 		}
240 | 		responseBytes = scanner.Bytes()
241 | 
242 | 		response = map[string]interface{}{}
243 | 		if err := json.Unmarshal(responseBytes, &response); err != nil {
244 | 			t.Fatalf("failed to unmarshal response: %v", err)
245 | 		}
246 | 
247 | 		if response["jsonrpc"] != "2.0" {
248 | 			t.Errorf("Expected jsonrpc 2.0, got %v", response["jsonrpc"])
249 | 		}
250 | 		if response["id"].(float64) != 2 {
251 | 			t.Errorf("Expected id 2, got %v", response["id"])
252 | 		}
253 | 		if response["result"].(map[string]interface{})["content"].([]interface{})[0].(map[string]interface{})["text"] != "test_value" {
254 | 			t.Errorf("Expected result 'test_value', got %v", response["result"])
255 | 		}
256 | 		if response["error"] != nil {
257 | 			t.Errorf("Expected no error, got %v", response["error"])
258 | 		}
259 | 
260 | 		// Clean up
261 | 		cancel()
262 | 		stdinWriter.Close()
263 | 		stdoutWriter.Close()
264 | 
265 | 		// Check for server errors
266 | 		if err := <-serverErrCh; err != nil {
267 | 			t.Errorf("unexpected server error: %v", err)
268 | 		}
269 | 	})
270 | }
271 | 


--------------------------------------------------------------------------------